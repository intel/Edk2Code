[
  {
    "title": "AccessAs (Change Field Unit Access)",
    "syntax": "AccessAs (AccessType, AccessAttribute)\nAccessAs (AccessType, AccessAttribute (AccessLength))",
    "arguments": "AccessType is an AccessTypeKeyword that specifies the type of access desired (ByteAcc, WordAcc, etc.).  AccessAttribute is an optional argument of type AccessAttributeKeyword that specifies additional protocols to be used, such as AttribQuick, AttribSendReceive, etc. AccessLength is a required argument for some of the Access Attributes.",
    "description": "The AccessAs operator is used within a FieldList to specify the Access Type, Access Attributes, and Access Length for the remaining FieldUnits within the list (or until another AccessAs operator  is encountered.) It allows FieldUnits to have different access types within a single Field definition.\nSupported AccessTypes:\n\u2022         AnyAcc\n\u2022         ByteAcc\n\u2022         WordAcc\n\u2022         DwordAcc\n\u2022         QWordAcc\n\u2022         BufferAcc\nSupported simple AccessAttributes (with SMBus synonyms):\n\u2022         AttribQuick (SMBQuick)\n\u2022         AttribSendReceive (SMBSendReceive)\n\u2022         AttribByte (SMBByte)\n\u2022         AttribWord (SMBWord)\n\u2022         AttribBlock (SMBBlock)\n\u2022         AttribProcessCall (SMBProcessCall)\n\u2022         AttribBlockProcessCall (SMBBlockProcessCall)\nAccess Attributes that require an AccessLength argument:\n\u2022         AttribBytes (AccessLength)\n\u2022         AttribRawBytes (AccessLength)\n\u2022         AttribRawProcessBytes (AccessLength)",
    "example": ""
  },
  {
    "title": "Acquire (Acquire a Mutex)",
    "syntax": "Acquire (SyncObject, TimeoutValue) => Boolean",
    "arguments": "SynchObject must be a mutex synchronization object. TimeoutValue is evaluated as an Integer.",
    "description": "Ownership of the Mutex is obtained. If the Mutex is already owned by a different invocation, the current execution thread is suspended until the owner of the Mutex releases it or until at least TimeoutValue milliseconds have elapsed. A Mutex can be acquired more than once by the same invocation.\nNote:            For Mutex objects referenced by a _DLM object, the host OS may also contend for ownership.\nThis operation returns True if a timeout occurred and the mutex ownership was not acquired. A TimeoutValue of 0xFFFF (or greater) indicates that there is no timeout and the operation will wait indefinitely.",
    "example": ""
  },
  {
    "title": "Add (Integer Add)",
    "syntax": "Add (Addend1, Addend2, Result) => Integer\nResult = Addend1 + Addend2 => Integer\nResult += Addend => Integer",
    "arguments": "Addend1 and Addend2 are evaluated as Integers.",
    "description": "The operands are added and the result is optionally stored into Result. Overflow conditions are ignored and the result of overflows simply loses the most significant bits.",
    "example": ""
  },
  {
    "title": "Alias (Declare Name Alias)",
    "syntax": "Alias (SourceObject, AliasObject)",
    "arguments": "SourceObject is any named object. AliasObject is a NameString.",
    "description": "Creates a new object named AliasObject that refers to and acts exactly the same as SourceObject.\nAliasObject is created as an alias of SourceObject in the namespace. The SourceObject name must already exist in the namespace. If the alias is to a name within the same definition block, the SourceObject name must be logically ahead of this definition in the block.",
    "example": "The following example shows the use of an Alias term:\nAlias (\\SUS.SET.EVEN, SSE)"
  },
  {
    "title": "And (Integer Bitwise And)",
    "syntax": "And (Source1, Source2, Result) => Integer\nResult = Source1 & Source2  => Integer\nResult &= Source => Integer",
    "arguments": "Source1 and Source2 are evaluated as Integers.",
    "description": "A bitwise AND is performed and the result is optionally stored into Result.",
    "example": ""
  },
  {
    "title": "Argx (Method Argument Data Objects)",
    "syntax": "Arg0 | Arg1 | Arg2 | Arg3 | Arg4 | Arg5 | Arg6",
    "arguments": "",
    "description": "Up to 7 argument-object references can be passed to a control method. On entry to a control method, only the argument objects that are passed are usable.",
    "example": ""
  },
  {
    "title": "BankField (Declare Bank/Data Field)",
    "syntax": "BankField (RegionName, BankName, BankValue, AccessType, LockRule, UpdateRule) {FieldUnitList}",
    "arguments": "RegionName is evaluated as a Namestring, and is the name of the host Operation Region.\nBankName is evaluated as a Namestring, and is the name of the bank selection register.\nBankValue is the bank selection ID (Integer) that is written to the BankName register before the FieldUnitList is accessed.\nThe AccessType, LockRule, UpdateRule, and FieldUnitList are the same format as the Field operator.",
    "description": "Accessing the contents of a banked field data object will occur automatically through the proper bank setting, with synchronization occurring on the operation region that contains the BankName data variable, and on the Global Lock if specified by the LockRule.\nThis operator creates data field objects. The contents of the created objects are obtained by a reference to a bank selection register.\nThis encoding is used to define named data field objects whose data values are fields within a larger object selected by a bank-selected register.",
    "example": "The following is a block of ASL sample code using BankField:\n\u2022       Creates a 4-bit bank-selected register in system I/O space.\n\u2022       Creates overlapping fields in the same system I/O space that are selected via the bank register.\n//\n// Define a 256-byte operational region in SystemIO space\n// and name it GIO0\nOperationRegion (GIO0, SystemIO, 0x125, 0x100)\n// Create some fields in GIO including a 4-bit bank select register\nField (GIO0, ByteAcc, NoLock, Preserve) {\n    GLB1, 1,\n    GLB2, 1,\n    Offset (1),            // Move to offset for byte 1\n    BNK1, 4\n}\n// Create FET0 & FET1 in bank 0 at byte offset 0x30\nBankField (GIO0, BNK1, 0, ByteAcc, NoLock, Preserve) {\n    Offset (0x30),       \n    FET0, 1,\n    FET1, 1\n}\n    // Create BLVL & BAC in bank 1 at the same offset\nBankField (GIO0, BNK1, 1, ByteAcc, NoLock, Preserve) {\n    Offset (0x30),\n    BLVL, 7,\n    BAC,  1\n}"
  },
  {
    "title": "Break (Break from While)",
    "syntax": "Break",
    "arguments": "",
    "description": "Break causes execution to continue immediately following the innermost enclosing While or Switch scope, in the current Method. If there is no enclosing While or Switch within the current Method, a fatal error is generated.\nCompatibility Note: In ACPI 1.0, the Break operator continued immediately following the innermost\n\u201ccode package.\u201d Starting in ACPI 2.0, the Break operator was changed to exit the innermost \u201cWhile\u201d or \u201cSwitch\u201d package. This should have no impact on existing code, since the ACPI 1.0 definition was, in practice, useless.",
    "example": ""
  },
  {
    "title": "BreakPoint (Execution Break Point)",
    "syntax": "BreakPoint",
    "arguments": "",
    "description": "Used for debugging, the Breakpoint opcode stops the execution and enters the AML debugger. In the non-debug version of the AML interpreter, BreakPoint is equivalent to Noop.",
    "example": ""
  },
  {
    "title": "Buffer (Declare Buffer Object)",
    "syntax": "Buffer (BufferSize) {Initializer} => Buffer",
    "arguments": "Declares a Buffer of optional size BufferSize and an optional initial value of Initializer. The Initializer is must be either a ByteList or a String.",
    "description": "The optional BufferSize argument specifies the size of the buffer and an optional initial value of the buffer is specified via the Initializer. The initial value can be either an ASCII String or a list of byte values separated by commas. Strings are automatically null terminated with a single zero byte.\nThe relationship between the BufferSize and the Initializer is summarized by the rules below.\nIn the typical case, the BufferSize is identical to the length of the Initializer:\n    Name (BUF0, Buffer(4) {0x01,0x02,0x03,0x04}) // Length = 4\nIf the BufferSize is not specified, the length of the Initializer is used as the buffer size:\n    Name (BUF1, Buffer() {0,1,2,3,4,5})// Length = 6\n    Name (BUF2, Buffer() {\"abcde\"}) // Length = 6\nIf the BufferSize is larger than the length of the Initializer, the BufferSize is used as the final buffer size. At runtime, the AML interpreter will automatically pad zeros to the Initializer to match the BufferSize:\n    Name (BUF3, Buffer(1024) {4,5,6,7,8})// Length = 1024\n    Name (BUF4, Buffer(1024) {\"abcde\"})// Length = 1024\nIf the BufferSize is smaller than the length of the Initializer, the length of the Initializer is used as the buffer size:\n    Name (BUF5, Buffer(1) {5,4,3,2,1}) // Length = 5\nIf the Initializer is not specified, the AML interpreter creates a buffer containing all zeros, the length of which matches the BufferSize:\n    Name (BUF6, Buffer(32} {}) // Length = 32\nIf neither the BufferSize nor the Initializer are specified, a buffer of zero length is created:\n    Name (BUF7, Buffer() {}) // Length = 0",
    "example": ""
  },
  {
    "title": "Case (Expression for Conditional Execution)",
    "syntax": "Case (Value) {TermList}",
    "arguments": "Value specifies an Integer, Buffer, String or Package object. TermList is a sequence of executable ASL expressions.",
    "description": "Execute code based upon the value of a Switch statement.\nIf the Case Value is an Integer, Buffer or String, then control passes to the statement that matches the value of the enclosing Switch (Value). If the Case value is a Package, then control passes if any member of the package matches the Switch (Value). The Switch CaseTermList can include any number of Case instances, but no two Case Values (or members of a Value, if Value is a Package) within the same Switch statement can contain the same value.\nExecution of the statement body begins at the start of the TermList and proceeds until the end of the TermList body or until a Break or Continue operator transfers control out of the body.",
    "example": ""
  },
  {
    "title": "Concatenate (Concatenate Data)",
    "syntax": "Concatenate (Source1, Source2, Result) => Buffer or String",
    "arguments": "Source1 and Source2 must each evaluate to any valid ACPI object. For the basic data object types\n(Integer, String, or Buffer), the value of the object is used in the concatenation. For all other object types (see table 19-378 below), a string object is created that contains the name (type) of the object. This string object is then concatenated according to the rules in Table 19-427.\nThe data type of Source1 dictates the required type of Source2 and the type of the result object. Source2 is implicitly converted if necessary (and possible) to match the type of Source1.",
    "description": "Source2 is concatenated to Source1 and the result data is optionally stored into Result.\nTable 19-427 Concatenate Data Types\nSource1 Data Type\nSource2 Data Type (\u00e8 Converted Type)\nResult Data Type\nInteger\nInteger/String/Buffer \u00e8 Integer\nBuffer\nString\nInteger/String/Buffer/All other types  \u00e8 String\nString\nBuffer\nInteger/String/Buffer/All other types \u00e8 Buffer\nBuffer\nAll other types \u00e8String\nInteger/String/Buffer/All other types  \u00e8 String\nString\nFor the Source1/Integer case, a String or Buffer that cannot be implicitly converted to an Integer will generate a fatal error.\nTable 19-428 Concatenate Object Types\nData Object Type\nName\nResolved to Value\n1\nInteger\nInteger value of the object\n2\nString\nString value of the object\n3\nBuffer\nBuffer value of the object\n \n \n \nOther Object Types\nName\nResolved to String\n0\nUninitialized\n\"[Uninitialized Object]\"\n4\nPackage\n\"[Package]\"\n5\nField Unit\n\"[Field]\"\n6\nDevice\n\"[Device]\"\n7\nEvent\n\"[Event]\"\n8\nControl Method\n\"[Control Method]\"\n9\nMutex\n\"[Mutex]\"\n10\nOperation Region\n\"[Operation Region]\"\n11\nPower Resource\n\"[Power Resource]\"\n12\nProcessor\n\"[Processor]\"\n13\nThermal Zone\n\"[Thermal Zone]\"\n14\nBuffer Field\n\"[Buffer Field]\"\n15\nDDB Handle\n\"[DDB Handle]\"\n16\nDebug Object\n\"[Debug Object]\"",
    "example": "Device (DEVX) {}\nName (PKGX, Package () {1,2,3,\"Battery1\"})\nMethod (MTHX, 2)\n{\n    Concatenate (\"My Object: \", DEVX, Debug) // MyObject: Device\n    Printf (\"PKGX %o contains %o elements\\n\", PKGX, SizeOf (PKGX))\n    Printf (\"Arg0: %o\\n\", Arg0)\n}"
  },
  {
    "title": "ConcatenateResTemplate (Concatenate Resource Templates)",
    "syntax": "ConcatenateResTemplate (Source1, Source2, Result) => Buffer",
    "arguments": "Source1 and Source2 are evaluated as Resource Template buffers.",
    "description": "The resource descriptors from Source2 are appended to the resource descriptors from Source1. Then a new end tag and checksum are appended and the result is stored in Result, if specified. If either Source1 or Source2 is exactly 1 byte in length, a run-time error occurs. An empty buffer is treated as a resource template with only an end tag.",
    "example": ""
  },
  {
    "title": "CondRefOf (Create Object Reference Conditionally)",
    "syntax": "CondRefOf (Source, Result) => Boolean",
    "arguments": "Attempts to create a reference to the Source object. The Source of this operation can be any object type (for example, data package, device object, and so on), and the result data is optionally stored into Result.",
    "description": "On success, the Destination object is set to refer to Source and the execution result of this operation is the value True. On failure, Destination is unchanged and the execution result of this operation is the value False. This can be used to reference items in the namespace that may appear dynamically (for example, from a dynamically loaded definition block).\nCondRefOf is equivalent to RefOf except that if the Source object does not exist, it is fatal for RefOf but not for CondRefOf.",
    "example": ""
  },
  {
    "title": "Connection (Declare Field Connection Attributes)",
    "syntax": "Connection (ConnectionResourceObj)",
    "arguments": "ConnectionResourceObj is a GPIO or Serial Bus Connection Descriptor depending on the Operation Region type, or a named object containing the Descriptor\nSee Section 6.4.3.8.2, \"Connection Resource Descriptors\" and Section \"Field (Declare Field Objects)\" for more information.",
    "description": "The Connection macro declares the connection attributes for subsequent fields defined within the Field declaration.",
    "example": "OperationRegion(TOP1, GenericSerialBus, 0x00, 0x100)// GenericSerialBus device at command value offset zero\nName (I2C, ResourceTemplate(){\n    I2CSerialBusV2(0x5a,,100000,, \"\\_SB.I2C\",,,,,RawDataBuffer(){1,6}) })\nField(TOP1, BufferAcc, NoLock, Preserve)\n{\n    Connection(I2C)                                 // Specify connection resource information\n    AccessAs(BufferAcc, AttribWord)                 // Use the GenericSerialBus\n                                                    // Read/Write Word protocol     FLD0, 8,                                        // Virtual register at command value 0.\n    FLD1, 8,                                        // Virtual register at command value 1.\n   \nField(TOP1, BufferAcc, NoLock, Preserve)\n{\n    Connection(I2CSerialBusV2(0x5b,,100000,, \"\\_SB.I2C\",,,,,RawDataBuffer(){3,9}))        AccessAs(BufferAcc, AttribBytes (16))\n    FLD2, 8                                         // Virtual register at command value 0.\n}\n // Create the GenericSerialBus data buffer\nName(BUFF, Buffer(34){})                           // Create GenericSerialBus data buffer as BUFF\nCreateByteField(BUFF, 0x00, STAT)                  // STAT = Status (Byte)\nCreateWordField(BUFF, 0x02, DATA)                  // DATA = Data (Word)"
  },
  {
    "title": "Continue (Continue Innermost Enclosing While)",
    "syntax": "Continue",
    "arguments": "",
    "description": "Continue causes execution to continue at the start of the innermost enclosing While scope, in the currently executing Control Method, at the point where the condition is evaluated. If there is no enclosing While within the current Method, a fatal error is generated.",
    "example": ""
  },
  {
    "title": "CopyObject (Copy and Store Object)",
    "syntax": "CopyObject (Source, Destination) => DataRefObject",
    "arguments": "Converts the contents of the Source to a DataRefObject using the conversion rules in 18.2.5 and then copies the results without conversion to the object referred to by Destination.",
    "description": "If Destination is already an initialized object of type DataRefObject, the original contents of Destination are discarded and replaced with Source. Otherwise, a fatal error is generated.\nNote:     (Compatibility Note) The CopyObject operator was first introduced new in ACPI 2.0.",
    "example": ""
  },
  {
    "title": "CreateBitField (Create 1-Bit Buffer Field)",
    "syntax": "CreateBitField (SourceBuffer, BitIndex, BitFieldName)",
    "arguments": "SourceBuffer is evaluated as a buffer. BitIndex is evaluated as an integer. BitFieldName is a NameString.",
    "description": "A new buffer field object named BitFieldName is created for the bit of SourceBuffer at the bit index of BitIndex. The bit-defined field within SourceBuffer must exist.BitFieldName is created for the bit of SourceBuffer at the bit index of BitIndex. The bit-defined field within SourceBuffer must exist.",
    "example": ""
  },
  {
    "title": "CreateByteField (Create 8-Bit Buffer Field)",
    "syntax": "CreateByteField (SourceBuffer, ByteIndex, ByteFieldName)",
    "arguments": "SourceBuffer is evaluated as a buffer. ByteIndex is evaluated as an integer. ByteFieldName is a NameString.",
    "description": "A new buffer field object named ByteFieldName is created for the byte of SourceBuffer at the byte index of ByteIndex. The byte-defined field within SourceBuffer must exist.",
    "example": ""
  },
  {
    "title": "CreateDWordField (Create 32-Bit Buffer Field)",
    "syntax": "CreateDWordField (SourceBuffer, ByteIndex, DWordFieldName)",
    "arguments": "SourceBuffer is evaluated as a buffer. ByteIndex is evaluated as an integer. DWordFieldName is a NameString.",
    "description": "A new buffer field object named DWordFieldName is created for the DWord of SourceBuffer at the byte index of ByteIndex. The DWord-defined field within SourceBuffer must exist.",
    "example": ""
  },
  {
    "title": "CreateField (Create Arbitrary Length Buffer Field)",
    "syntax": "CreateField (SourceBuffer, BitIndex, NumBits, FieldName)",
    "arguments": "SourceBuffer is evaluated as a buffer. BitIndex and NumBits are evaluated as integers. FieldName is a NameString.",
    "description": "A new buffer field object named FieldName is created for the bits of SourceBuffer at BitIndex for NumBits. The entire bit range of the defined field within SourceBuffer must exist. If NumBits evaluates to zero, a fatal exception is generated.",
    "example": ""
  },
  {
    "title": "CreateQWordField (Create 64-Bit Buffer Field)",
    "syntax": "CreateQWordField (SourceBuffer, ByteIndex, QWordFieldName)",
    "arguments": "SourceBuffer is evaluated as a buffer. ByteIndex is evaluated as an integer. QWordFieldName is a NameString.",
    "description": "A new buffer field object named QWordFieldName is created for the QWord of SourceBuffer at the byte index of ByteIndex. The QWord-defined field within SourceBuffer must exist.",
    "example": ""
  },
  {
    "title": "CreateWordField (Create 16-Bit Buffer Field)",
    "syntax": "CreateWordField (SourceBuffer, ByteIndex, WordFieldName)",
    "arguments": "SourceBuffer is evaluated as a buffer. ByteIndex is evaluated as an integer. WordFieldName is a NameString.",
    "description": "A new bufferfield object named WordFieldName is created for the word of SourceBuffer at the byte index of ByteIndex. The word-defined field within SourceBuffer must exist.",
    "example": ""
  },
  {
    "title": "DataTableRegion (Create Data Table Operation Region)",
    "syntax": "DataTableRegion (RegionName, SignatureString, OemIDString, OemTableIDString)",
    "arguments": "Creates a new region named RegionName. SignatureString, OemIDString and OemTableIDString are evaluated as strings.",
    "description": "A Data Table Region is a special Operation Region whose RegionSpace is SystemMemory. Any table referenced by a Data Table Region must be in memory marked by AddressRangeReserved or AddressRangeNVS.\nThe memory referred to by the Data Table Region is the memory that is occupied by the table referenced in XSDT that is identified by SignatureString, OemIDString and OemTableIDString. Any Field object can reference RegionName\nThe base address of a Data Table region is the address of the first byte of the header of the table identified by SignatureString, OemIDString and OemTableIDString. The length of the region is the length of the table.",
    "example": ""
  },
  {
    "title": "Debug (Debugger Output)",
    "syntax": "Debug",
    "arguments": "",
    "description": "The debug data object is a virtual data object. Writes to this object provide debugging information. On at least debug versions of the interpreter, any writes into this object are appropriately displayed on the system\u2019s native kernel debugger. All writes to the debug object are otherwise benign. If the system is in use without a kernel debugger, then writes to the debug object are ignored. The following table relates the ASL term types that can be written to the Debug object to the format of the information on the kernel debugger display.\nTable 19-429 Debug Object Display Formats\nASL Term Type\nDisplay Format\nNumeric data object\nAll digits displayed in hexadecimal format.\nString data object\nString is displayed.\nObject reference\nInformation about the object is displayed (for example, object type and object name), but the object is not evaluated.\nThe Debug object is a write-only object; attempting to read from the debug object is not supported.",
    "example": ""
  },
  {
    "title": "Decrement (Integer Decrement)",
    "syntax": "Decrement (Minuend) => Integer\nMinuend-- => Integer",
    "arguments": "Minuend is evaluated as an Integer.",
    "description": "This operation decrements the Minuend by one and the result is stored back to Minuend. Equivalent to Subtract (Minuend, 1, Minuend). Underflow conditions are ignored and the result is Ones.",
    "example": ""
  },
  {
    "title": "Default (Default Execution Path in Switch)",
    "syntax": "Default {TermList}",
    "arguments": "TermList is a sequence of executable ASL expressions.",
    "description": "Within the body of a Switch (page 1040) statement, the statements specified by TermList will be executed if no Case (page 948) statement value matches the Switch statement value. If Default is omitted and no Case match is found, none of the statements in the Switch body are executed. There can be at most one Default statement in the immediate scope of the parent Switch statement. The Default statement can appear anywhere in the body of the Switch statement.",
    "example": ""
  },
  {
    "title": "DefinitionBlock (Declare Definition Block)",
    "syntax": "DefinitionBlock (AMLFileName, TableSignature, ComplianceRevision, OEMID, TableID, OEMRevision) {TermList}",
    "arguments": "AMLFileName is a string that specifies the desired name of the translated output AML file. If the\nAMLFileName is a NULL (zero length) string, the ASL compiler will automatically create the filename (typically generated from the input filename/pathname).TableSignature is a string that contains the 4character ACPI signature. ComplianceRevision is an 8-bit value. OEMID is a 6-character string, TableId  is an 8-character string, and OEMRevision is a 32-bit value. TermList is a sequence of executable ASL expressions.\nIf multiple DefinitionBlocks are defined in the same ASL file, the first DefinitionBlock defines the output AMLFileName as per the rule above.",
    "description": "The DefinitionBlock term specifies the unit of data and/or AML code that the OS will load as part of the Differentiated Definition Block or as part of an additional Definition Block.\nThis unit of data and/or AML code describes either the base system or some large extension (such as a docking station). The entire DefinitionBlock will be loaded and compiled by the OS as a single unit.\nSystem software loads a definition block by referencing the objects in the TermList package in order. The object list is encoded as TermList, so that rather than describing a static object list, it is possible to describe a dynamic object list according to the system settings. See \"Section 5.4.2, Definition Block Loading.\"\nNote: For compatibility with ACPI versions before ACPI 2.0, the bit width of Integer objects is dependent on the ComplianceRevision of the DSDT. If the ComplianceRevision is less than 2, all integers are restricted to 32 bits. Otherwise, full 64-bit integers are used. The version of the DSDT sets the global integer width for all integers, including integers in SSDTs.",
    "example": ""
  },
  {
    "title": "DerefOf (Dereference an Object Reference)",
    "syntax": "DerefOf (Source) => Object",
    "arguments": "Returns the object referred by the Source object reference.",
    "description": "If the Source evaluates to an object reference, the actual contents of the object referred to are returned. If the Source evaluates to a string, the string is evaluated as an ASL name (relative to the current scope) and the contents of that object are returned. If the object specified by Source does not exist then a fatal error is generated. If the object specified is a reference generated by the Index() operator and refers to an uninitialized package element, then a fatal error is generated.\nNote:    (Compatibility Note) The use of a String with DerefOf was first introduced in ACPI 2.0.",
    "example": ""
  },
  {
    "title": "Device (Declare Device Package)",
    "syntax": "Device (DeviceName) {TermList}",
    "arguments": "Creates a Device object of name DeviceName, which represents a processor, a bus or a device, or any other similar hardware. Device opens a name scope.",
    "description": "A Device Package is one of the basic ways the Differentiated Definition Block describes the hardware devices in the system to the operating software. Each Device Package is defined somewhere in the hierarchical namespace corresponding to that device\u2019s location in the system. Within the namespace of the device are other names that provide information and control of the device, along with any subdevices that in turn describe sub-devices, and so on.\nFor any device, the platform runtime firmware provides only information that is added to the device in a non-hardware standard manner. This type of value-added function is expressible in the ACPI Definition Block such that operating software can use the function.\nThe platform runtime firmware supplies Device Objects only for devices that are obtaining some systemadded function outside the device\u2019s normal capabilities and for any Device Object required to fill in the tree for such a device. For example, if the system includes a PCI device (integrated or otherwise) with no additional functions such as power management, the platform runtime firmware would not report such a device; however, if the system included an integrated ISA device below the integrated PCI device (device is an IS bridge), then the system would include a Device Package for the ISA device with the minimum feature being added being the ISA device\u2019s ID and configuration information and the parent PCI device, because it is required to get the ISA Device Package placement in the namespace correct.\nThe device object list is encoded as TermList, so that rather than describing a static device object list, it is possible to describe a dynamic device object list according to the system settings. See \"Section 5.4.2, Definition Block Loading.\"",
    "example": "The following block of ASL sample code shows a nested use of Device objects to describe an IDE controller connected to the root PCI bus.\n    Device (IDE0) {                    // primary controller\n        Name (_ADR, 0)                 // put PCI Address (device/function) here\n        // define region for IDE mode register\n        OperationRegion (PCIC, PCI_Config, 0x50, 0x10)\n        Field (PCIC, AnyAcc, NoLock, Preserve) {\n            \u2026\n        }\n        Device (PRIM) {                // Primary adapter\n            Name (_ADR, 0)             // Primary adapter = 0\n            \u2026\n            Method (_STM, 2) {\n                \u2026\n            }\n            Method (_GTM) {\n                \u2026\n            }\n            Device (MSTR) {            // master channel\n                Name (_ADR, 0)\n                Name (_PR0, Package () {0, PIDE})\n                Name (_GTF) {\n                    \u2026\n                }\n            }\n            Device (SLAV) {\n                Name (_ADR, 1)\n                Name (_PR0, Package () {0, PIDE})\n                Name (_GTF) {\n                    \u2026\n                }\n            }\n        }\n    }"
  },
  {
    "title": "Divide (Integer Divide)",
    "syntax": "Divide (Dividend, Divisor, Remainder, Result) => Integer\nResult = Dividend / Divisor => Integer\nResult /= Divisor => Integer",
    "arguments": "Dividend and Divisor are evaluated as Integers.",
    "description": "Dividend is divided by Divisor, then the resulting remainder is optionally stored into Remainder and the resulting quotient is optionally stored into Result. Divide-by-zero exceptions are fatal.\nThe function return value is the Result (quotient).",
    "example": ""
  },
  {
    "title": "DMA (DMA Resource Descriptor Macro)",
    "syntax": "DMA (DmaType, IsBusMaster, DmaTransferSize, DescriptorName) {DmaChannelList} => Buffer Arguments\nDmaType specifies the type of DMA cycle: ISA compatible (Compatibility), EISA Type A (TypeA), EISA Type B (TypeB) or EISA Type F (TypeF). The 2-bit field DescriptorName._TYP is automatically created to refer to this portion of the resource descriptor, where \u20180\u2019 is Compatibility, \u20181\u2019 is TypeA, \u20182\u2019 is TypeB and \u20183\u2019 is TypeF.\nIsBusMaster specifies whether this device can generate DMA bus master cycles (BusMaster) or not (NotBusMaster). If nothing is specified, then BusMaster is assumed. The 1-bit field DescriptorName._BM is automatically created to refer to this portion of the resource descriptor, where \u20180\u2019 is NotBusMaster and \u20181\u2019 is BusMaster.\nDmaTransferSize specifies the size of DMA cycles the device is capable of generating: 8-bit (Transfer8), 16-bit (Transfer16) or both 8 and 16-bit (Transfer8_16). The 2-bit field DescriptorName._SIZ is automatically created to refer to this portion of the resource descriptor, where \u20180\u2019 is Transfer8, \u20181\u2019 is Transfer8_16 and \u20182\u2019 is Transfer16.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nDmaChannelList is a comma-delimited list of integers in the range 0 through 7 that specify the DMA channels used by the device. There may be no duplicates in the list.",
    "arguments": "",
    "description": "The DMA macro evaluates to a buffer which contains a DMA resource descriptor. The format of the DMA resource descriptor can be found in \u201cDMA Descriptor\u201d (page 420). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "DWordIO (DWord IO Resource Descriptor Macro)",
    "syntax": "DWordIO (ResourceUsage, IsMinFixed, IsMaxFixed, Decode, ISARanges, AddressGranularity,\nAddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName, TranslationType, TranslationDensity)",
    "arguments": "ResourceUsage specifies whether the I/O range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nIsMinFixed specifies whether the minimum address of this I/O range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName._MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this I/O range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName._MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nDecode specifies whether or not the device decodes the I/O range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nISARanges specifies whether the I/O ranges specifies are limited to valid ISA I/O ranges (ISAOnly), valid non-ISA I/O ranges (NonISAOnly) or encompass the whole range without limitation (EntireRange). The 2bit field DescriptorName._RNG is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is NonISAOnly, \u20182\u2019 is ISAOnly and \u20180\u2019 is EntireRange.\nAddressGranularity evaluates to a 32-bit integer that specifies the power-of-two boundary (- 1) on which the I/O range must be aligned. The 32-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 32-bit integer that specifies the lowest possible base address of the I/O range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 32-bit integer that specifies the highest possible base address of the I/O range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 32-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 32-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the I/O range. The 32-bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a value of zero is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nTranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same\n(TypeStatic). If TypeTranslation is specified, then the primary side of the bus is Memory. If TypeStatic is specified, then the primary side of the bus is I/O. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName._TTP is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is TypeTranslation and \u20180\u2019 is TypeStatic. See _TTP (page 443) for more information\nTranslationDensity is an optional argument that specifies whether or not the translation from the primary to secondary bus is sparse (SparseTranslation) or dense (DenseTranslation). It is only used when TranslationType is TypeTranslation. If nothing is specified, then DenseTranslation is assumed. The 1-bit field DescriptorName._TRS is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SparseTranslation and \u20180\u2019 is DenseTranslation. See _TRS (page 444) for more information.",
    "description": "The DWordIO macro evaluates to a buffer which contains a 32-bit I/O range resource descriptor. The format of the 32-bit I/O range resource descriptor can be found in \u201cDWord Address Space Descriptor \u201d (page 435). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "DWordMemory (DWord Memory Resource Descriptor Macro)",
    "syntax": "DWordMemory (ResourceUsage, Decode, IsMinFixed, IsMaxFixed, Cacheable, ReadAndWrite,\nAddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength,\nResourceSourceIndex, ResourceSource, DescriptorName, MemoryRangeType, TranslationType)",
    "arguments": "ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nDecode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nIsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName._MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName._MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nCacheable specifies whether or not the memory region is cacheable (Cacheable), cacheable and writecombining (WriteCombining), cacheable and prefetchable (Prefetchable) or uncacheable\n(NonCacheable). If nothing is specified, then NonCacheable is assumed. The 2-bit field\nDescriptorName._MEM is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Cacheable, \u20182\u2019 is WriteCombining, \u20183\u2019 is Prefetchable and \u20180\u2019 is NonCacheable.\nReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write\n(ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is ReadWrite and \u20180\u2019 is ReadOnly.\nAddressGranularity evaluates to a 32-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 32-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 32-bit integer that specifies the lowest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 32-bit integer that specifies the highest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 32-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 32-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the Memory range. The 32-bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this Memory range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nMemoryRangeType is an optional argument that specifies the memory usage. The memory can be marked as normal (AddressRangeMemory), used as ACPI NVS space (AddressRangeNVS), used as ACPI reclaimable space (AddressRangeACPI) or as system reserved (AddressRangeReserved). If nothing is specified, then AddressRangeMemory is assumed. The 2-bit field DescriptorName._MTP is automatically created in order to refer to this portion of the resource descriptor, where \u20180\u2019 is AddressRangeMemory, \u20181\u2019 is AddressRangeReserved, \u20182\u2019 is AddressRangeACPI and \u20183\u2019 is AddressRangeNVS.\nTranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is I/O. If TypeStatic is specified, then the primary side of the bus is Memory. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName._TTP is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is TypeTranslation and \u20180\u2019 is TypeStatic. See _TTP (page 443) for more information.",
    "description": "The DWordMemory macro evaluates to a buffer which contains a 32-bit memory resource descriptor. The format of the 32-bit memory resource descriptor can be found in \u201cDWord Address Space Descriptor \u201d (page 435). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "DWordSpace (DWord Space Resource Descriptor Macro)",
    "syntax": "DWordSpace (ResourceType, ResourceUsage, Decode, IsMinFixed, IsMaxFixed, TypeSpecificFlags,\nAddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName)",
    "arguments": "ResourceType evaluates to an 8-bit integer that specifies the type of this resource. Acceptable values are 0xC0 through 0xFF.\nResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nDecode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nIsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName._MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName._MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nTypeSpecificFlags evaluates to an 8-bit integer. The flags are specific to the ResourceType.\nAddressGranularity evaluates to a 32-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 32-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 32-bit integer that specifies the lowest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 32-bit integer that specifies the highest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 32-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 32-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 32-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the Memory range. The 32-bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this Memory range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The DWordSpace macro evaluates to a buffer which contains a 32-bit Address Space resource descriptor. The format of the 32-bit Address Space resource descriptor can be found in \u201cDWord Address Space Descriptor \u201d (page 435). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "EISAID (EISA ID String To Integer Conversion Macro)",
    "syntax": "EISAID (EisaIdString) => DWordConst",
    "arguments": "The EisaIdString must be a String object of the form \u201cUUUNNNN\u201d, where \u201cU\u201d is an uppercase letter and \u201cN\u201d is a hexadecimal digit. No asterisks or other characters are allowed in the string.",
    "description": "Converts EisaIdString, a 7-character text string argument, into its corresponding 4-byte numeric EISA ID encoding. It can be used when declaring IDs for devices that have EISA IDs.",
    "example": "    EISAID (\u201cPNP0C09\u201d)     // This is a valid invocation of the macro."
  },
  {
    "title": "Else (Alternate Execution)",
    "syntax": "Else {TermList}",
    "arguments": "TermList is a sequence of executable ASL statements.",
    "description": "If Predicate evaluates to 0 in an If statement, then control is transferred to the Else portion, which can consist of zero or more ElseIf statements followed by zero or one Else statements. If the Predicate of any ElseIf statement evaluates to non-zero, the statements in its term list are executed and then control is transferred past the end of the final Else term. If no Predicate evaluates to non-zero, then the statements in the Else term list are executed.",
    "example": "The following example checks Local0 to be zero or non-zero. On non-zero, CNT is incremented; otherwise, CNT is decremented.\nIf (LGreater (Local0, 5)\n{\n    Increment (CNT)\n} Else If (Local0) {\n    Add (CNT, 5, CNT)\n}\nElse\n{\n    Decrement (CNT)\n}"
  },
  {
    "title": "ElseIf (Alternate/Conditional Execution)",
    "syntax": "ElseIf (Predicate) {TermList}",
    "arguments": "Predicate is evaluated as an Integer.",
    "description": "If the Predicate of any ElseIf statement evaluates to non-zero, the statements in its term list are executed and then control is transferred past the end of the final Else. If no Predicate evaluates to non-zero, then the statements in the Else term list are executed.\nNote:     (Compatibility Note) The ElseIf operator was first introduced in ACPI 2.0, but is backward compatible with the ACPI 1.0 specification. An ACPI 2.0 and later ASL compiler must synthesize ElseIf from the If. and Else opcodes available in 1.0. For example:\nIf (predicate1)\n{\n    \u2026statements1\u2026\n}\nElseIf (predicate2)\n{\n    \u2026statements2\u2026\n}\nElse\n{\n    \u2026statements3\u2026\n}\nis translated to the following:\nIf (predicate1)\n{\n    \u2026statements1\u2026\n}\nElse\n{\n    If (predicate2)\n    {\n        \u2026statements2\u2026\n    }\n    Else\n    {\n        \u2026statements3\u2026\n    } }",
    "example": ""
  },
  {
    "title": "EndDependentFn (End Dependent Function Resource Descriptor Macro)",
    "syntax": "EndDependentFn () => Buffer",
    "arguments": "",
    "description": "The EndDependentFn macro generates an end-of-dependent-function resource descriptor buffer inside of an ResourceTemplate (page 1033). It must be matched with a StartDependentFn (page 1038) or StartDependentFnNoPri (page 1038) macro.",
    "example": ""
  },
  {
    "title": "Event (Declare Event Synchronization Object)",
    "syntax": "Event (EventName)",
    "arguments": "Creates an event synchronization object named EventName.",
    "description": "For more information about the uses of an event synchronization object, see the ASL definitions for the Wait, Signal, and Reset function operators.",
    "example": ""
  },
  {
    "title": "ExtendedIO (Extended IO Resource Descriptor Macro)",
    "syntax": "ExtendedIO (ResourceUsage, IsMinFixed, IsMaxFixed, Decode, ISARanges, AddressGranularity,\nAddressMinimum, AddressMaximum, AddressTranslation, RangeLength, TypeSpecificAttributes, DescriptorName, TranslationType, TranslationDensity)",
    "arguments": "ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nIsMinFixed specifies whether the minimum address of this I/O range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName._MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this I/O range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName._MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nDecode specifies whether or not the device decodes the I/O range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nISARanges specifies whether the I/O ranges specifies are limited to valid ISA I/O ranges (ISAOnly), valid non-ISA I/O ranges (NonISAOnly) or encompass the whole range without limitation (EntireRange). The 2bit field DescriptorName._RNG is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is NonISAOnly, \u20182\u2019 is ISAOnly and \u20180\u2019 is EntireRange.\nAddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the I/O range must be aligned. The 64-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the I/O range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the I/O range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the I/O range. The 64-bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.\nTypeSpecificAttributes is an optional argument that specifies attributes specific to this resource type. See Section 6.4.3.5.4.1,\u201dType Specific Attributes\u201d.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operatorsDescription\nThe ExtendedIO macro evaluates to a buffer which contains a 64-bit I/O resource descriptor, which describes a range of I/O addresses. The format of the 64-bit I/O resource descriptor can be found in \u201cExtended Address Space Descriptor\u201d (page 425). The macro is designed to be used inside of a ResourceTemplate (page 1033).\nTranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same\n(TypeStatic). If TypeTranslation is specified, then the primary side of the bus is Memory. If TypeStatic is specified, then the primary side of the bus is I/O. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is TypeTranslation and \u20180\u2019 is TypeStatic. See _TTP (page 443) for more information\nTranslationDensity is an optional argument that specifies whether or not the translation from the primary to secondary bus is sparse (SparseTranslation) or dense (DenseTranslation). It is only used when TranslationType is TypeTranslation. If nothing is specified, then DenseTranslation is assumed. The 1-bit field DescriptorName._TRS is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SparseTranslation and \u20180\u2019 is DenseTranslation. See _TRS (page 444) for more information.",
    "description": "",
    "example": ""
  },
  {
    "title": "ExtendedMemory (Extended Memory Resource Descriptor Macro)",
    "syntax": "ExtendedMemory (ResourceUsage, Decode, IsMinFixed, IsMaxFixed, Cacheable, ReadAndWrite,\nAddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, TypeSpecificAttributes, DescriptorName, MemoryRangeType, TranslationType)",
    "arguments": "ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nDecode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName._DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nIsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nCacheable specifies whether or not the memory region is cacheable (Cacheable), cacheable and writecombining (WriteCombining), cacheable and prefetchable (Prefetchable) or uncacheable\n(NonCacheable). If nothing is specified, then NonCacheable is assumed. The 2-bit field\nDescriptorName._MEM is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Cacheable, \u20182\u2019 is WriteCombining, \u20183\u2019 is Prefetchable and \u20180\u2019 is NonCacheable.\nReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is ReadWrite and \u20180\u2019 is ReadOnly.\nAddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 64-bit field DescriptorName._GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName ._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName ._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 64-bit field DescriptorName. _TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the Memory range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nTypeSpecificAttributes is an optional argument that specifies attributes specific to this resource type. See Section 6.4.3.5.4.1,\u201dType Specific Attributes\u201d.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nMemoryRangeType is an optional argument that specifies the memory usage. The memory can be marked as normal (AddressRangeMemory), used as ACPI NVS space (AddressRangeNVS), used as ACPI reclaimable space (AddressRangeACPI) or as system reserved (AddressRangeReserved). If nothing is specified, then AddressRangeMemory is assumed. The 2-bit field DescriptorName. _MTP is automatically created in order to refer to this portion of the resource descriptor, where \u20180\u2019 is AddressRangeMemory, \u20181\u2019 is AddressRangeReserved, \u20182\u2019 is AddressRangeACPI and \u20183\u2019 is AddressRangeNVS.\nTranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is I/O. If TypeStatic is specified, then the primary side of the bus is Memory. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is TypeTranslation and \u20180\u2019 is TypeStatic. See _TTP (page 443) for more information.",
    "description": "The ExtendedMemory macro evaluates to a buffer which contains a 64-bit memory resource descriptor, which describes a range of memory addresses. The format of the 64-bit memory resource descriptor can be found in \u201cExtended Address Space Descriptor\u201d (page 439). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "ExtendedSpace (Extended Address Space Resource Descriptor Macro)",
    "syntax": "ExtendedSpace (ResourceType, ResourceUsage, Decode, IsMinFixed, IsMaxFixed, TypeSpecificFlags,\nAddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, TypeSpecificAttributes, DescriptorName)",
    "arguments": "ResourceType evaluates to an 8-bit integer that specifies the type of this resource. Acceptable values are 0xC0 through 0xFF.\nResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nDecode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nIsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nTypeSpecificFlags evaluates to an 8-bit integer. The flags are specific to the ResourceType.\nAddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 64-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the Memory range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nTypeSpecificAttributes is an optional argument that specifies attributes specific to this resource type. See Section 6.4.3.5.4.1,\u201dType Specific Attributes\u201d.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The ExtendedSpace macro evaluates to a buffer which contains a 64-bit Address Space resource descriptor, which describes a range of addresses. The format of the 64-bit AddressSpace descriptor can be found in \u201cExtended Address Space Descriptor\u201d (page 439). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "External (Declare External Objects)",
    "syntax": "External (ObjectName, ObjectType, ReturnType, ParameterTypes)",
    "arguments": "ObjectName is a NameString.\nObjectType is an optional ObjectTypeKeyword (e.g. IntObj, PkgObj, etc.). If not specified, \u201cUnknownObj\u201d type is assumed.\nReturnType is optional. If the specified ObjectType is MethodObj, then this specifies the type or types of object returned by the method. If the method does not return an object, then nothing is specified or UnknownObj is specified. To specify a single return type, simply use the ObjectTypeKeyword. To specify multiple possible return types, enclose the comma-separated ObjectTypeKeywords with braces. For example: {IntObj, BuffObj}.\nParameterTypes is optional. If the specified ObjectType is MethodObj, this specifies both the number and type of the method parameters. It is a comma-separated, variable-length list of the expected object type or types for each of the method parameters, enclosed in braces. For each parameter, the parameter type consists of either an ObjectTypeKeyword or a comma-separated sub-list of ObjectTypeKeywords enclosed in braces. There can be no more than seven parameters in total.Description\nThe External directive informs the ASL compiler that the object is declared external to this table so that no errors will be generated for an undeclared object. The ASL compiler will create the external object at the specified place in the namespace (if a full path of the object is specified), or the object will be created at the current scope of the External term.\nFor external control methods, the ASL compiler can emit an External AML opcode that contains the name of the method and the number of required arguments. This information may be used by AML disassemblers to properly disassemble the AML to the correct ASL code.\nExternal is especially useful for use in secondary SSDTs, when the required scopes and objects are declared in the main DSDT.",
    "description": "",
    "example": "This example shows the use of External in conjunction with Scope within an SSDT:\nDefinitionBlock (\"ssdt.aml\", \"SSDT\", 2, \"X\", \"Y\", 0x00000001)\n{\n    External (\\_SB.PCI0, DeviceObj)\n    Scope (\\_SB.PCI0)\n    {     }\n}"
  },
  {
    "title": "Fatal (Fatal Error Check)",
    "syntax": "Fatal (Type, Code, Arg)",
    "arguments": "This operation is used to inform the OS that there has been an OEM-defined fatal error.",
    "description": "In response, the OS must log the fatal event and perform a controlled OS shutdown in a timely fashion.",
    "example": ""
  },
  {
    "title": "Field (Declare Field Objects)",
    "syntax": "Field (RegionName, AccessType, LockRule, UpdateRule) {FieldUnitList}",
    "arguments": "RegionName is evaluated as a Namestring that refers to the host operation region.\nAccessType is optional and defines the default access width of the field definition and is any one of the following: AnyAcc, ByteAcc, WordAcc, DWordAcc, or QWordAcc. In general, accesses within the parent object are performed naturally aligned. If desired, AccessType set to a value other than AnyAcc can be used to force minimum access width. Notice that the parent object must be able to accommodate the AccessType width. For example, an access type of WordAcc cannot read the last byte of an odd-length operation region. The exceptions to natural alignment are the access types used for a non-linear SMBus device. These will be discussed in detail below. Not all access types are meaningful for every type of operational region. If not specified, the default is AnyAcc.\nLockRule is optional and indicates whether the Global Lock is to be used when accessing this field and is one of the following: Lock or NoLock. If LockRule is set to Lock, accesses to modify the component data objects will acquire and release the Global Lock. If both types of locking occur, the Global Lock is acquired after the parent object Mutex. On Hardware-reduced ACPI platforms, Lock is not supported. If not specified, the default is NoLock.\nUpdateRule is optional and specifieas how the unmodified bits of a field are treated, and can be any one of the following: Preserve, WriteAsOnes, or WriteAsZeros. For example, if a field defines a component data object of 4 bits in the middle of a WordAcc region, when those 4 bits are modified the UpdateRule specifies how the other 12 bits are treated. If not specified, the default is Preserve.\nFieldUnitList is a variable-length list of individual field unit definitions, separated by commas. Each entry in the field unit list is one of the following:\nTable 19-430 Field Unit list entires\nFieldUnitName, BitLength\nOffset (ByteOffset)\nAccessAs (AccessType, AccessAttribute)\nConnection (ConnectionResourceObj)\nFieldUnitName is the ACPI name for the field unit (1 to 4 characters), and BitLength is the length of the field unit in bits. Offset is used to specify the byte offset of the next defined field unit. This can be used instead of defining the bit lengths that need to be skipped. AccessAs is used to define the access type and attributes for the remaining field units within the list. Connection is used to identify the connection resource of the field access. This is necessary for GenericSerialBus and GeneralPurposeIO operation region address spaces only.",
    "description": "Declares a series of named data objects whose data values are fields within a larger object. The fields are parts of the object named by RegionName, but their names appear in the same scope as the Field term.\nFor example, the field operator allows a larger operation region that represents a hardware register to be broken down into individual bit fields that can then be accessed by the bit field names. Extracting and combining the component field from its parent is done automatically when the field is accessed.\nWhen reading from a FieldUnit, returned values are normalized (shifted and masked to the proper length.) The data type of an individual FieldUnit can be either a Buffer or an Integer, depending on the bit length of the FieldUnit. If the FieldUnit is smaller than or equal to the size of an Integer (in bits), it will be treated as an Integer. If the FieldUnit is larger than the size of an Integer, it will be treated as a Buffer. The size of an Integer is indicated by the DSDT header\u2019s Revision field. A revision less than 2 indicates that the size of an Integer is 32 bits. A value greater than or equal to 2 signifies that the size of an Integer is 64 bits. For more information about data types and FieldUnit type conversion rules, see Section 19.3.5.7, \u201cData Type Conversion Rules\u201d.\nAccessing the contents of a field data object provides access to the corresponding field within the parent object. If the parent object supports Mutex synchronization, accesses to modify the component data objects will acquire and release ownership of the parent object around the modification.\nThe following table relates region types declared with an OperationRegion term to the different access types supported for each region.\nTable 19-431 OperationRegion Address Spaces and Access Types\nAddress Space\nPermitted Access Type(s)\nSystemMemory\nByteAcc, WordAcc, DWordAcc, QWordAcc, or AnyAcc\nAll access allowed\nSystemIO\nByteAcc, WordAcc, DWordAcc, QWordAcc, or AnyAcc\nAll access allowed\nPCI_Config\nByteAcc, WordAcc, DWordAcc, QWordAcc, or AnyAcc\nAll access allowed\nEmbeddedControl\nByteAcc\nByte access only\nSMBus\nBufferAcc\nReads and writes to this operation region involve the use of a region specific data buffer.\n(See below.)\nSystemCMOS\nByteAcc\nByte access only\nPciBarTarget\nByteAcc, WordAcc, DWordAcc, QWordAcc, or AnyAcc\nAll access allowed\nIPMI\nBufferAcc\nReads and writes to this operation region involve the use of a region specific data buffer.\n(See below.)\nGeneralPurposeIO\nByteAcc\nByte access only\nGenericSerialBus\nBufferAcc\nReads and writes to this operation region involve the use of a region-specific data buffer.\n(See below.)\nPCC\nByteAcc\nReads and writes to this operation region are performed in units of bytes.\nThe named FieldUnit data objects are provided in the FieldList as a series of names and bit widths. Bits assigned no name (or NULL) are skipped. The ASL compiler supports the Offset (ByteOffset) macro within a FieldList to skip to the bit position of the supplied byte offset, and the AccessAs macro to change access within the field list.\nGenericSerialBus, SMBus and IPMI regions are inherently non-linear, where each offset within the respective address space represents a variable sized (0 to 32 bytes) field. Given this uniqueness, these operation regions include restrictions on their field definitions and require the use of  a region-specific data buffer when initiating transactions. For more information on the SMBus data buffer format, see Section 13, \u201cACPI System Management Bus Interface Specification,\u201d. For more information on the IPMI data buffer format, see Section 5.5.2.4.4, \u201cDeclaring IPMI Operation Regions\". For more information on the Generic Serial Bus data buffer format, see Section 5.5.2.4.6 \"Declaring Generic Serial Bus Operation Regions.\"\nFor restrictions on the use of Fields with GeneralPurposeIO OpRegions, see Section 5.5.2.4.5, \"Declaring General PurposeIO Operation Regions\".",
    "example": "OperationRegion (MIOC, PCI_Config, Zero, 0xFF)\nField (MIOC, AnyAcc, NoLock, Preserve)\n{\n        Offset  (0x58), \uf020\n        HXGB,   32, \uf020\n        HXGT,   32, \uf020\n        GAPE,   8, \uf020\n        MR0A,   4, \uf020\n        MR0B,   4\n}"
  },
  {
    "title": "FindSetLeftBit (Find First Set Left Bit)",
    "syntax": "FindSetLeftBit (Source, Result) => Integer",
    "arguments": "Source is evaluated as an Integer.",
    "description": "The one-based bit location of the first MSb (most significant set bit) is optionally stored into Result. The result of 0 means no bit was set, 1 means the left-most bit set is the first bit, 2 means the left-most bit set is the second bit, and so on.",
    "example": ""
  },
  {
    "title": "FindSetRightBit (Find First Set Right Bit)",
    "syntax": "FindSetRightBit (Source, Result) => Integer",
    "arguments": "Source is evaluated as an Integer.",
    "description": "The one-based bit location of the most LSb (least significant set bit) is optionally stored in Result. The result of 0 means no bit was set, 32 means the first bit set is the thirty-second bit, 31 means the first bit set is the thirty-first bit, and so on.",
    "example": ""
  },
  {
    "title": "FixedDMA (DMA Resource Descriptor Macro)",
    "syntax": "FixedDMA (DmaRequestLine, Channel, DmaTransferWidth, DescriptorName)   => Buffer",
    "arguments": "DmaRequestLine is a system-relative number uniquely identifying the request line statically assigned to the device.. The bit field name _DMA is automatically created to refer to this portion of the resource descriptor.\nChannel is a controller-relative number uniquely identifying the channel statically assigned to this DMARequestLine.  Channels can be shared by reusing Channel numbers across descriptors. The bit field name _TYP is automatically created to refer to this portion of the resource descriptor.\nDmaTransferWidth is an optional argument specifying the width of data transfer for which the device is configured. Valid values are Width8Bit, Width16Bit, Width32Bit,Width64Bit, Width 128Bit or\nWidth256Bit. If not specified, Width32Bit is assumed. The bit field name _SIZ is automatically created to refer to this portion of the resource descriptor.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The FixedDMA macro evaluates to a buffer that contains a Fixed DMA Descriptor (Section 6.4.3).",
    "example": ""
  },
  {
    "title": "FixedIO (Fixed IO Resource Descriptor Macro)",
    "syntax": "FixedIO (AddressBase, RangeLength, DescriptorName) => Buffer",
    "arguments": "AddressBase evaluates to a 16-bit integer. It describes the starting address of the fixed I/O range. The field DescriptorName. _BAS is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to an 8-bit integer. It describes the length of the fixed I/O range. The field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nDescriptorName evaluates to a name string which refers to the entire resource descriptor.",
    "description": "The FixedIO macro evaluates to a buffer which contains a fixed I/O resource descriptor. The format of the fixed I/O resource descriptor can be found in \u201cFixed Location I/O Port Descriptor \u201d (page 423). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "For (Conditional Loop)",
    "syntax": "For (Initialize, Predicate, Update) {TermList}",
    "arguments": "Initialize. This optional expression is evaluated once before the loop is entered. If not specified, no initialization takes place.\nPredicate. The list of terms within the TermList are executed until the predicate evaluates to zero (FALSE). If this argument is not specified, the For macro is equivalent to While(1).\nUpdate. This optional expression is evaluated once per execution of the loop, after all other terms within the TermList have been executed.",
    "description": "For is a macro that creates a loop by converting the input arguments to the equivalent ASL While loop.\nNote: Creation of a named object more than once in a given scope is not allowed. As such, unconditionally creating named objects within a For loop must be avoided. A fatal error will be generated on the second iteration of the loop, during the attempt to create the same named object a second time.",
    "example": "The following example shows the use of the For macro to create a loop, followed by the equivalent While loop that is actually emitted by the ASL compiler:\n        for (local0 = 0, local0 < 8, local0++)\n        {\n        }\n        Local0 = 0\n        While (Local0 < 8)\n        {\n            Local0++\n        }"
  },
  {
    "title": "Fprintf (Create and Store formatted string)",
    "syntax": "Fprintf (Destination, FormatString, FormatArgs) => String",
    "arguments": "Fprintf is a macro that converts the evaluated FormatString into a series of string Concatenate operations, storing the result in Destination.\nFormatString is a string literal which may contain one or more uses of the format specifier, %o, to indicate locations in the string where an object may be inserted. %o is the only format specifier supported since the resulting object is a string and type conversion is handled automatically by Concatenate.\nFormatArgs is a comma separated list of Named Objects, Locals, or Args that can be evaluated to a string. Each argument is added to the FormatString using the Concatenate operation at the location specified by %o in order of appearance.",
    "description": "Fprintf is a macro that converts the evaluated FormatString into a series of string Concatenate operations, storing the result in Destination",
    "example": "The following ASL example uses Fprintf to write a formatted string of Arg0 and Arg1 to the Named Object STR1.\n    Fprintf (STR1, \"%o: %o Successful\", Arg1, Arg0)\nThis Fprintf macro expression evaluates to the following ASL operation.\n    Store (Concatenate (Concatenate (Concatenate (Concatenate\n          (\"\", Arg1), \": \"), Arg0), \" Successful\"), STR1)"
  },
  {
    "title": "FromBCD (Convert BCD To Integer)",
    "syntax": "FromBCD (BCDValue, Result) => Integer",
    "arguments": "BCDValue is evaluated as an Integer in Binary Coded Decimal format.",
    "description": "The FromBCD operation converts BCDValue to a numeric format, and optionally stores the numeric value into Result.",
    "example": ""
  },
  {
    "title": "Function (Declare Control Method)",
    "syntax": "Function (FunctionName, ReturnType, ParameterTypes) {TermList}",
    "arguments": "ReturnType is optional and specifies the type(s) of the object(s) returned by the method. If the method does not return an object, then nothing is specified or UnknownObj is specified. To specify a single return type, simply use the ObjectTypeKeyword (e.g. IntObj, PkgObj, etc.). To specify multiple possible return types, enclose the comma-separated ObjectTypeKeywords with braces. For example: {IntObj, BuffObj}.\nParameterTypes is optional and specifies both the number and type of the method parameters. It is a comma-separated, variable-length list of the expected object type or types for each of the method parameters, enclosed in braces. For each parameter, the parameter type consists of either an\nObjectTypeKeyword or a comma-separated sub-list of ObjectTypeKeywords enclosed in braces. There can be no more than seven parameters in total.",
    "description": "Function declares a named package containing a series of terms that collectively represent a control method. A control method is a procedure that can be invoked to perform computation. Function opens a name scope.\nSystem software executes a control method by executing the terms in the package in order. For more information on method execution, see Section 5.5.2, \u201cControl Method Execution.\u201d\nThe current namespace location used during name creation is adjusted to be the current location on the namespace tree. Any names created within this scope are \u201cbelow\u201d the name of this package. The current namespace location is assigned to the method package, and all namespace references that occur during control method execution for this package are relative to that location.\nFunctions are equivalent to a Method that specifies NotSerialized. As such, a function should not create any named objects, since a second thread that might re-enter the function will cause a fatal error if an attempt is made to create the same named object twice.\nNote:     (Compatibility Note) New for ACPI 3.0",
    "example": "The following block of ASL sample code shows the use of Function for defining a control method:\nFunction (EXAM, IntObj, {StrObj, {IntObj, StrObj}})\n{\n    Name (Temp,\u201d\u201d)\n    Store (Arg0, Temp)                // could have used Arg1\n    Return (SizeOf (Concatenate (Arg1, Temp)))\n}\nThis declaration is equivalent to:\nMethod (EXAM, 2, NotSerialized, 0, IntObj, {StrObj, {IntObj, StrObj}})\n{\n\u2026\n}"
  },
  {
    "title": "GpioInt (GPIO Interrupt Connection Resource Descriptor Macro)",
    "syntax": "",
    "arguments": "EdgeLevel can be either Edge or Level. The bit field name _MOD is automatically created to refer to this portion of the resource descriptor.\nActiveLevel can be one of ActiveHigh, ActiveLow or ActiveBoth. ActiveBoth can be specified only if EdgeLevel is Edge. The bit field name _POL is automatically created to refer to this portion of the resource descriptor.\nShared is an optional argument and can be one of Shared, Exclusive, SharedAndWake or\nExclusiveAndWake. If not specified, Exclusive is assumed. The \"Wake\" designation indicates that the interrupt is capable of waking the system from a low-power idle state or a system sleep state. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\nPinConfig can be one of PullDefault, PullUp, PullDown, PullNone or a vendor-supplied value in the range 128-255. The bit field name _PPI is automatically created to refer to this portion of the resource descriptor.\nDebounceTimeout is an optional argument specifying the debounce wait time, in hundredths of milliseconds. The bit field name _DBT is automatically created to refer to this portion of the resource descriptor.\nResourceSource is a string which uniquely identifies the GPIO controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\nResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.\nResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nVendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.\nPinList is a list of (zero-based) pin numbers on the ResourceSource that are described by this descriptor. For interrupt pin descriptors, only one pin is allowed. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.",
    "description": "The GpioInt macro evaluates to a buffer that contains a GPIO Interrupt Connection resource descriptor.\nThe format of the GPIO Interrupt Connection resource descriptor can be found in \"GPIO Connection Descriptor\" (Section 6.4.3.8.1). The macro is designed to be used inside of a Resource Template (Section 19.3.3).",
    "example": ""
  },
  {
    "title": "GpioIo (GPIO Connection IO Resource Descriptor Macro)",
    "syntax": "",
    "arguments": "Shared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\nPinConfig can be one of PullDefault, PullUp, PullDown, PullNone or a vendor-supplied value in the range 128-255. The bit field name _PPI is automatically created to refer to this portion of the resource descriptor.\nDebounceTimeout is an optional argument specifying the hardware debounce wait time, in hundredths of milliseconds. The bit field name _DBT is automatically created to refer to this portion of the resource descriptor.\nDriveStrength is an optional argument specifying the output drive capability of the pin, in hundredths of milliamperes. The bit field name _DRS is automatically created to refer to this portion of the resource descriptor.\nIORestriction is an optional argument and can be IoRestrictionInputOnly, IoRestrictionOutputOnly, IoRestrictionNone, or IORestrictionNoneAndPreserve. IORestrictions limit the mode in which the pin can be accessed (Input or Output). They also ensure that the pin configuration is preserved during periods when the driver is unloaded or the resource has been disconnected by the driver. If not specified, IoRestrictionNone is assumed. The bit field name _IOR is automatically created to refer to this portion of the resource descriptor.\nResourceSource is a string which uniquely identifies the GPIO controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\nResourceSourceIndex is an optional argument and is always 0 for this revision.\nResourceUsage is an optional argument and is always ResourceConsumer for this revision.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nVendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.\nPinList is a list of pin numbers on the ResourceSource that are described by this descriptor. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.",
    "description": "The GpioIo macro evaluates to a buffer that contains a GPIO IO Connection resource descriptor. The format of the GPIO  IO Connection resource descriptor can be found in \"GPIO Connection Descriptor\" (Section 6.4.3.8.1). The macro is designed to be used inside of a Resource Template (Section 19.3.3).",
    "example": ""
  },
  {
    "title": "I2CSerialBusV2 (I2C Serial Bus Connection Resource Descriptor  (Version 2) Macro)",
    "syntax": "I2CSerialBusV2 (SlaveAddress, SlaveMode, ConnectionSpeed, AddressingMode, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, Shared, VendorData)",
    "arguments": "SlaveAddress is the I2C bus address for this connection. The bit field name _ADR is automatically created to refer to this portion of the resource descriptor.\nSlaveMode is an optional argument and can be either ControllerInitiated or DeviceInitiated.\nControllerInitiated is the default. The bit field name _SLV is automatically created to refer to this portion of the resource descriptor.\nConnectionSpeed is the maximum connection speed supported by this connection, in hertz. The bit field name _SPE is automatically created to refer to this portion of the resource descriptor.\nAddressingMode is an optional argument and can be either AddressingMode7Bit or\nAddressingMode10Bit. AddressingMode7Bit is the default. The bit field name _MOD is automatically created to refer to this portion of the resource descriptor.\nResourceSource is a string which uniquely identifies the I2C bus controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\nResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.\nResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nShared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\nVendorData is an optional argument that specifies an object to be decoded by the OS driver. It is a RawDataBuffer. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.",
    "description": "The I2CSerialBusV2 macro evaluates to a buffer that contains an I2C Serial Bus resource descriptor (Version 2). The macro is designed to be used inside of a ResourceTemplate (see Section 19.3.3).",
    "example": ""
  },
  {
    "title": "If (Conditional Execution)",
    "syntax": "If (Predicate) {TermList}",
    "arguments": "Predicate is evaluated as an Integer.",
    "description": "If the Predicate is non-zero, the term list of the If term is executed.",
    "example": "The following examples all check for bit 3 in Local0 being set, and clear it if set.\n// example 1\nIf (And (Local0, 4))\n{\n    XOr (Local0, 4, Local0)\n}\n// example 2\nStore (4, Local2)\nIf (And (Local0, Local2))\n{\n    XOr (Local0, Local2, Local0) }"
  },
  {
    "title": "Include (Include Additional ASL File)",
    "syntax": "Include (FilePathName)",
    "arguments": "FilePathname is a StringData data type that contains the full OS file system path.",
    "description": "Include another file that contains ASL terms to be inserted in the current file of ASL terms. The file must contain elements that are grammatically correct in the current scope.",
    "example": "   \n    Include (\"dataobj.asl\")"
  },
  {
    "title": "Increment (Integer Increment)",
    "syntax": "Increment (Addend) => Integer\nDestination = Source [Index] => ObjectReference\nAddend++ => Integer",
    "arguments": "Addend is evaluated as an Integer.",
    "description": "Add one to the Addend and place the result back in Addend. Equivalent to Add (Addend, 1, Addend). Overflow conditions are ignored and the result of an overflow is zero.",
    "example": ""
  },
  {
    "title": "Index (Indexed Reference To Member Object)",
    "syntax": "Index (Source, Index, Destination) => ObjectReference\nDestination = Source [Index] => ObjectReference",
    "arguments": "Source is evaluated to a buffer, string, or package data type. Index is evaluated to an integer. The reference to the nth object (where n = Index) within Source is optionally stored as a reference into Destination.",
    "description": "When Source evaluates to a Buffer, Index returns a reference to a Buffer Field containing the nth byte in the buffer. When Source evaluates to a String, Index returns a reference to a Buffer Field containing the nth character in the string. When Source evaluates to a Package, Index returns a reference to the nth object in the package.",
    "example": ""
  },      
  {
    "title": "IndexField (Declare Index/Data Fields)",
    "syntax": "IndexField (IndexName, DataName, AccessType, LockRule, UpdateRule) {FieldUnitList}",
    "arguments": "IndexName is evaluated as a Namestring and refers to a Field Unit object.\nDataName is evaluated as a Namestring and refers to a Field Unit object.\nAccessType, LockRule, UpdateRule, and FieldList are the same format as the Field term.",
    "description": "Creates a series of named data objects whose data values are fields within a larger object accessed by an index/data-style reference to IndexName and DataName.\nThis encoding is used to define named data objects whose data values are fields within an index/data register pair. This provides a simple way to declare register variables that occur behind a typical index and data register pair.\nAccessing the contents of an indexed field data object will automatically occur through the DataName object by using an IndexName object aligned on an AccessType boundary, with synchronization occurring on the operation region that contains the index data variable, and on the Global Lock if specified by LockRule.\nThe value written to the IndexName register is defined to be a byte offset that is aligned on an AccessType boundary. For example, if AccessType is DWordAcc, valid index values are 0, 4, 8, etc. This value is always a byte offset and is independent of the width or access type of the DataName register.",
    "example": "The following is a block of ASL sample code using IndexField:\nCreates an index/data register in system I/O space made up of 8-bit registers.\n            \u2022     Creates a FET0 field within the indexed range.\nMethod (EX1) {\n    // Define a 256-byte operational region in SystemIO space     // and name it GIO0\n    OperationRegion (GIO0, 1, 0x125, 0x100)\n    // Create a field named Preserve structured as a sequence     // of index and data bytes\n    Field (GIO0, ByteAcc, NoLock, WriteAsZeros) {\n        IDX0, 8,\n        DAT0, 8,\n            .\n            .\n            .\n    }\n    // Create an IndexField within IDX0 & DAT0 which has\n    // FETs in the first two bits of indexed offset 0,\n    // and another 2 FETs in the high bit on indexed\n    // 2F and the low bit of indexed offset 30\n    IndexField (IDX0, DAT0, ByteAcc, NoLock, Preserve) {\n        FET0, 1,         FET1, 1,\n        Offset (0x2f),        // skip to byte offset 2f\n        , 7,                  // skip another 7 bits\n        FET3, 1,\n        FET4, 1\n    }\n    // Clear FET3 (index 2F, bit 7)\n    Store (Zero, FET3)\n} // End EX1"
  },
  {
    "title": "Interrupt (Interrupt Resource Descriptor Macro)",
    "syntax": "Interrupt (ResourceUsage, EdgeLevel, ActiveLevel, Shared, ResourceSourceIndex, ResourceSource, DescriptorName) {InterruptList} => Buffer",
    "arguments": "ResourceUsage describes whether the device consumes the specified interrupt (ResourceConsumer) or produces it for use by a child device (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nEdgeLevel describes whether the interrupt is edge triggered (Edge) or level triggered (Level). The field DescriptorName. _HE is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Edge and \u20180\u2019 is Level.\nActiveLevel describes whether the interrupt is active-high (ActiveHigh) or active-low (ActiveLow). The field DescriptorName. _LL is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is ActiveHigh and \u20180\u2019 is ActiveLow.\nShared describes whether the interrupt can be shared with other devices (Shared) or not (Exclusive), and whether it is capable of waking the system from a low-power idle or system sleep state (SharedAndWake or ExclusiveAndWake). The field DescriptorName. _SHR is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Shared and \u20180\u2019 is Exclusive. If nothing is specified, then Exclusive is assumed.\nResourceSourceIndex evaluates to an integer between 0x00 and 0xFF and describes the resource source index. If it is not specified, then it is not generated. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource evaluates to a string which uniquely identifies the resource source. If it is not specified, it is not generated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName evaluates to a name string which refers to the entire resource descriptor.\nInterruptList is a comma-delimited list on integers, at least one value is required. Each integer represents a 32-bit interrupt number. At least one interrupt must be defined, and there may be no duplicates in the list. The field \u201cDescriptorName. _INT\u201d is automatically created to refer to this portion of the resource descriptor.",
    "description": "The Interrupt macro evaluates to a buffer that contains an interrupt resource descriptor. The format of the interrupt resource descriptor can be found in Section 6.4.3.6, Extended Interrupt Descriptor. The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "IO (IO Resource Descriptor Macro)",
    "syntax": "IO (Decode, AddressMin, AddressMax, AddressAlignment, RangeLength, DescriptorName) => Buffer\nArgument\nDecode describes whether the I/O range uses 10-bit decode (Decode10) or 16-bit decode (Decode16). The field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Decode16 and \u20180\u2019 is Decode10.\nAddressMin evaluates to a 16-bit integer that specifies the minimum acceptable starting address for the I/O range. It must be an even multiple of AddressAlignment. The field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMax evaluates to a 16-bit integer that specifies the maximum acceptable starting address for the I/O range. It must be an even multiple of AddressAlignment. The field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressAlignment evaluates to an 8-bit integer that specifies the alignment granularity for the I/O address assigned. The field DescriptorName. _ALN is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to an 8-bit integer that specifies the number of bytes in the I/O range. The field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "arguments": "",
    "description": "The IO macro evaluates to a buffer which contains an IO resource descriptor. The format of the IO descriptor can be found in \u201cI/O Port Descriptor\u201d (page 419). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "IRQ (Interrupt Resource Descriptor Macro)",
    "syntax": "IRQ (EdgeLevel, ActiveLevel, Shared, DescriptorName) {InterruptList} => Buffer",
    "arguments": "EdgeLevel describes whether the interrupt is edge triggered (Edge) or level triggered (Level). The field DescriptorName. _HE is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Edge and ActiveHigh and \u20180\u2019 is Level and ActiveLow.\nActiveLevel describes whether the interrupt is active-high (ActiveHigh) or active-low (ActiveLow). The field DescriptorName. _LL is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Edge and ActiveHigh and \u20180\u2019 is Level and ActiveLow.\nShared describes whether the interrupt can be shared with other devices (Shared) or not (Exclusive), and whether it is capable of waking the system from a low-power idle or system sleep state (SharedAndWake or ExclusiveAndWake). The field DescriptorName. _SHR is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Shared and \u20180\u2019 is Exclusive. If nothing is specified, then Exclusive is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nInterruptList is a comma-delimited list of integers in the range 0 through 15, at least one value is required. There may be no duplicates in the list.",
    "description": "The IRQ macro evaluates to a buffer that contains an IRQ resource descriptor. The format of the IRQ descriptor can be found in \u201cIRQ Descriptor\u201d ((page 419). The macro produces the three-byte form of the descriptor. The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "IRQNoFlags (Interrupt Resource Descriptor Macro)",
    "syntax": "IRQNoFlags (DescriptorName) {InterruptList} => Buffer",
    "arguments": "DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer.\nInterruptList is a comma-delimited list of integers in the range 0 through 15, at least one value is required. There may be no duplicates in the list Description\nThe IRQNoFlags macro evaluates to a buffer which contains an active-high, edge-triggered IRQ resource descriptor. The format of the IRQ descriptor can be found in IRQ Descriptor (page 419). The macro produces the two-byte form of the descriptor. The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "description": "",
    "example": ""
  },
  {
    "title": "LAnd (Logical And)",
    "syntax": "LAnd (Source1, Source2) => Boolean\nSource1 && Source2 => Boolean",
    "arguments": "Source1 and Source2 are evaluated as integers.",
    "description": "If both values are non-zero, True is returned: otherwise, False is returned.",
    "example": ""
  },
  {
    "title": "LEqual (Logical Equal)",
    "syntax": "LEqual (Source1, Source2) => Boolean\nSource1 == Source2 => Boolean",
    "arguments": "Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.",
    "description": "If the values are equal, True is returned; otherwise, False is returned. For integers, a numeric compare is performed. For strings and buffers, True is returned only if both lengths are the same and the result of a byte-wise compare indicates exact equality.",
    "example": ""
  },
  {
    "title": "LGreater (Logical Greater)",
    "syntax": "LGreater (Source1, Source2) => Boolean\nSource1 > Source2 => Boolean",
    "arguments": "Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.",
    "description": "If Source1 is greater than Source2, True is returned; otherwise, False is returned. For integers, a numeric comparison is performed. For strings and buffers, a lexicographic comparison is performed. True is returned if a byte-wise (unsigned) compare discovers at least one byte in Source1 that is numerically greater than the corresponding byte in Source2. False is returned if at least one byte in Source1 is numerically less than the corresponding byte in Source2. In the case of byte-wise equality, True is returned if the length of Source1 is greater than Source2, False is returned if the length of Source1 is less than or equal to Source2.",
    "example": ""
  },
  {
    "title": "LGreaterEqual (Logical Greater Than Or Equal)",
    "syntax": "LGreaterEqual (Source1, Source2) => Boolean\nSource1 >= Source2 => Boolean",
    "arguments": "Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.",
    "description": "If Source1 is greater than or equal to Source2, True is returned; otherwise, False is returned. Equivalent to LNot(LLess()). See the description of the LLess operator.",
    "example": ""
  },
  {
    "title": "LLess (Logical Less)",
    "syntax": "LLess (Source1, Source2) => Boolean\nSource1 < Source2 => Boolean",
    "arguments": "Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.",
    "description": "If Source1 is less than Source2, True is returned; otherwise, False is returned. For integers, a numeric comparison is performed. For strings and buffers, a lexicographic comparison is performed. True is returned if a byte-wise (unsigned) compare discovers at least one byte in Source1 that is numerically less than the corresponding byte in Source2. False is returned if at least one byte in Source1 is numerically greater than the corresponding byte in Source2. In the case of byte-wise equality, True is returned if the length of Source1 is less than Source2, False is returned if the length of Source1 is greater than or equal to Source2.",
    "example": ""
  },
  {
    "title": "LLessEqual (Logical Less Than Or Equal)",
    "syntax": "LLessEqual (Source1, Source2) => Boolean\nSource1 <= Source2 => Boolean",
    "arguments": "Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.",
    "description": "If Source1 is less than or equal to Source2, True is returned; otherwise False is returned. Equivalent to LNot(LGreater()). See the description of the LGreater operator.",
    "example": ""
  },
  {
    "title": "LNot (Logical Not)",
    "syntax": "LNot (Source) => Boolean\n!Source => Boolean",
    "arguments": "Source is evaluated as an integer.",
    "description": "If the value is zero True is returned; otherwise, False is returned.",
    "example": ""
  },
  {
    "title": "LNotEqual (Logical Not Equal) )",
    "syntax": "LNotEqual (Source1, Source2) => Boolean\nSource1 != Source2 => Boolean",
    "arguments": "Source1 and Source2 must each evaluate to an integer, a string, or a buffer. The data type of Source1 dictates the required type of Source2. Source2 is implicitly converted if necessary to match the type of Source1.",
    "description": "If Source1 is not equal to Source2, True is returned; otherwise False is returned. Equivalent to LNot(LEqual()).See the description of the LEqual operator.",
    "example": ""
  },
  {
    "title": "Load (Load Definition Block)",
    "syntax": "Load (Object, DDBHandle)",
    "arguments": "The Object parameter can refer to one of the following object types:\n1.      An operation region field\n2.      An operation region directly\n3.      An ASL Buffer object\nIf the object is an operation region, the operation region must be in SystemMemory space. The Definition Block should contain an ACPI DESCRIPTION_HEADER of type SSDT.\nThe Definition Block must be totally contained within the supplied operation region, operation region field, or Buffer object. OSPM reads this table into memory, the checksum is verified, and then it is loaded into the ACPI namespace.",
    "description": "Performs a run-time load of a Definition Block. Any table loaded via an operation region must be in memory marked as AddressRangeReserved or AddressRangeNVS. The OS can also check the OEM Table ID and Revision ID against a database for a newer revision Definition Block of the same OEM Table ID and load it instead.\nThe default namespace location to load the Definition Block is relative to the root of the namespace. The new Definition Block can override this by specifying absolute names or by adjusting the namespace location using the Scope operator.\nLoading a Definition Block is a synchronous operation. Upon completion of the operation, the Definition Block has been loaded. The control methods defined in the Definition Block are not executed during load time.",
    "example": ""
  },
  {
    "title": "LoadTable (Load Definition Block From XSDT)",
    "syntax": "LoadTable (SignatureString, OEMIDString, OEMTableIDString, RootPathString, ParameterPathString, ParameterData) => DDBHandle",
    "arguments": "The XSDT is searched for a table where the Signature field matches SignatureString, the OEM ID field matches OEMIDString, and the OEM Table ID matches OEMTableIDString. All comparisons are case sensitive. If the SignatureString is greater than four characters, the OEMIDString is greater than six characters, or the OEMTableID is greater than eight characters, a run-time error is generated. The OS can also check the OEM Table ID and Revision ID against a database for a newer revision Definition Block of the same OEM Table ID and load it instead.\nThe RootPathString specifies the root of the Definition Block. It is evaluated using normal scoping rules, assuming that the scope of the LoadTable instruction is the current scope. The new Definition Block can override this by specifying absolute names or by adjusting the namespace location using the Scope operator. If RootPathString is not specified, \u201c\\\u201d is assumed\nIf ParameterPathString and ParameterData are specified, the data object specified by ParameterData is stored into the object specified by ParameterPathString after the table has been added into the namespace. If the first character of ParameterPathString is a backslash (\u2018\\\u2019) or caret (\u2018^\u2019) character, then the path of the object is ParameterPathString. Otherwise, it is RootPathString.ParameterPathString. If the specified object does not exist, a run-time error is generated.\nThe handle of the loaded table is returned. If no table matches the specified signature, then 0 is returned.",
    "description": "Performs a run-time load of a Definition Block from the XSDT. Any table referenced by LoadTable must be in memory marked by AddressRangeReserved or AddressRangeNVS.\nNote:     OSPM loads the DSDT and all SSDTs during initialization. As such, Definition Blocks to be conditionally loaded via LoadTable must contain signatures other than \u201cSSDT\u201d.\nLoading a Definition Block is a synchronous operation. Upon completion of the operation, the Definition Block has been loaded. The control methods defined in the Definition Block are not executed during load time.",
    "example": "    Store (LoadTable (\u201cOEM1\u201d, \u201dMYOEM\u201d, \u201dTABLE1\u201d, \u201d\\\\_SB.PCI0\u201d,\u201dMYD\u201d,\n                         Package () {0,\u201d\\\\_SB.PCI0\u201d}), Local0)\nThis operation would search through the RSDT or XSDT for a table with the signature \u201cOEM1,\u201d the OEM ID of \u201cMYOEM,\u201d and the table ID of \u201cTABLE1.\u201d If not found, it would store Zero in Local0. Otherwise, it will store a package containing 0 and \u201c\\\\_SB.PCI0\u201d into the variable at \\_SB.PCI0.MYD."
  },
  {
    "title": "Localx (Method Local Data Objects)",
    "syntax": "Local0 | Local1 | Local2 | Local3 | Local4 | Local5 | Local6 | Local7",
    "arguments": "",
    "description": "Up to 8 local objects can be referenced in a control method. On entry to a control method, these objects are uninitialized and cannot be used until some value or reference is stored into the object. Once initialized, these objects are preserved in the scope of execution for that control method.",
    "example": ""
  },
  {
    "title": "LOr (Logical Or)",
    "syntax": "LOr (Source1, Source2) => Boolean\nSource1 || Source2 => Boolean",
    "arguments": "Source1 and Source2 are evaluated as integers.",
    "description": "If either value is non-zero, True is returned; otherwise, False is returned.",
    "example": ""
  },
  {
    "title": "Match (Find Object Match)",
    "syntax": "Match (SearchPackage, Op1, MatchObject1, Op2, MatchObject2, StartIndex) => Ones | Integer",
    "arguments": "SearchPackage is evaluated to a package object and is treated as a one-dimension array. Each package element must evaluate to either an integer, a string, or a buffer. Uninitialized package elements and elements that do not evaluate to integers, strings, or buffers are ignored. Op1 and Op2 are match operators. MatchObject1 and MatchObject2 are the objects to be matched and must each evaluate to either an integer, a string, or a buffer. StartIndex is the starting index within the SearchPackage.",
    "description": "A comparison is performed for each element of the package, starting with the index value indicated by StartIndex (0 is the first element). If the element of SearchPackage being compared against is called P[i], then the comparison is:\nIf (P[i] Op1 MatchObject1) and (P[i] Op2 MatchObject2) then Match => i is returned.\nIf the comparison succeeds, the index of the element that succeeded is returned; otherwise, the constant object Ones is returned. The data type of the MatchObject dictates the required type of the package element. If necessary, the package element is implicitly converted to match the type of the MatchObject. If the implicit conversion fails for any reason, the package element is ignored (no match.)\nOp1 and Op2 have the values and meanings listed in the following table.\nTable 19-432 Match Term Operator Meanings\nOperator\nEncoding\nMacro\nTRUE A don\u2019t care, always returns TRUE\n0\nMTR\nEQ Returns TRUE if P[i] == MatchObject\n1\nMEQ\nLE Returns TRUE if P[i] <= MatchObject\n2\nMLE\nLT Returns TRUE if P[i] < MatchObject\n3\nMLT\nGE Returns TRUE if P[i] >= MatchObject\n4\nMGE\nGT Returns TRUE if P[i] > MatchObject\n5\nMGT",
    "example": "Following are some example uses of Match:\nName (P1,\n    Package () {1981, 1983, 1985, 1987, 1989, 1990, 1991, 1993, 1995, 1997, 1999,\n2001}\n)\n// match 1993 == P1[i]\nMatch (P1, MEQ, 1993, MTR, 0, 0)        // -> 7, since P1[7] == 1993\n// match 1984 == P1[i]\nMatch (P1, MEQ, 1984, MTR, 0, 0)        // -> ONES (not found)\n// match P1[i] > 1984 and P1[i] <= 2000\nMatch (P1, MGT, 1984, MLE, 2000, 0)     // -> 2, since P1[2]>1984 and P1[2]<=2000\n// match P1[i] > 1984 and P1[i] <= 2000, starting with 3rd element\nMatch (P1, MGT, 1984, MLE, 2000, 3)     // -> 3, first match at or past Start"
  },
  {
    "title": "Memory24 (Memory Resource Descriptor Macro)",
    "syntax": "Memory24 (ReadAndWrite, AddressMinimum, AddressMaximum, AddressAlignment, RangeLength, DescriptorName)",
    "arguments": "ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is ReadWrite and \u20180\u2019 is ReadOnly.\nAddressMinimum evaluates to a 16-bit integer that specifies bits [8:23] of the lowest possible base address of the memory range. All other bits are assumed to be zero. The value must be an even multiple of AddressAlignment. The 16-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 16-bit integer that specifies bits [8:23] of the highest possible base address of the memory range. All other bits are assumed to be zero. The value must be an even multiple of AddressAlignment. The 16-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressAlignment evaluates to a 16-bit integer that specifies bits [0:15] of the required alignment for the memory range. All other bits are assumed to be zero. The address selected must be an even multiple of this value. The 16-bit field DescriptorName. _ALN is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 16-bit integer that specifies the total number of bytes decoded in the memory range. The 16-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor. The range length provides the length of the memory range in 256 byte blocks.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The Memory24 macro evaluates to a buffer which contains an 24-bit memory descriptor. The format of the 24-bit memory descriptor can be found in \u201c24-Bit Memory Range Descriptor \u201d (page 426). The macro is designed to be used inside of a ResourceTemplate (page 1033).\nNote:     The use of Memory24 is deprecated and should not be used in new designs.",
    "example": ""
  },
  {
    "title": "Memory32 (Memory Resource Descriptor Macro)",
    "syntax": "Memory32 (ReadAndWrite, AddressMinimum, AddressMaximum, AddressAlignment, RangeLength, DescriptorName)",
    "arguments": "ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is ReadWrite and \u20180\u2019 is ReadOnly.\nAddressMinimum evaluates to a 32-bit integer that specifies the lowest possible base address of the memory range. The value must be an even multiple of AddressAlignment. The 32-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 32-bit integer that specifies the highest possible base address of the memory range. The value must be an even multiple of AddressAlignment. The 32-bit field\nDescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressAlignment evaluates to a 32-bit integer that specifies the required alignment for the memory range. The address selected must be an even multiple of this value. The 32-bit field DescriptorName. _ALN is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the memory range. The 32-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor. The range length provides the length of the memory range in 1 byte blocks.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The Memory32 macro evaluates to a buffer which contains a 32-bit memory descriptor, which describes a memory range with a minimum, a maximum and an alignment. The format of the 32-bit memory descriptor can be found in \u201c32-Bit Memory Range Descriptor \u201d (page 427). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "Memory32Fixed (Memory Resource Descriptor Macro)",
    "syntax": "Memory32Fixed (ReadAndWrite, AddressBase, RangeLength, DescriptorName)",
    "arguments": "ReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is ReadWrite and \u20180\u2019 is ReadOnly.\nAddressBase evaluates to a 32-bit integer that specifies the base address of the memory range. The 32bit field DescriptorName. _BAS is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 32-bit integer that specifies the total number of bytes decoded in the memory range. The 32-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The Memory32Fixed macro evaluates to a buffer which contains a 32-bit memory descriptor, which describes a fixed range of memory addresses. The format of the fixed 32-bit memory descriptor can be found in 32-Bit Fixed Memory Range Descriptor (page 429). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "Method (Declare Control Method)",
    "syntax": "Method (MethodName, NumArgs, SerializeRule, SyncLevel, ReturnType, ParameterTypes) {TermList}",
    "arguments": "MethodName is evaluated as a Namestring data type.\nNumArgs is optional and is the required number of arguments to be passed to the method, evaluated as an Integer data type. If not specified, the default value is zero arguments. Up to 7 arguments may be passed to a method. These arguments may be referenced from within the method as Arg0 through Arg6.\nSerializeRule is optional and is a flag that defines whether the method is serialized or not and is one of the following: Serialized or NotSerialized. A method that is serialized cannot be reentered by additional threads. If not specified, the default is NotSerialized.\nSyncLevel is optional and specifies the synchronization level for the method (0 15). If not specified, the default sync level is zero.\nReturnType is optional and specifies the type(s) of the object(s) returned by the method. If the method does not return an object, then nothing is specified or UnknownObj is specified. To specify a single return type, simply use the ObjectTypeKeyword (e.g. IntObj, PkgObj, etc.). To specify multiple possible return types, enclose the comma-separated ObjectTypeKeywords with braces. For example: {IntObj, BuffObj}.\nParameterTypes is optional and specifies the type of the method parameters. It is a comma-separated, variable-length list of the expected object type or types for each of the method parameters, enclosed in braces. For each parameter, the parameter type consists of either an ObjectTypeKeyword or a commaseparated sub-list of ObjectTypeKeywords enclosed in braces. If ParameterTypes is specified, the number of parameters must match NumArgs.\nTermList is a variable-length list of executable ASL statements representing the body of the control method.",
    "description": "Creates a new control method of name MethodName. This is a named package containing a series of object references that collectively represent a control method, which is a procedure that can be invoked to perform computation. Method opens a name scope.\nSystem software executes a control method by referencing the objects in the package in order. For more information on method execution, see Section 5.5.2, \u201cControl Method Execution.\u201d\nThe current namespace location used during name creation is adjusted to be the current location on the namespace tree. Any names created within this scope are \u201cbelow\u201d the name of this package. The current namespace location is assigned to the method package, and all namespace references that occur during control method execution for this package are relative to that location.\nIf a method is declared as Serialized, an implicit mutex associated with the method object is acquired at the specified SyncLevel. If no SyncLevel is specified, SyncLevel 0 is assumed. The serialize rule can be used to prevent reentering of a method. This is especially useful if the method creates namespace objects.\nWithout the serialize rule, the reentering of a method will fail when it attempts to create the same namespace object.\nThere are eight local variables automatically available for each method, referenced as Local0 through Local7. These locals may be used to store any type of ASL object.\nAlso notice that all namespace objects created by a method have temporary lifetime. When method execution exits, the created objects will be destroyed.",
    "example": "The following block of ASL sample code shows a use of Method for defining a control method that turns on a power resource.\nMethod (_ON) {\n    Store (One, GIO.IDEP)          // assert power     Sleep (10)                     // wait 10ms\n    Store (One, GIO.IDER)          // de-assert reset#\n    Stall (10)                     // wait 10us\n    Store (Zero, GIO.IDEI)         // de-assert isolation }\nThis method is an implementation of _SRS (Set Resources). It shows the use of a method argument and two method locals.\nMethod (_SRS, 1, NotSerialized)\n{\n    CreateWordField (Arg0, One, IRQW)\n    Store (\\_SB.PCI0.PID1.IENA, Local1)\n    Or (IRQW, Local1, Local1)\n    Store (Local1, \\_SB.PCI0.PID1.IENA)\n    FindSetRightBit (IRQW, Local0)\n    If (Local0)\n    {\n        Decrement (Local0)\n        Store (Local0, \\_SB.PCI0.PID1.IN01)\n    }\n}"
  },
  {
    "title": "Mid (Extract Portion of Buffer or String)",
    "syntax": "Mid (Source, Index, Length, Result) => Buffer or String",
    "arguments": "Source is evaluated as either a Buffer or String. Index and Length are evaluated as Integers.",
    "description": "If Source is a buffer, then Length bytes, starting with the Indexth byte (zero-based) are optionally copied into Result. If Index is greater than or equal to the length of the buffer, then the result is an empty buffer. Otherwise, if Index + Length is greater than or equal to the length of the buffer, then only bytes up to and including the last byte are included in the result.\nIf Source is a string, then Length characters, starting with the Indexth character (zero-based) are optionally copied into Result. If Index is greater than or equal to the length of the buffer, then the result is an empty string. Otherwise, if Index + Length is greater than or equal to the length of the string, then only bytes up to an including the last character are included in the result.",
    "example": ""
  },
  {
    "title": "Mod (Integer Modulo)",
    "syntax": "Mod (Dividend, Divisor, Result) => Integer\nResult = Dividend % Divisor => Integer\nResult %= Divisor => Integer",
    "arguments": "Dividend and Divisor are evaluated as Integers.",
    "description": "The Dividend is divided by Divisor, and then the resulting remainder is optionally stored into Result. If Divisor evaluates to zero, a fatal exception is generated.",
    "example": ""
  },
  {
    "title": "Multiply (Integer Multiply)",
    "syntax": "Multiply (Multiplicand, Multiplier, Result) => Integer\nResult = Multiplicand * Multiplier => Integer\nResult *= Multiplier => Integer",
    "arguments": "Multiplicand and Multiplier are evaluated as Integers.",
    "description": "The Multiplicand is multiplied by Multiplier and the result is optionally stored into Result. Overflow conditions are ignored and results are undefined.",
    "example": ""
  },
  {
    "title": "Mutex (Declare Synchronization/Mutex Object)",
    "syntax": "Mutex (MutexName, SyncLevel)",
    "arguments": "The MutexName is evaluated as a Namestring data type.\nThe SyncLevel is optional and specifies the logical nesting level of the Mutex synchronization object. The current sync level is maintained internally for a thread, and represents the greatest SyncLevel among mutex objects that are currently acquired by the thread. The SyncLevel of a thread, before acquiring any mutexes, is zero. The SyncLevel of the Global Lock (\\_GL) is zero. If not specified, the default sync level value is zero.",
    "description": "Creates a data mutex synchronization object named MutexName, with a synchronization level from 0 to 15 as specified by the Integer SyncLevel.\nA mutex synchronization object provides a control method with a mechanism for waiting for certain events. To prevent deadlocks, wherever more than one synchronization object must be owned, the synchronization objects must always be released in the order opposite the order in which they were acquired.\nThe SyncLevel parameter declares the logical nesting level of the synchronization object. The current sync level is maintained internally for a thread, and represents the greatest SyncLevel among mutex objects that are currently acquired by the thread. The SyncLevel of a thread before acquiring any mutexes is zero. The SyncLevel of the Global Lock (\\_GL) is zero.\nAll Acquire terms must refer to a synchronization object with a SyncLevel that is equal or greater than the current level, and all Release terms must refer to a synchronization object with a SyncLevel that is equal to the current level.\nMutex synchronization provides the means for mutually exclusive ownership. Ownership is acquired using an Acquire term and is released using a Release term. Ownership of a Mutex must be relinquished before completion of any invocation. For example, the top-level control method cannot exit while still holding ownership of a Mutex. Acquiring ownership of a Mutex can be nested (can be acquired multiple times by the same thread).",
    "example": ""
  },
  {
    "title": "Name (Declare Named Object)",
    "syntax": "Name (ObjectName, Object)",
    "arguments": "Creates a new object named ObjectName. Attaches Object to ObjectName in the Global ACPI namespace.",
    "description": "Creates ObjectName in the namespace, which references the Object.",
    "example": "The following example creates the name PTTX in the root of the namespace that references a package.\nName (\\PTTX,                    // Port to Port Translate Table\n    Package () {Package () {0x43, 0x59}, Package) {0x90, 0xFF}} )\nThe following example creates the name CNT in the root of the namespace that references an integer data object with the value 5.\nName (\\CNT, 5)"
  },
  {
    "title": "NAnd (Integer Bitwise Nand)",
    "syntax": "NAnd (Source1, Source2, Result) => Integer",
    "arguments": "Source1 and Source2 are evaluated as Integers.",
    "description": "A bitwise NAND is performed and the result is optionally stored in Result.",
    "example": ""
  },
  {
    "title": "NoOp Code (No Operation)",
    "syntax": "NoOp",
    "arguments": "",
    "description": "This operation has no effect.",
    "example": ""
  },
  {
    "title": "NOr (Integer Bitwise Nor)",
    "syntax": "NOr (Source1, Source2, Result) => Integer",
    "arguments": "Source1 and Source2 are evaluated as Integers.",
    "description": "A bitwise NOR is performed and the result is optionally stored in Result.",
    "example": ""
  },
  {
    "title": "Not (Integer Bitwise Not)",
    "syntax": "Not (Source, Result) => Integer\nResult = ~Source => Integer",
    "arguments": "Source is evaluated as an integer data type.\nA bitwise NOT is performed and the result is optionally stored in Result.",
    "description": "",
    "example": ""
  },
  {
    "title": "Notify (Notify Object of Event)",
    "syntax": "Notify (Object, NotificationValue)",
    "arguments": "Notifies the OS that the NotificationValue for the Object has occurred. Object must be a reference to a device, processor, or thermal zone object.",
    "description": "Object type determines the notification values. For example, the notification values for a thermal zone object are different from the notification values used for a device object. Undefined notification values are treated as reserved and are ignored by the OS.\nFor lists of defined Notification values, see Section 5.6.6, \u201cDevice Object Notifications.\u201d",
    "example": ""
  },
  {
    "title": "Offset (Change Current Field Unit Offset)",
    "syntax": "Offset (ByteOffset)",
    "arguments": "ByteOffset is the new offset (in bytes) for the next FieldUnit within a FieldList.",
    "description": "The Offset operator is used within a FieldList to specify the byteOffset of the next defined field within its parent operation region. This can be used instead of defining the bit lengths that need to be skipped. All offsets are defined starting from zero, based at the starting address of the parent region.",
    "example": ""
  },
  {
    "title": "ObjectType (Get Object Type)",
    "syntax": "ObjectType (Object) => Integer",
    "arguments": "Object is any valid object.",
    "description": "The execution result of this operation is an integer that has the numeric value of the object type for Object.\nThe object type codes are listed in Table 18-20. Notice that if this operation is performed on an object reference such as one produced by the Alias, Index, or RefOf statements, the object type of the base object is returned. For typeless objects such as predefined scope names (in other words, \\_SB, \\_GPE, etc.), the type value 0 (Uninitialized) is returned.\nTable 19-433 TValues Returned By the ObjectType Operator\nValue\nObject\n0\nUninitialized\n1\nInteger\n2\nString\n3\nBuffer\n4\nPackage\n5\nField Unit\n6\nDevice\n7\nEvent\n8\nMethod\n9\nMutex\n10\nOperation Region\n11\nPower Resource\n12\nProcessor\n13\nThermal Zone\n14\nBuffer Field\n15\nDDB Handle\n16\nDebug Object\n>16\nReserved",
    "example": ""
  },
  {
    "title": "One (Constant One Integer)",
    "syntax": "One=> Integer",
    "arguments": "",
    "description": "The One operator returns an Integer with the value 1. Writes to this object are not allowed. The use of this operator can reduce AML code size, since it is represented by a one-byte AML opcode.",
    "example": ""
  },
  {
    "title": "Ones (Constant Ones Integer)",
    "syntax": "Ones=> Integer\nThe Ones operator returns an Integer with all bits set to 1. Writes to this object are not allowed. The use of this operator can reduce AML code size, since it is represented by a one-byte AML opcode.\nNote:     The actual value of the integer returned by the Ones operator depends on the integer width of the\nDSDT. If the revision of the DSDT is 1 or less, the integer width is 32 bits and Ones returns 0xFFFFFFFF. If the revision of the DSDT is 2 or greater, the integer width is 64 bits and Ones returns 0xFFFFFFFFFFFFFFFF. This difference must be considered when performing comparisons against the Ones Integer.",
    "arguments": "",
    "description": "",
    "example": ""
  },
  {
    "title": "OperationRegion (Declare Operation Region)",
    "syntax": "OperationRegion (RegionName, RegionSpace, Offset, Length)",
    "arguments": "Declares an operation region named RegionName. Offset is the offset within the selected RegionSpace at which the region starts (byte-granular), and Length is the length of the region in bytes.",
    "description": "An Operation Region is a type of data object where read or write operations to the data object are performed in some hardware space. For example, the Definition Block can define an Operation Region within a bus, or system I/O space. Any reads or writes to the named object will result in accesses to the I/ O space.\nOperation regions are regions in some space that contain hardware registers for exclusive use by ACPI control methods. In general, no hardware register (at least byte-granular) within the operation region accessed by an ACPI control method can be shared with any accesses from any other source, with the exception of using the Global Lock to share a region with the firmware. The entire Operation Region can be allocated for exclusive use to the ACPI subsystem in the host OS.\nOperation Regions that are defined within the scope of a method are the exception to this rule. These Operation Regions are known as \u201cDynamic\u201d since the OS has no idea that they exist or what registers they use until the control method is executed. Using a Dynamic SystemIO or SystemMemory Operation Region is not recommended since the OS cannot guarantee exclusive access. All other types of Operation Regions may be Dynamic.\nOperation Regions define the overall base address and length of a hardware region, but they cannot be accessed directly by AML code. A Field object containing one or more FieldUnits is used to overlay the Operation Region in order to access individual areas of the Region. An individual FieldUnit within an Operation Region may be as small as one bit, or as large as the length of the entire Region. FieldUnit values are normalized (shifted and masked to the proper length.) The data type of a FieldUnit can be either a Buffer or an Integer, depending on the bit length of the FieldUnit. If the FieldUnit is smaller than or equal to the size of an Integer (in bits), it will be treated as an Integer. If the FieldUnit is larger than the size of an Integer, it will be treated as a Buffer. The size of an Integer is indicated by the DSDT header\u2019s Revision field. A revision less than 2 indicates that the size of an Integer is 32 bits. A value greater than or equal to 2 signifies that the size of an Integer is 64 bits. For more information about data types and FieldUnit type conversion rules, see Section 19.3.5.7, \u201cData Type Conversion Rules\u201d.\nAn Operation Region object implicitly supports Mutex synchronization. Updates to the object, or a Field data object for the region, will automatically synchronize on the Operation Region object; however, a control method may also explicitly synchronize to a region to prevent other accesses to the region (from other control methods). Notice that according to the control method execution model, control method execution is non-preemptive. Because of this, explicit synchronization to an Operation Region needs to be done only in cases where a control method blocks or yields execution and where the type of register usage requires such synchronization.\nThe predefined Operation Region types specified in ACPI are shown in the Table 5-160 on page 275.",
    "example": "The following example ASL code shows the use of OperationRegion combined with Field to describe IDE 0 and 1 controlled through general I/O space, using one FET.\nOperationRegion (GIO, SystemIO, 0x125, 0x1)\nField (GIO, ByteAcc, NoLock, Preserve) {\n    IDEI,    1,        // IDEISO_EN    - isolation buffer\n    IDEP,    1,        // IDE_PWR_EN   - power\n    IDER,    1         // IDERST#_EN   - reset# }"
  },
  {
    "title": "Or (Integer Bitwise Or)",
    "syntax": "Or (Source1, Source2, Result) => Integer\nResult = Source1 | Source2 => Integer\nResult |= Source1 => Integer",
    "arguments": "Source1 and Source2 are evaluated as Integers.",
    "description": "A bitwise OR is performed and the result is optionally stored in Result.",
    "example": ""
  },
  {
    "title": "Package (Declare Package Object)",
    "syntax": "Package (NumElements) {PackageList} => Package",
    "arguments": "NumElements is evaluated as an Integer. PackageList is an initializer list of objects.\nDeclares an unnamed aggregation of named data items, constants, and/or references to  non-data namespace objects. The size of the package is NumElements. The PackageList contains the data items, constants, and/or object references used to initialize the package.\nIf NumElements is absent, it is automatically set by the ASL compiler to match the number of elements in the PackageList. If NumElements is present and greater than the number of elements in the PackageList, the default entry of type Uninitialized  (see ObjectType) is used to initialize the package elements beyond those initialized from the PackageList.\nThere are three types of package elements allowed in the PackageList: ConstantData Objects(Integers, Strings, Buffers, and Packages), named references that resolve to Data Objects (Integers, Strings, Buffers, and Packages), and named references to objects other than Data Objects.\nThese constant terms are resolved at ASL compile time:\n\u2022       Integer Constant\n\u2022       String Constant\n\u2022       Buffer Constant\n\u2022       Package Constant\nThese Named References to Data Objects are resolved to actual data by the AML Interpreter at runtime:\n\u2022       Integer reference\n\u2022       String reference\n\u2022       Buffer reference\n\u2022       Buffer Field reference\n\u2022       Field Unit reference\n\u2022       Package reference\nThese Named References to non-Data Objects cannot be resolved to values. They are instead returned in the package as references:\n\u2022       Device reference\n\u2022       Event reference\n\u2022       Method reference\n\u2022       Mutex reference\n\u2022       Operation Region reference\n\u2022       Power Resource reference\n\u2022       Processor reference\n\u2022       Thermal Zone reference\nNote:     For Package elements of type Package (defining a subpackage), individual elements of the subpackage are resolved according to the rules above, both compile-time and runtime.\nEvaluating an uninitialized element will yield a runtime error, but elements can be assigned values at runtime to define them (via the Index operator). It is a compile time error for NumElements to be less than the number of elements defined in the PackageList.\nThe ASL compiler can emit two different AML opcodes for a Package declaration, either PackageOp or VarPackageOp. For small, fixed-length packages, the PackageOp is used and this opcode is compatible with ACPI 1.0. A VarPackageOp will be emitted if any of the following conditions are true:\n\u2022       The NumElements argument is a TermArg that can only be resolved at runtime.\n\u2022       At compile time, NumElements resolves to a constant that is larger than 255.\n\u2022       The PackageList contains more than 255 initializer elements.",
    "description": "",
    "example": "Name (INT1, 0x1234)\nProcessor (CPU0, 0, 0x1010, 6) {}\nPowerResource (PWR1, 0, 0) {}\nName (PKG1, Package () {\n    0x3400,      // Integer Constant, resolved at compile time\n    \"Processor\"  // String Constant, resolved at compile time\n    \\INT1        // Integer Reference, resolved to value at\n                 // runtime\n    \\CPU0        // Object Reference, returned as a reference\n                 // object\n    Package () { // Package Constant. Elements are resolved at\n                 // both compile time and runtime\n        0x4321,  // Integer Constant, resolved at compile time\n        \\INT1,   // Integer Reference, resolved to value at\n                 // runtime\n        \\PWR1\n    })\nThe runtime values of the parent package and subpackages are:\nPackage [Contains 0x05 Elements]\n(00)  Integer 0x0000000000003400\n(01)  String [0x09] \"Processor\"\n(02)  Integer 0x0000000000001234\n(03)  Reference [Named Object] [CPU0] Processor\n(04)  Package [Contains 0x03 Elements]\n(00)  Integer 0x0000000000004321\n(01)  Integer 0x0000000000001234\n(02)  Reference [Named Object] [PWR1] Power}"
  },
  {
    "title": "PinConfig (Pin Configuration)",
    "syntax": "Macro:\nPinConfig (Shared/Exclusive, PinConfigType, PinConfigValue, ResourceSource,\nResourceSourceIndex, ResourceUsage, DescriptorName, VendorData) {Pin List}",
    "arguments": "\u2022       Shared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\n\u2022       PinConfigType can be one of the configuration types described below in Table 19-434. The bit field _TYP is automatically created to refer to this portion of the resource descriptor.\n\u2022       PinConfigValue is one of the configurations values described below in Table 19-434. The bit field _VAL is automatically created to refer to this portion of the resource descriptor.\n\u2022       ResourceSource is a string which uniquely identifies the pin controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\n\u2022       ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.\n\u2022       ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.\n\u2022       DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\n\u2022       VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.\n\u2022       PinList is a list of pin numbers on the ResourceSource that are described by this descriptor. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.\nTable 19-434 Pin Configuration Types and Values\nPin Configuration Type\nPin Configuration Value",
    "description": "0x00 = Default\nN/A\nDefault configuration. No configuration is applied.\n0x01 = Bias Pull-Up\nPull up resistance, in\nOhms.\nThis means the pin is pulled up with a certain number of Ohms to an implicitly supplied VDD rail.\n0x02 = Bias Pull-down\nPull down resistance, in Ohms.\nThis means the pin is pulled down with a certain number of Ohms, toward the GND rail.\n0x03 = Bias Default\nN/A\nIf the silicon has a default biasing mode, reset the pin to this mode.\n0x04 = Bias Disable\nN/A\nAny software-selectable bias settings on the pin will be disabled.\n0x05 = Bias High Impedance\nN/A\nThis means that the pin is configured into a high impedance mode and essentially shut off from the outside world. It will not influence the signal state if a rail is connected to the pin, hence a good default mode.\n0x06 = Bias Bus Hold\nN/A\nThis will make the pin in a weak latch state where it weakly drives the last value on a tristate bus.\n0x07 = Drive Open Drain\nN/A\nThis will configure the pin into open drain (open collector) state.\nPin Configuration Type\nPin Configuration Value\n0x08 = Drive Open Source\nN/A\nThis will configure the pin into open source (open emitter) state.\n0x09 = Drive Push Pull\nN/A\nThis will configure the pin into explicit push-pull state. This is useful if the power-on default state is e.g. open drain or high impedance state.\n0x0A = Drive Strength\nDrive strength in milliamperes\nThis will set the output driver of the pin to supply a certain number of milliamperes, usually by activating several driver stages.\n0x0B = Slew Rate\nCustom format\nThis controls the slew rate of the pin, affecting speed but also sharpness of edges and thus noisiness on the board. The hardware-specific argument tells what slew rate to configure\n0x0C = Input Debounce\nDebounce time in microseconds.\nThis will enable debouncing (for e.g. key inputs) of the pin signal.\n0x0D = Input Schmitt Trigger\nEnabled = 1, Disabled = 0\nThis will enable Schmitt trigger support for the line.\n0x0E 0x7F = Reserved\nReserved\nReserved\n0x80 0xFF = Vendor defined values\nCustom base\nFrom this point, vendor and Hardware-specific configurations are listed.\nThe PinConfig macro evaluates to a buffer that contains a Pin Configuration resource descriptor. The format of the Pin Configuration resource descriptor can be found in \u201cPin Configuration Descriptor\u201d on page 462. The macro is designed to be used inside of an ASL Resource Template (Section 19.3.3).\nNote: There is some overlap between the properties set by GpioIo/GpioInt/ PinFunction and PinConfig descriptors.  For example, both are setting properties such as pull-ups. If the same property is specified by multiple descriptors for the same pins, the order in which these properties are applied is undetermined. To avoid any conflicts, GpioInt/GpioIo/PinFunction should provide a default value for these properties when PinConfig is used. If PinConfig is used to set pin bias, PullDefault should be used for GpioIo/GpioInt/ PinFunction. If PinConfig is used to set debounce timeout, 0 should be used for GpioIo/GpioInt. If PinConfig is used to set drive strength, 0 should be used for GpioIo.",
    "example": "//\n// Description: GPIO\n//\nDevice (GPI0)\n{\n    Name (_HID, \"PNPFFFE\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4FE00000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x54}\n       })\n        Return(RBUF)\n}\n}\n//\n// Description: I2C controller 1\n//\nDevice (I2C1)\n{\n    Name (_HID, \"PNPFFFF\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4F800000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x55}\n            PinFunction(Exclusive, PullDefault, 0x5,\n\"\\\\_SB.GPI0\", 0, ResourceConsumer, )  {2, 3}\n       // Configure 10k Pull up for I2C SDA/SCL pins\n       PinConfig(Exclusive, 0x01, 10000, \"\\\\_SB.GPI0\", 0, ResourceConsumer, ) {2, 3}\n        })\n        Return(RBUF)\n    } }\n//\n// Description: Physical display panel //\nDevice (SDIO)\n{\n    Name (_HID, \"PNPFFFD\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x57}\n            GpioIo(Shared, PullDefault, 0, 0, IoRestrictionNone,\n\"\\\\_SB.GPI0\",) {2, 3}\n       // Configure 20k Pull down\n       PinConfig(Exclusive, 0x02, 20000, \"\\\\_SB.GPI0\", 0,\nResourceConsumer, ) {2, 3}\n       // Enable Schmitt-trigger\n       PinConfig(Exclusive, 0x0D, 1, \"\\\\_SB.GPI0\", 0,\nResourceConsumer, ) {2, 3}\n       // Set slew rate to custom value 3\n       PinConfig(Exclusive, 0x0B, 3, \"\\\\_SB.GPI0\", 0, ResourceConsumer, ) {2, 3}\n        })\n        Return(RBUF)\n}\n}"
  },
  {
    "title": "PinFunction (Pin Function)",
    "syntax": "Macro:\nPinFunction(Shared/Exclusive, PinPullConfiguration, FunctionNumber, ResourceSource,\nResourceSourceIndex, ResourceUsage, DescriptorName, VendorData) {Pin List}",
    "arguments": "\u2022       Shared is an optional argument and can be one of Shared, Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\n\u2022       PinPullConfiguration can be one of PullDefault, PullUp, PullDown, PullNone or a vendorsupplied value in the range 128-255.\n\u2022       FunctionNumber is a provider-specific integer that designates which function is being described.\n\u2022       ResourceSource is a string which uniquely identifies the GPIO controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\n\u2022       ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.\n\u2022       ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.\n\u2022       DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\n\u2022       VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.\n\u2022       PinList is a non-empty list of (zero-based) pin numbers on the ResourceSource that are described by this descriptor. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.",
    "description": "The PinFunction macro evaluates to a buffer that contains a Pin Function resource descriptor, as described in this section. The macro is designed to be used inside of a Resource Template (Section 19.3.3).\nNote: PinFunction macro allows for maximum flexibility to define the desired function of each pin individually. It is the responsibility of the firmware writer to take into account any platform-level restrictions where pin function must be applied at a coarser granularity. Thus, if the platform design requires the functions for a set of pins to be configured as group, the firmware writer must ensure this is done in the corresponding PinFunction description by specifying all relevant pins in a single PinFunction.  In the multi-pin scenario, the OSPM must honor the PinFunction requirements for all of the specified pins on an \u201call-or-nothing\u201d basis.\nNote: The Pin Function descriptor is intended for scenarios where non-GPIO functions are desired. For GPIO-based functionalities, the firmware should always specify the appropriate GpioIo or Gpioint descriptor.",
    "example": "//\n// Description: GPIO //\nDevice (GPI0)\n{\n    Name (_HID, \"PNPFFFE\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4FE00000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x54}\n       })\n        Return(RBUF)\n}\n//\n// Description: I2C controller 1 //\nDevice (I2C1)\n{\n    Name (_HID, \"PNPFFFF\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4F800000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x55}\n            PinFunction(Exclusive, PullUp, 0x5, \"\\\\_SB.GPI0\", 0,\nResourceConsumer, )  {2, 3}\n        })\n        Return(RBUF)\n    }\n}\n//\n// Description: I2C controller 2\n//\nDevice (I2C2)\n{\n    Name (_HID, \"PNPFFFF\")\n    Name (_UID, 0x1)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x56}\n            PinFunction(Exclusive, PullUp, 0x0, 0x4,\n\"\\\\_SB.GPI0\", 0, ResourceConsumer, )  {2, 3}\n        })\n        Return(RBUF)\n}\n}\n//\n// Description: Physical display panel //\nDevice (DISP)\n{\n    Name (_HID, \"PNPFFFD\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) {0x57}\n            GpioIo(Shared, PullDefault, 0, 0, IoRestrictionNone,\n\"\\\\_SB.GPI0\",) {2, 3}\n        })\n        Return(RBUF)\n}\n}"
  },
  {
    "title": "PinGroup (Pin Group)",
    "syntax": "Macro:\nPinGroup (ResourceLabel, ResourceUsage, DescriptorName, VendorData) { Pin List } Arguments\n\u2022       ResourceUsage is an optional argument and is assumed to be ResourceProducer for this revision.\n\u2022       ResourceLabel is an arbitrary, non-empty string that uniquely identifies this particular PinGroup resource from others within a resource template buffer. This label is used by resource consumers to refer to this resource.\n\u2022       DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\n\u2022       VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.\n\u2022       PinList is a non-empty list of (zero-based) pin numbers on the ResourceSource that are described by this descriptor. The bit field name _PIN is automatically created to refer to this portion of the resource descriptor.",
    "arguments": "",
    "description": "The PinGroup macro evaluates to a buffer that contains a Pin Group resource descriptor. The format of the Pin Group resource descriptor can be found in \"Pin Group Descriptor\" (Section 6.4.3.11). The macro is designed to be used inside of a Resource Template (Section 19.3.3).\nPinGroup resource descriptors must be declared within the scope of the pin controller device to which the pins belong.",
    "example": ""
  },
  {
    "title": "PinGroupConfig (Pin Group Configuration)",
    "syntax": "Macro:\nPinGroupConfig (Shared/Exclusive, PinConfigType, PinConfigValue, ResourceSource, ResourceSourceIndex, ResourceSourceLabel, ResourceUsage, DesriptorName, VendorData) Arguments:\n\u2022       Shared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\n\u2022       PinConfigType can be one of the configuration types described below in Table 19-435. The bit field name _TYP is automatically created to refer to this portion of the resource descriptor.\n\u2022       PinConfigValue is one of the configurations values described below in Table 19-435. The bit field name _VAL is automatically created to refer to this portion of the resource descriptor. \u2022        ResourceSource is a string that uniquely identifies the GPIO controller which includes the PinGroup resource referenced by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\n\u2022       ResourceSourceLabel is a non-empty string argument that matches ResourceLabel of the PinGroup resource in the current resource template buffer of the GPIO controller referenced in ResourceSource.\n\u2022       DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\n\u2022       ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.\n\u2022       ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.\n\u2022       VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.\nTable 19-435 Pin Group Configuration Types and Values\nPin Configuration Type\nPin Configuration Value",
    "arguments": "",
    "description": "0x00 = Default\nN/A\nDefault configuration. No configuration is applied).\n0x01 = Bias Pull-Up\nPull up resistance, in\nOhms.\nThis means the pin is pulled up with a certain number of Ohms to an implicitly supplied VDD rail.\n0x02 = Bias Pull-down\nPull down resistance, in Ohms.\nThis means the pin is pulled down with a certain number of Ohms, toward the GND rail.\n0x03 = Bias Default\nN/A\nIf the silicon has a default biasing mode, reset the pin to this mode.\n0x04 = Bias Disable\nN/A\nAny software-selectable bias settings on the pin will be disabled.\n0x05 = Bias High Impedance\nN/A\nThis means that the pin is configured into a high impedance mode and essentially shut off from the outside world. It will not influence the signal state if a rail is connected to the pin, hence a good default mode.\nPin Configuration Type\nPin Configuration Value\n0x06 = Bias Bus Hold\nN/A\nThis will make the pin in a weak latch state where it weakly drives the last value on a tristate bus.\n0x07 = Drive Open Drain\nN/A\nThis will configure the pin into open drain (open collector) state.\n0x08 = Drive Open Source\nN/A\nThis will configure the pin into open source (open emitter) state.\n0x09 = Drive Push Pull\nN/A\nThis will configure the pin into explicit pushpull state. This is useful if the power-on default state is e.g. open drain or high impedance state.\n0x0A = Drive Strength\nDrive strength in milliamperes\nThis will set the output driver of the pin to supply a certain number of milliamperes, usually by activating several driver stages.\n0x0B = Slew Rate\nCustom format\nThis controls the slew rate of the pin, affecting speed but also sharpness of edges and thus noisiness on the board. The hardware-specific argument tells what slew rate to configure\n0x0C = Input Debounce\nDebounce time in microseconds.\nThis will enable debouncing (for e.g. key inputs) of the pin signal.\n0x0D = Input Schmitt Trigger\nEnabled = 1, Disabled = 0\nThis will enable Schmitt trigger support for the line.\n0x0E 0x7F = Reserved\nReserved\nReserved\n0x80 0xFF = Vendor defined values\nCustom base\nFrom this point, vendor and Hardwarespecific configurations are listed.\nThe PinGroupConfig macro evaluates to a buffer that contains a Pin Group Configuration resource descriptor. The format of the Pin Group Configuration resource descriptor can be found in \"Pin Group Configuration Descriptor\" (Section 6.4.3.13). The macro is designed to be used inside of a Resource Template (Section 19.3.3).",
    "example": "//\n// Description: GPIO\n//\nDevice (GPI0)\n{\n    Name (_HID, \"PNPFFFE\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4FE00000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x54}\n            PinGroup(\u201cgroup1\u201d, ResourceProducer) {2, 3}\n       })\n        Return(RBUF)\n}\n//\n// Description: I2C controller 1 //\nDevice (I2C1)\n{\n    Name (_HID, \"PNPFFFF\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4F800000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x55}\n            // Set function I2C1 for SDA/SCL pins             \n            PinGroupFunction(Exclusive, 0x5, \"\\\\_SB.GPI0, 0,\n\u201cgroup1\u201d, ResourceConsumer, )\n            // Configure 10k Pull up for SDA/SCL pins\n            PinGroupConfig(Exclusive, 0x01, 10000, \"\\\\_SB.GPI0 \", \n0, \u201cgroup1\u201d, ResourceConsumer, )\n        })\n        Return(RBUF)\n    }\n}\n//\n// Description: I2C controller 2 //\nDevice (I2C2)\n{\n    Name (_HID, \"PNPFFFF\")\n    Name (_UID, 0x1)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)\n            Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x56}\n            // Set function I2C2 for SDA/SCL pins           \n            PinGroupFunction(Exclusive, 0x4, \"\\\\_SB.GPI0 \", 0,\n\u201cgroup1\u201d, ResourceConsumer, )\n            // Configure 10k Pull up for SDA/SCL pins\n            PinGroupConfig(Exclusive, 0x01, 10000, \"\\\\_SB.GPI0 \",\n0, \u201cgroup1\u201d, ResourceConsumer,)\n        })\n        Return(RBUF)\n}\n}\n//\n// Description: Physical display panel //\nDevice (DISP)\n{\n    Name (_HID, \"PNPFFFD\")\n    Name (_UID, 0x0)\n    Method (_STA)\n    {\n        Return(0xf)\n    }\n    Method (_CRS, 0x0, NotSerialized)\n    {\n        Name (RBUF, ResourceTemplate()\n        {\n            Memory32Fixed(ReadWrite, 0x4F900000, 0x20)             Interrupt(ResourceConsumer, Level, ActiveHigh,\nShared) {0x57}\n            // Set function GPIO for pin group group1\n            PinGroupFunction(Exclusive, 0x1, \"\\\\_SB.GPI0 \", 0,\n\u201cgroup1\u201d, ResourceConsumer, )\n            // Configure 20k Pull down\n            PinGroupConfig (Exclusive, 0x02, 20000, \"\\\\_SB.GPI0\n\", 0, \u201cgroup1\u201d, ResourceConsumer, )\n            //Enable Schmitt-trigger\n            PinGroupConfig (Exclusive, 0x0D, 1, \"\\\\_SB.GPI0 \", 0,\n\u201cgroup1\u201d, ResourceConsumer, )\n            //Set slew rate to custom value 3\n            PinGroupConfig (Exclusive, 0x0B, 3, \"\\\\_SB.GPI0 \", 0,\n\u201cgroup1\u201d, ResourceConsumer, )\n        })\n        Return(RBUF)}\n}\n}"
  },
  {
    "title": "PinGroupFunction (Pin Group Function)",
    "syntax": "Macro:\nPinGroupFunction (Shared/Exclusive, FunctionNumber, ResourceSource, ResourceSourceIndex, ResourceSourceLabel, ResourceUsage, DescriptorName, VendorData) Arguments\n\u2022       Shared is an optional argument and can be one of Shared, Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\n\u2022       FunctionNumber is a provider-specific integer which designates which function is being described. The bit field name _FUN is automatically created to refere to this portion of the resource descriptor.\n\u2022       ResourceSource is a string that uniquely identifies the GPIO controller which includes the PinGroup resource referenced by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\n\u2022       ResourceSourceLabel is a non-empty string argument that matches ResourceLabel of a PinGroup resource in the current resource template buffer of the GPIO controller referenced in ResourceSource.\n\u2022       DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\n\u2022       ResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.\n\u2022       ResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.\n\u2022       VendorData is an optional argument that specifies a RawDataBuffer containing vendor-defined byte data to be decoded by the OS driver. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.",
    "arguments": "",
    "description": "The PinGroupFunction macro evaluates to a buffer that contains a Pin Function resource descriptor. The format of the Pin Function resource descriptor can be found in \u201cPin Function Descriptor\u201d on page 460. The macro is designed to be used inside of an ASL Resource Template (Section 19.3.3).",
    "example": ""
  },
  {
    "title": "PowerResource (Declare Power Resource)",
    "syntax": "PowerResource (ResourceName, SystemLevel, ResourceOrder) {TermList}",
    "arguments": "Declares a power resource named ResourceName. PowerResource opens a name scope.",
    "description": "For a definition of the PowerResource term, see Section 7.2, \u201cDeclaring a Power Resource Object.\u201d\nThe power management object list is encoded as TermList, so that rather than describing a static power management object list, it is possible to describe a dynamic power management object list according to the system settings. See \"Section 5.4.2, Definition Block Loading.\"",
    "example": ""
  },
  {
    "title": "Printf (Create and Store formatted string)",
    "syntax": "Printf (FormatString, FormatArgs) => String",
    "arguments": "Printf is a macro that converts the evaluated FormatString into a series of string Concatenate operations, storing the result in the Debug object.\nFormatString is a string literal which may contain one or more uses of the format specifier, %o, to indicate locations in the string where an object may be inserted. %o is the only format specifier supported since the resulting object is a string and type conversion is handled automatically by Concatenate.\nFormatArgs is a comma separated list of Named Objects, Locals, or Args that can be evaluated to a string. Each argument is added to the FormatString using the Concatenate operation at the location specified by %o in order of appearance.",
    "description": "The Printf macro converts a format string into a series of cascading string Concatenate operations, and stores the result in the Debug object",
    "example": "The following ASL example uses Printf to write a formatted string with the values of Arg0, Arg1, Arg2, and Arg3 to the Debug Object.\n    Printf (\"%o: Unexpected value for %o, %o at line %o\",             Arg0, Arg1, Arg2, Arg3)\nThis Printf macro expression evaluates to the following ASL operation.\n    Store (Concatenate (Concatenate (Concatenate (Concatenate\n          (Concatenate (Concatenate (Concatenate (\"\", Arg0),\n           \": Unexpected value for \"), Arg1), \", \"), Arg2),\n           \" at line \"), Arg3), Debug)"
  },
  {
    "title": "Processor (Declare Processor)",
    "syntax": "Processor (ProcessorName, ProcessorID, PBlockAddress, PblockLength) {TermList}",
    "arguments": "Declares a named processor object named ProcessorName. Processor opens a name scope. Each processor is required to have a unique ProcessorID value that is unique from any other ProcessorID value.\nFor each processor in the system, the ACPI system firmware declares one processor object in the namespace anywhere within the \\_SB scope. For compatibility with operating systems implementing ACPI 1.0, the processor object may also be declared under the \\_PR scope. An ACPI-compatible namespace may define Processor objects in either the \\_SB or \\_PR scope but not both.\nPBlockAddress provides the system I/O address for the processors register block. Each processor can supply a different such address. PBlockLength is the length of the processor register block, in bytes and is either 0 (for no P_BLK) or 6. With one exception, all processors are required to have the same\nPBlockLength. The exception is that the boot processor can have a non-zero PBlockLength when all other processors have a zero PBlockLength. It is valid for every processor to have a PBlockLength of 0.",
    "description": "The following block of ASL sample code shows a use of the Processor term.\n \n        Processor (\n            \\_PR.CPU0,        // Namespace name\n            1,\n            0x120,            // PBlk system IO address\n      6                // PBlkLen\n        ) {ObjectList}\nThe TermList is an optional list that may contain an arbitrary number of ASL Objects. Processor-specific objects that may be included in the TermList include _PTC, _CST, _PCT, _PSS, _PPC, _PSD, _TSD, _CSD, _PDC, _TPC, _TSS, and _OSC. These processor-specific objects can only be specified when the processor object is declared within the \\_SB scope. For a full definition of these objects, see Section 8, \u201cProcessor Configuration and Control.\u201d\nThe optional processor object list is encoded as TermList, so that rather than describing a static processor object list, it is possible to describe a dynamic processor object list according to the system settings. See \"Section 5.4.2, Definition Block Loading.\"",
    "example": ""
  },
  {
    "title": "QWordIO (QWord IO Resource Descriptor Macro)",
    "syntax": "QWordIO (ResourceUsage, IsMinFixed, IsMaxFixed, Decode, ISARanges, AddressGranularity,\nAddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName, TranslationType, TranslationDensity)",
    "arguments": "ResourceUsage specifies whether the I/O range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nIsMinFixed specifies whether the minimum address of this I/O range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this I/O range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nDecode specifies whether or not the device decodes the I/O range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nISARanges specifies whether the I/O ranges specifies are limited to valid ISA I/O ranges (ISAOnly), valid non-ISA I/O ranges (NonISAOnly) or encompass the whole range without limitation (EntireRange). The 2bit field DescriptorName._RNG is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is NonISAOnly, \u20182\u2019 is ISAOnly and \u20180\u2019 is EntireRange.\nAddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the I/O range must be aligned. The 64-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the I/O range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the I/O range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the I/O range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nTranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same\n(TypeStatic). If TypeTranslation is specified, then the primary side of the bus is Memory. If TypeStatic is specified, then the primary side of the bus is I/O. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is TypeTranslation and \u20180\u2019 is TypeStatic. See _TTP (page 443) for more information\nTranslationDensity is an optional argument that specifies whether or not the translation from the primary to secondary bus is sparse (SparseTranslation) or dense (DenseTranslation). It is only used when TranslationType is TypeTranslation. If nothing is specified, then DenseTranslation is assumed. The 1-bit field DescriptorName. _TRS is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SparseTranslation and \u20180\u2019 is DenseTranslation. See _TRS (page 444) for more information.",
    "description": "The QWordIO macro evaluates to a buffer which contains a 64-bit I/O resource descriptor, which describes a range of I/O addresses. The format of the 64-bit I/O resource descriptor can be found in QWord Address Space Descriptor  (page 431). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "QWordMemory (QWord Memory Resource Descriptor Macro)",
    "syntax": "QWordMemory (ResourceUsage, Decode, IsMinFixed, IsMaxFixed, Cacheable, ReadAndWrite, AddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength,\nResourceSourceIndex, ResourceSource, DescriptorName, MemoryRangeType, TranslationType)",
    "arguments": "ResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nDecode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nIsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nCacheable specifies whether or not the memory region is cacheable (Cacheable), cacheable and writecombining (WriteCombining), cacheable and prefetchable (Prefetchable) or uncacheable\n(NonCacheable). If nothing is specified, then NonCacheable is assumed. The 2-bit field DescriptorName.\n_MEM is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is Cacheable, \u20182\u2019 is WriteCombining, \u20183\u2019 is Prefetchable and \u20180\u2019 is NonCacheable.\nReadAndWrite specifies whether or not the memory region is read-only (ReadOnly) or read/write (ReadWrite). If nothing is specified, then ReadWrite is assumed. The 1-bit field DescriptorName._RW is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is ReadWrite and \u20180\u2019 is ReadOnly.\nAddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 64-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the Memory range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this Memory range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nMemoryRangeType is an optional argument that specifies the memory usage. The memory can be marked as normal (AddressRangeMemory), used as ACPI NVS space (AddressRangeNVS), used as ACPI reclaimable space (AddressRangeACPI) or as system reserved (AddressRangeReserved). If nothing is specified, then AddressRangeMemory is assumed. The 2-bit field DescriptorName. _MTP is automatically created in order to refer to this portion of the resource descriptor, where \u20180\u2019 is AddressRangeMemory, \u20181\u2019 is AddressRangeReserved, \u20182\u2019 is AddressRangeACPI and \u20183\u2019 is AddressRangeNVS.\nTranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same (TypeStatic). If TypeTranslation is specified, then the primary side of the bus is I/O. If TypeStatic is specified, then the primary side of the bus is Memory. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is TypeTranslation and \u20180\u2019 is TypeStatic. See _TTP (page 443) for more information.",
    "description": "The QWordMemory macro evaluates to a buffer which contains a 64-bit memory resource descriptor, which describes a range of memory addresses. The format of the 64-bit memory resource descriptor can be found in \u201cQWord Address Space Descriptor \u201d (page 431). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "QWordSpace (QWord Space Resource Descriptor Macro)",
    "syntax": "QWordSpace (ResourceType, ResourceUsage, Decode, IsMinFixed, IsMaxFixed, TypeSpecificFlags,\nAddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength,\nResourceSourceIndex, ResourceSource, DescriptorName)",
    "arguments": "ResourceType evaluates to an 8-bit integer that specifies the type of this resource. Acceptable values are 0xC0 through 0xFF.\nResourceUsage specifies whether the Memory range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nDecode specifies whether or not the device decodes the Memory range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nIsMinFixed specifies whether the minimum address of this Memory range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this Memory range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nTypeSpecificFlags evaluates to an 8-bit integer. The flags are specific to the ResourceType.\nAddressGranularity evaluates to a 64-bit integer that specifies the power-of-two boundary (- 1) on which the Memory range must be aligned. The 64-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 64-bit integer that specifies the lowest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 64-bit integer that specifies the highest possible base address of the\nMemory range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 64-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 64-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 64-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 64-bit integer that specifies the total number of bytes decoded in the Memory range. The 64-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this Memory range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The QWordSpace macro evaluates to a buffer which contains a 64-bit Address Space resource descriptor, which describes a range of addresses. The format of the 64-bit AddressSpace descriptor can be found in \u201cQWord Address Space Descriptor \u201d (page 431). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "RawDataBuffer",
    "syntax": "RawDataBuffer (RDBufferSize) {ByteList} => RawDataBuffer",
    "arguments": "Declares a RawDataBuffer of size RDBufferSize and optional initial value of ByteList.",
    "description": "The optional RDBufferSize parameter specifies the size of the buffer and must be a word constant. The initial value is specified in Initializer ByteList. If RDBufferSize is not specified, it defaults to the size of initializer. If the count is too small to hold the value specified by initializer, the initializer size is used.\nNote that a RawDataBuffer is not encoded as a Buffer (Opcode, Package length bytes, etc), but rather contains only the raw bytes specified.",
    "example": ""
  },
  {
    "title": "RefOf (Create Object Reference)",
    "syntax": "RefOf (Object) => ObjectReference",
    "arguments": "Object can be any object type (for example, a package, a device object, and so on).",
    "description": "Returns an object reference to Object. If the Object does not exist, the result of a RefOf operation is fatal. Use the CondRefOf term in cases where the Object might not exist.\nThe primary purpose of RefOf() is to allow an object to be passed to a method as an argument to the method without the object being evaluated at the time the method was loaded.",
    "example": ""
  },
  {
    "title": "Register (Generic Register Resource Descriptor Macro)",
    "syntax": "Register (AddressSpaceKeyword, RegisterBitWidth, RegisterBitOffset, RegisterAddress, AccessSize, DescriptorName)",
    "arguments": "AddressSpaceKeyword specifies the address space where the register exists. The register can be one of the following:\n\u2022       I/O space (SystemIO)\n\u2022       System Memory (SystemMemory)\n\u2022       PCI configuration space (PCI_Config)\n\u2022       Embedded controller space (EmbeddedControl)\n\u2022       SMBus (SMBus)\n\u2022       CMOS (SystemCMOS)\n\u2022       PCI Bar target (PciBarTarget)\n\u2022       IPMI (IPMI)\n\u2022       General purpose I/O (GeneralPurposeIO) \u2022       Generic serial bus (GenericSerialBus)\n\u2022       Platform Communications Channel (PCC)\n\u2022       Fixed-feature hardware (FFixedHW)\nThe 8-bit field DescriptorName. _ASI is automatically created in order to refer to this portion of the resource descriptor. See the Address Space ID definition in Table 6-238 for more information, including a list of valid values and their meanings.\nRegisterBitWidth evaluates to an 8-bit integer that specifies the number of bits in the register. The 8-bit field DescriptorName. _RBW is automatically created in order to refer to this portion of the resource descriptor. See the _RBW definition in Table 6-238 for more information.\nRegisterBitOffset evaluates to an 8-bit integer that specifies the offset in bits from the start of the register indicated by RegisterAddress. The 8-bit field DescriptorName. _RBO is automatically created in order to refer to this portion of the resource descriptor. See the _RBO definition in Table 6-238 for more information.\nRegisterAddress evaluates to a 64-bit integer that specifies the register address. The 64-bit field DescriptorName. _ADR is automatically created in order to refer to this portion of the resource descriptor. See the _ADR definition in Table 6-238 for more information.\nAccessSize evaluates to an 8-bit integer that specifies the size of data values used when accessing the address space as follows:\n0  - Undefined (legacy)\n1  - Byte access\n2  - Word access\n3  - DWord access\n4  - QWord access\nThe 8-bit field DescriptorName. _ASZ is automatically created in order to refer to this portion of the resource descriptor. See the _ASZ definition in Table 6-238 for more information. For backwards compatibility, the AccesSize parameter is optional when invoking the Register macro. If the AccessSize parameter is not supplied then the AccessSize field will be set to zero. In this case, OSPM will assume the access size.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The Register macro evaluates to a buffer that contains a generic register resource descriptor. The format of the generic register resource descriptor can be found in Table 6-238. The macro is designed to be used inside of the ResourceTemplate (Section 19.6.117).",
    "example": ""
  },
  {
    "title": "Release (Release a Mutex Synchronization Object)",
    "syntax": "Release (SyncObject)",
    "arguments": "SynchObject must be a mutex synchronization object.",
    "description": "If the mutex object is owned by the current invocation, ownership for the Mutex is released once. It is fatal to release ownership on a Mutex unless it is currently owned. A Mutex must be totally released before an invocation completes.",
    "example": ""
  },
  {
    "title": "Reset (Reset an Event Synchronization Object)",
    "syntax": "Reset (SyncObject)",
    "arguments": "SynchObject must be an Event synchronization object.",
    "description": "This operator is used to reset an event synchronization object to a non-signaled state. See also the Wait and Signal function operator definitions.",
    "example": ""
  },
  {
    "title": "ResourceTemplate (Resource To Buffer Conversion Macro)",
    "syntax": "ResourceTemplate () {ResourceMacroList} => Buffer",
    "arguments": "",
    "description": "For a full definition of the ResourceTemplateTerm macro, see Section 19.3.3, \u201cASL Resource Templates\u201d.",
    "example": ""
  },
  {
    "title": "Return (Return from Method Execution)",
    "syntax": "Return\nReturn ()\nReturn (Arg)",
    "arguments": "Arg is optional and can be any valid object or reference.",
    "description": "Returns control to the invoking control method, optionally returning a copy of the object named in Arg. If no Arg object is specified, a Return(Zero) is generated by the ASL compiler.\nNote: In the absence of an explicit Return () statement, the return value to the caller is undefined.",
    "example": ""
  },
  {
    "title": "Revision (Constant Revision Integer)",
    "syntax": "Revision => Integer",
    "arguments": "",
    "description": "The Revision operator returns an Integer containing the current revision of the AML interpreter. Writes to this object are not allowed.",
    "example": ""
  },
  {
    "title": "Scope (Open Named Scope)",
    "syntax": "Scope (Location) {ObjectList}",
    "arguments": "Opens and assigns a base namespace scope to a collection of objects. All object names defined within the scope are created relative to Location. Note that Location does not have to be below the surrounding scope, but can refer to any location within the namespace. The Scope term itself does not create objects, but only locates objects within the namespace; the actual objects are created by other ASL terms.",
    "description": "The object referred to by Location must already exist in the namespace and be one of the following object types that has a namespace scope associated with it:\n\u2022       A predefined scope such as: \\ (root), \\_SB, \\GPE, \\_PR, \\_TZ, etc.\n\u2022       Device\n\u2022       Processor\n\u2022       Thermal Zone\n\u2022       Power Resource\nThe Scope term alters the current namespace location to the existing Location. This causes the defined objects within TermList to be created relative to this new location in the namespace.\nThe object list is encoded as TermList, so that rather than describing a static object list, it is possible to describe a dynamic object list according to the system settings. See \"Section 5.4.2, Definition Block Loading.\"\nNote: When creating secondary SSDTs, it is often required to use the Scope operator to change the namespace location in order create objects within some part of the namespace that has been defined by the main DSDT. Use the External operator to declare the scope location so that the ASL compiler will not issue an error for an undefined Location.",
    "example": "The following example ASL code uses the Scope operator and creates several objects:\nScope (\\PCI0)\n{\n    Name (X, 3)\n    Scope (\\)\n    {\n        Method (RQ) {Return (0)}\n    }\n    Name (^Y, 4) }\nThe created objects are placed in the ACPI namespace as shown:\n\\PCI0.X\n\\RQ \\Y\nThis example shows the use of External in conjunction with Scope within an SSDT:\nDefinitionBlock (\"ssdt.aml\", \"SSDT\", 2, \"X\", \"Y\", 0x00000001)\n{\n    External (\\_SB.PCI0, DeviceObj)\n    Scope (\\_SB.PCI0)\n    {     }\n}"
  },
  {
    "title": "ShiftLeft (Integer Shift Left)",
    "syntax": "ShiftLeft (Source, ShiftCount, Result) => Integer\nResult = Source << ShiftCount => Integer\nResult <<= ShiftCount => Integer",
    "arguments": "Source and ShiftCount are evaluated as Integers.",
    "description": "Source is shifted left with the least significant bit zeroed ShiftCount times. The result is optionally stored into Result.",
    "example": ""
  },
  {
    "title": "ShiftRight (Integer Shift Right)",
    "syntax": "ShiftRight (Source, ShiftCount, Result) => Integer\nResult = Source >> ShiftCount => Integer\nResult >>= ShiftCount => Integer",
    "arguments": "Source and ShiftCount are evaluated as Integers.",
    "description": "Source is shifted right with the most significant bit zeroed ShiftCount times. The result is optionally stored into Result.",
    "example": ""
  },
  {
    "title": "Signal (Signal a Synchronization Event)",
    "syntax": "Signal (SyncObject)",
    "arguments": "SynchObject must be an Event synchronization object.",
    "description": "The Event object is signaled once, allowing one invocation to acquire the event.",
    "example": ""
  },
  {
    "title": "SizeOf (Get Data Object Size)",
    "syntax": "SizeOf (ObjectName) => Integer",
    "arguments": "ObjectName must be a buffer, string or package object.",
    "description": "Returns the size of a buffer, string, or package data object.\nFor a buffer, it returns the size in bytes of the data. For a string, it returns the size in bytes of the string, not counting the trailing NULL. For a package, it returns the number of elements. For an object reference, the size of the referenced object is returned. Other data types cause a fatal run-time error.",
    "example": ""
  },
  {
    "title": "Sleep (Milliseconds Sleep)",
    "syntax": "Sleep (MilliSeconds)",
    "arguments": "The Sleep term is used to implement long-term timing requirements. Execution is delayed for at least the required number of milliseconds.",
    "description": "The implementation of Sleep is to round the request up to the closest sleep time supported by the OS and relinquish the processor.",
    "example": ""
  },
  {
    "title": "SPISerialBusV2 (SPI Serial Bus Connection Resource Descriptor (Version 2) Macro)",
    "syntax": "SPISerialBusV2 (DeviceSelection, DeviceSelectionPolarity, WireMode, DataBitLength, SlaveMode,\nConnectionSpeed, ClockPolarity, ClockPhase, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, Shared, VendorData)",
    "arguments": "DeviceSelection is the device selection value. This value may refer to a chip-select line, GPIO line or other line selection mechanism. _ADR is automatically created to refer to this portion of the resource descriptor.\nDeviceSelectionPolarity is an optional argument and can be either PolarityHigh or PolarityLow to indicate that the device is active. PolarityLow is the default. The bit field _DPL is automatically created to refer to this portion of the resource descriptor.\nWireMode is an optional argument and can be either ThreeWireMode or FourWireMode. FourWireMode is the default. The bit field name _MOD is automatically created to refer to this portion of the resource descriptor.\nDataBitLength is the size, in bits, of the smallest transfer unit for this connection. _LEN is automatically created to refer to this portion of the resource descriptor.\nSlaveMode is an optional argument and can be either ControllerInitiated or DeviceInitiated.\nControllerInitiated is the default. The bit field name _SLV is automatically created to refer to this portion of the resource descriptor.\nConnectionSpeed is the maximum connection speed supported by this connection, in hertz. The bit field name _SPE is automatically created to refer to this portion of the resource descriptor.\nClockPolarity can be either ClockPolarityLow or ClockPolarityHigh. _POL is automatically created to refer to this portion of the resource descriptor.\nClockPhase can be either ClockPhaseFirst or ClockPhaseSecond. _PHA is automatically created to refer to this portion of the resource descriptor.\nResourceSource is a string which uniquely identifies the SPI bus controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\nResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.\nResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nShared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\nVendorData is an optional argument that specifies an object to be decoded by the OS driver. It is a RawDataBuffer. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.",
    "description": "The SPISerialBusV2 macro evaluates to a buffer that contains a SPI Serial Bus resource descriptor (Version 2). The macro is designed to be used inside of a ResourceTemplate (see Section 19.3.3).",
    "example": ""
  },
  {
    "title": "Stall (Stall for a Short Time)",
    "syntax": "Stall (MicroSeconds)",
    "arguments": "The Stall term is used to implement short-term timing requirements. Execution is delayed for at least the required number of microseconds.",
    "description": "The implementation of Stall is OS-specific, but must not relinquish control of the processor. Because of this, delays longer than 100 microseconds must use Sleep instead of Stall.",
    "example": ""
  },
  {
    "title": "StartDependentFn (Start Dependent Function Resource Descriptor",
    "syntax": "StartDependentFn (CompatibilityPriority, PerformancePriority) {ResourceList}",
    "arguments": "CompatibilityPriority indicates the relative compatibility of the configuration specified by ResourceList relative to the PC/AT. 0 = Good, 1 = Acceptable, 2 = Sub-optimal.\nPerformancePriority indicates the relative performance of the configuration specified by ResourceList relative to the other configurations. 0 = Good, 1 = Acceptable, 2 = Sub-optimal.\nResourceList is a list of resources descriptors which must be selected together for this configuration.",
    "description": "The StartDependentFn macro evaluates to a buffer which contains a start dependent function resource descriptor, which describes a group of resources which must be selected together. Each subsequent StartDependentFn or StartDependentFnNoPri resource descriptor introduces a new choice of resources for configuring the device, with the last choice terminated with an EndDependentFn resource descriptor. The format of the start dependent function resource descriptor can be found in \u201cStart Dependent Functions Descriptor\u201d (page 420). This macro generates the two-byte form of the resource descriptor. The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "StartDependentFnNoPri (Start Dependent Function Resource Descriptor Macro)",
    "syntax": "StartDependentFnNoPri () {ResourceList}",
    "arguments": "",
    "description": "The StartDependentFnNoPri macro evaluates to a buffer which contains a start dependent function resource descriptor, which describes a group of resources which must be selected together. Each subsequent StartDependentFn or StartDependentFnNoPri resource descriptor introduces a new choice of resources for configuring the device, with the last choice terminated with an EndDependentFn resource descriptor. The format of the start dependent function resource descriptor can be found in \u201cStart Dependent Functions Descriptor\u201d (page 421). This macro generates the one-byte form of the resource descriptor. The macro is designed to be used inside of a ResourceTemplate (page 1033).\nThis is similar to StartDependentFn (page 1038) with both CompatibilityPriority and PerformancePriority set to 1, but is one byte shorter.",
    "example": ""
  },
  {
    "title": "Store (Store an Object)",
    "syntax": "Store (Source, Destination) => DataRefObject\nDestination = Source => DataRefObject",
    "arguments": "This operation evaluates Source, converts it to the data type of Destination, and writes the result into\nDestination. For information on automatic data-type conversion, see Section 19.3.5, \u201cASL Data Types.\u201d",
    "description": "Stores to OperationRegion Field data types may relinquish the processor depending on the address space.\nAll stores (of any type) to the constant Zero, constant One, or constant Ones object are not allowed. Stores to read-only objects are fatal. The execution result of the operation depends on the type of Destination. For any type other than an operation region field, the execution result is the same as the data written to Destination. For operation region fields with an AccessType of ByteAcc, WordAcc,\nDWordAcc, QWordAcc or AnyAcc, the execution result is the same as the data written to Destination as in the normal case, but when the AccessType is BufferAcc, the operation region handler may modify the data when it is written to the Destination so that the execution result contains modified data.",
    "example": "The following example creates the name CNT that references an integer data object with the value 5 and then stores CNT to Local0. After the Store operation, Local0 is an integer object with the value 5.\nName (CNT, 5)\nStore (CNT, Local0)"
  },
  {
    "title": "Subtract (Integer Subtract)",
    "syntax": "Subtract (Minuend, Subtrahend, Result) => Integer\nResult = Minuend - Subtrahend => Integer\nResult -= Subtrahend => Integer",
    "arguments": "Minuend and Subtrahend are evaluated as Integers.",
    "description": "Subtrahend is subtracted from Minuend, and the result is optionally stored into Result. Underflow conditions are ignored and the result simply loses the most significant bits.",
    "example": ""
  },
  {
    "title": "Switch (Select Code To Execute Based On Expression)",
    "syntax": "Switch (Expression) {CaseTermList}",
    "arguments": "Expression is an ASL expression that evaluates to an Integer, String or Buffer.",
    "description": "The Switch, Case and Default statements help simplify the creation of conditional and branching code. The Switch statement transfers control to a statement within the enclosed body of executable ASL code\nIf the Case Value is an Integer, Buffer or String, then control passes to the statement that matches the value of Switch (Expression). If the Case value is a Package, then control passes if any member of the package matches the Switch (Value) The Switch CaseTermList can include any number of Case instances, but no two Case Values (or members of a Value, if Value is a Package) within the same Switch statement can have the same value.\nExecution of the statement body begins at the selected TermList and proceeds until the TermList end of body or until a Break or Continue statement transfers control out of the body.\nThe Default statement is executed if no Case Value matches the value of Switch (expression). If the Default statement is omitted, and no Case match is found, none of the statements in the Switch body are executed. There can be at most one Default statement. The Default statement can appear anywhere in the body of the Switch statement.\nA Case or Default term can only appear inside a Switch statement. Switch statements can be nested. (Compatibility Note) The Switch, Case, and Default terms were first introduced in ACPI 2.0. However, their implementation is backward compatible with ACPI 1.0 AML interpreters.",
    "example": "Use of the Switch statement usually looks something like this:\nSwitch (expression)\n{\n    Case (value) {\n        Statements executed if Lequal (expression, value)\n    }\n    Case (Package () {value, value, value}) {\n        Statements executed if Lequal (expression, any value in package)\n    }\n    Default {\n        Statements executed if expression does not equal         any case constant-expression\n}\n}\nNote:     (Compiler Note) The following example demonstrates how the Switch statement should be translated into ACPI 1.0-compatible AML:\nSwitch (Add (ABCD( ),1)\n{\n    Case (1) {\n        \u2026statements1\u2026\n    }\n    Case (Package () {4,5,6}) {\n        \u2026statements2\u2026\n    }\n    Default {\n        \u2026statements3\u2026\n    }\n}\nis translated as:\nName (_T_I, 0)                    // Create Integer temporary variable for result While (One)\n{\n    Store (Add (ABCD (), 1), _T_I)\n    If (LEqual (_T_I, 1)) {\n        \u2026statements1\u2026\n    }\n    Else {\n    If (LNotEqual (Match (Package () {4, 5, 6}, MEQ, _T_I, MTR, 0, 0), Ones)) {\n        \u2026statements2\u2026\n    }\n    Else {\n        \u2026statements3\u2026\n    }\n    Break }\nThe While (One) is emitted to enable the use of Break and Continue within the Switch statement. Temporary names emitted by the ASL compiler should appear at the top level of the method, since the Switch statement could appear within a loop and thus attempt to create the name more than once.\nNote: If the ASL compiler is unable to determine the type of the expression, then it will generate a warning and assume a type of Integer. The warning will indicate that the code should use one of the type conversion operators (Such as ToInteger, ToBuffer, ToDecimalString or ToHexString). Caution: Some of these operators are defined starting with ACPI 2.0 and as such may not be supported by ACPI 1.0b compatible interpreters.\nFor example:\nSwitch (ABCD ())    // Cannot determine the type because methods can return anything.\n{\n    \u2026case statements\u2026\n}\nwill generate a warning and the following code:\nName (_T_I, 0)\nStore (ABCD (), _T_I)\nTo remove the warning, the code should be:\nSwitch (ToInteger (ABCD ()))\n{\n    \u2026case statements\u2026\n}"
  },
  {
    "title": "ThermalZone (Declare Thermal Zone)",
    "syntax": "ThermalZone (ThermalZoneName) {TermList}",
    "arguments": "Declares a Thermal Zone object named ThermalZoneName. ThermalZone opens a name scope.\nEach use of a ThermalZone term declares one thermal zone in the system. Each thermal zone in a system is required to have a unique ThermalZoneName.",
    "description": "A thermal zone may be declared in the namespace anywhere within the \\_SB scope. For compatibility with operating systems implementing ACPI 1.0, a thermal zone may also be declared under the \\_TZ scope. An ACPI-compatible namespace may define Thermal Zone objects in either the \\_SB or \\_TZ scope but not both.\nFor example ASL code that uses a ThermalZone statement, see Section 11, \u201cThermal Management.\u201d\nThe thermal object list is encoded as TermList, so that rather than describing a static thermal object list, it is possible to describe a dynamic thermal object list according to the system settings. See \"Section 5.4.2, Definition Block Loading.\"",
    "example": ""
  },
  {
    "title": "Timer (Get 64-Bit Timer Value)",
    "syntax": "Timer => Integer",
    "arguments": "",
    "description": "The timer opcode returns a monotonically increasing value that can be used by ACPI methods to measure time passing, this enables speed optimization by allowing AML code to mark the passage of time independent of OS ACPI interpreter implementation.\nThe Sleep opcode can only indicate waiting for longer than the time specified.\nThe value resulting from this opcode is 64 bits. It is monotonically increasing, but it is not guaranteed that every result will be unique, i.e. two subsequent instructions may return the same value. The only guarantee is that each subsequent evaluation will be greater-than or equal to the previous ones.\nThe period of this timer is 100 nanoseconds. While the underlying hardware may not support this granularity, the interpreter will do the conversion from the actual timer hardware frequency into 100 nanosecond units.\nUsers of this opcode should realize that a value returned only represents the time at which the opcode itself executed. There is no guarantee that the next opcode in the instruction stream will execute in any particular time bound.\nThe OSPM can implement this using the ACPI Timer and keep track of overrun. Other implementations are possible. This provides abstraction away from chipset differences\nNote:     (Compatibility Note) New for ACPI 3.0",
    "example": ""
  },
  {
    "title": "ToBCD (Convert Integer to BCD)",
    "syntax": "ToBCD (Value, Result) => Integer",
    "arguments": "Value is evaluated as an integer",
    "description": "The ToBCD operator is used to convert Value from a numeric (Integer) format to a BCD format and optionally store the numeric value into Result.",
    "example": ""
  },
  {
    "title": "ToBuffer (Convert Data to Buffer)",
    "syntax": "ToBuffer (Data, Result) => Buffer",
    "arguments": "Data must be an Integer, String, or Buffer data type.",
    "description": "Data is converted to buffer type and the result is optionally stored into Result. If Data is an integer, it is converted into n bytes of buffer (where n is 4 if the definition block has defined integers as 32 bits or 8 if the definition block has defined integers as 64 bits as indicated by the Definition Block table header\u2019s Revision field), taking the least significant byte of integer as the first byte of buffer. If Data is a buffer, no conversion is performed. If Data is a string, each ASCII string character is copied to one buffer byte, including the string null terminator. A null (zero-length) string will be converted to a zero-length buffer.",
    "example": ""
  },
  {
    "title": "ToDecimalString (Convert Data to Decimal String)",
    "syntax": "ToDecimalString (Data, Result) => String",
    "arguments": "Data must be an Integer, String, or Buffer data type.",
    "description": "Data is converted to a decimal string, and the result is optionally stored into Result. If Data is already a string, no action is performed. If Data is a buffer, it is converted to a string of decimal values separated by commas. (Each byte of the buffer is converted to a single decimal value.) A zero-length buffer will be converted to a null (zero-length) string.",
    "example": ""
  },
  {
    "title": "ToHexString (Convert Data to Hexadecimal String)",
    "syntax": "ToHexString (Data, Result) => String",
    "arguments": "Data must be an Integer, String, or Buffer data type.",
    "description": "Data is converted to a hexadecimal string, and the result is optionally stored into Result. If Data is already a string, no action is performed. If Data is a buffer, it is converted to a string of hexadecimal values separated by commas. A zero-length buffer will be converted to a null (zero-length) string.",
    "example": ""
  },
  {
    "title": "ToInteger (Convert Data to Integer)",
    "syntax": "ToInteger (Data, Result) => Integer",
    "arguments": "Data must be an Integer, String, or Buffer data type.",
    "description": "Data is converted to integer type and the result is optionally stored into Result. If Data is a string, it must be either a decimal or hexadecimal numeric string (in other words, prefixed by \u201c0x\u201d) and the value must not exceed the maximum of an integer value. If the value is exceeding the maximum, the result of the conversion is unpredictable. A null (zero-length) string is illegal. If Data is a Buffer, the first 8 bytes of the buffer are converted to an integer, taking the first byte as the least significant byte of the integer. A zerolength buffer is illegal. If Data is an integer, no action is performed.",
    "example": ""
  },
  {
    "title": "ToPLD (Creates a _PLD Buffer Object)",
    "syntax": "ToPLD (PLDKeywordList) => _PLD Buffer Object",
    "arguments": "PLDKeywordList is a list of PLDKeyword types that describe elements of a Physical Layer Description (_PLD) buffer that can be assigned values. The table below shows the available PLDKeyword types and their assignable types. Refer to the _PLD section for a description of the _PLD method object.\nTable 19-436 PLD Keywords and Assignment Types\nPLDKeyword\nAssignment Type\nPLD_Revision\nInteger\nPLD_IgnoreColor\nInteger\nPLD_Red\nInteger\nPLD_Green\nInteger\nPLD_Blue\nInteger\nPLD_Width\nInteger\nPLD_Height\nInteger\nPLD_UserVisible\nInteger\nPLD_Dock\nInteger\nPLD_Lid\nInteger\nPLD_Panel\nInteger or String\nPLD_VerticalPosition\nInteger or String\nPLD_HorizontalPosition\nInteger or String\nPLD_Shape\nInteger or String\nPLD_GroupOrientation\nInteger\nPLD_GroupToken\nInteger\nPLD_GroupPosition\nInteger\nPLD_Bay\nInteger\nPLD_Ejectable\nInteger\nPLD_EjectRequired\nInteger\nPLD_CabinetNumber\nInteger\nPLD_CardCageNumber\nInteger\nPLD_Reference\nInteger\nPLD_Rotation\nInteger\nPLDKeyword\nAssignment Type\nPLD_Order\nInteger\nPLD_VeriticalOffset\nInteger\nPLD_HorizontalOffset\nInteger\nA subset of PLDKeyword types can be assigned string values for improved readability. Those types and their assignable values are shown in the table below.\nTable 19-437 PLD Keywords and assignable String Values\nPLDKeyword\nAssignable String Values\nPLD_Panel\n\u201cTOP\u201d, \u201cBOTTOM\u201d,\u201dLEFT\u201d, \u201cRIGHT\u201d,\u201dFRONT\u201d,\u201dBACK\u201d,\u201dUNKNOWN\u201d\nPLD_VerticalPosition\n\u201cUPPER\u201d,\u201dCENTER\u201d,\u201dLOWER\u201d\nPLD_HorizontalPosition\n\u201cLEFT\u201d,\u201dCENTER\u201d,\u201dRIGHT\u201d\nPLD_Shape\n\u201cROUND\u201d,\u201dOVAL\u201d,\u201dSQUARE\u201d,\n\u201cVERTICALRECTANGLE\u201d,\n\u201cHORIZONTALRECTANGLE\u201d,\n\u201cVERTICALTRAPEZOID\u201d,\n\u201cHORIZONTALTRAPEZOID\u201d,\n\u201cUNKNOWN\u201d",
    "description": "The ToPLD macro converts a list of PLDKeyword types into a _PLD buffer object.",
    "example": "The following ASL shows an example using ToPLDto construct a _PLD buffer/package object.\nName (_PLD, Package (0x01)  // _PLD: Physical Location of Device\n    {\n        ToPLD (\n            PLD_Revision           = 0x2,\n            PLD_IgnoreColor        = 0x1,\n            PLD_Red                = 0x37,\n            PLD_Green              = 0x44,\n            PLD_Blue               = 0xFF,             PLD_Width              = 0x4,\n            PLD_Height             = 0x19,\n            PLD_UserVisible        = 0x1,\n            PLD_Dock               = 0x0,\n            PLD_Lid                = 0x1,\n            PLD_Panel              = \"TOP\",\n            PLD_VerticalPosition   = \"CENTER\",\n            PLD_HorizontalPosition = \"RIGHT\",\n            PLD_Shape              = \"VERTICALRECTANGLE\",\n            PLD_GroupOrientation   = 0x1,\n            PLD_GroupToken         = 0xA,\n            PLD_GroupPosition      = 0x21,\n            PLD_Bay                = 0x1,\n            PLD_Ejectable          = 0x0,\n            PLD_EjectRequired      = 0x1,\n            PLD_CabinetNumber      = 0x1E,\n            PLD_CardCageNumber     = 0x17,\n            PLD_Reference          = 0x0,\n            PLD_Rotation           = 0x7,\n            PLD_Order              = 0x3,\n            PLD_VerticalOffset     = 0x141,\n            PLD_HorizontalOffset   = 0x2C)     })"
  },
  {
    "title": "ToString (Convert Buffer To String)",
    "syntax": "ToString (Source, Length, Result) => String",
    "arguments": "Source is evaluated as a buffer. Length is evaluated as an integer data type.",
    "description": "Starting with the first byte, the contents of the buffer are copied into the string until the number of characters specified by Length is reached or a null (0) character is found. If Length is not specified or is Ones, then the contents of the buffer are copied until a null (0) character is found. If the source buffer has a length of zero, a zero length (null terminator only) string will be created. The result is copied into the Result.",
    "example": ""
  },
  {
    "title": "ToUUID (Convert String to UUID Macro)",
    "syntax": "ToUUID (AsciiString) => Buffer",
    "arguments": "AsciiString is evaluated as a String data type.",
    "description": "This macro will convert an ASCII string to a 128-bit buffer. The string must have the following format:\naabbccdd-eeff-gghh-iijj-kkllmmnnoopp\nwhere aa pp are one byte hexadecimal numbers, made up of hexadecimal digits. The resulting buffer has the following format:\nTable 19-438 UUID Buffer Format\nString\nOffset In Buffer\naa\n3\nbb\n2\ncc\n1\ndd\n0\nee\n5\nff\n4\ngg\n7\nhh\n6\nii\n8\njj\n9\nkk\n10\nll\n11\nmm\n12\nnn\n13\noo\n14\npp\n15\nNote:     (Compatibility Note) New for ACPI 3.0",
    "example": ""
  },
  {
    "title": "UARTSerialBusV2 (UART Serial Bus Connection Resource Descriptor (Version 2) Macro)",
    "syntax": "UARTSerialBusV2 (InitialBaudRate, BitsPerByte, StopBits, LinesInUse, IsBigEndian, Parity, FlowControl,\nReceiveBufferSize, TransmitBufferSize, ResourceSource, ResourceSourceIndex, ResourceUsage, DescriptorName, Shared, VendorData)",
    "arguments": "InitialBaudRate evaluates to a 32-bit integer that specifies the default or initial connection speed in bytes per second that the device supports. The bit field _SPE is automatically created to refer to this portion of the resource descriptor.\nBitsPerByte is an optional argument that specifies whether five bits (DataBitsFive), six bits (DataBitsSix), seven bits (DataBitsSeven), eight bits (DataBitsEight) or nine bits (DataBitsNine) contain data during transfer of a single packet or character. DataBitsEight is the default. The bit field DescriptorName._LEN is automatically created to refer to this portion of the resource descriptor.\nStopBits is an optional argument that specifies whether there are two bits (StopBitsTwo), one and a half bits (StopBitsOnePlusHalf), one bit (StopBitsOne) or no bits (StopBitsZero) used to signal the end of a packet or character. StopBitsOne is the default. The bit field _STB is automatically created to refer to this portion of the resource descriptor.\nLinesInUse evaluates to an integer representing 8 1-bit flags representing the presence (\u20181\u2019) or absence (\u20180\u2019) of a particular line. The bit field _LIN is automatically created to refer to this portion of the resource descriptor.\nBit Mask\nUART Line\nBit 7 (0x80)\nRequest To Send (RTS)\nBit 6 (0x40)\nClear To Send (CTS)\nBit 5 (0x20)\nData Terminal Ready (DTR)\nBit 4 (0x10)\nData Set Ready (DSR)\nBit 3 (0x08)\nRing Indicator (RI)\nBit 2 (0x04)\nData Carrier Detect (DTD)\nBit 1 (0x02)\nReserved. Must be 0.\nBit 0 (0x01)\nReserved. Must be 0.\nIsBigEndian is an optional argument that specifies whether the device is expecting big endian (BigEndian) or little endian (LittleEndian) data formats. LittleEndian is the default. The bit field _END is automatically created to refer to this portion of the resource descriptor.\nParity is an optional argument that specifies whether the type of parity bits included after the data in a packet are to be interpreted as space parity (ParityTypeSpace), mark parity (ParityTypeMark), odd parity (ParityTypeOdd), even parity (ParityTypeEven) or no parity (ParityTypeNone). ParityTypeNone is the default. The bit field PAR is automatically created to refer to this portion of the resource descriptor.\nFlowControl is an optional argument that specifies whether there is hardware-based flow control\n(FlowControlHardware), software-based flow control (FlowControlXON) or no flow control\n(FlowControlNone) used when communicating with the device. FlowControlNone is the default. The bit field_FLC is automatically created to refer to this portion of the resource descriptor.\nReceiveBufferSize evaluates to a 16-bit integer that specifies the upper limit in bytes of the receive buffer that can be optimally utilized while communicating with this device. The bit field_RXL is automatically created to refer to this portion of the resource descriptor.\nTransmitBufferSize evaluates to a 16-bit integer that specifies the upper limit in bytes of the transmit buffer that can be optimally utilized while communicating with this device. The bit field _TXL is automatically created to refer to this portion of the resource descriptor.\nResourceSource is a string which uniquely identifies the UART bus controller referred to by this descriptor. ResourceSource can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search rules.\nResourceSourceIndex is an optional argument and is assumed to be 0 for this revision.\nResourceUsage is an optional argument and is assumed to be ResourceConsumer for this revision.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nShared is an optional argument and can be either Shared or Exclusive. If not specified, Exclusive is assumed. The bit field name _SHR is automatically created to refer to this portion of the resource descriptor.\nVendorData is an optional argument that specifies an object to be decoded by the OS driver. It is a RawDataBuffer. The bit field name _VEN is automatically created to refer to this portion of the resource descriptor.",
    "description": "The UARTSerialBusV2 macro evaluates to a buffer that contains a UART Serial Bus resource descriptor (Version 2). The macro is designed to be used inside of a ResourceTemplate (seeSection 19.3.3 ).",
    "example": ""
  },
  {
    "title": "Unicode (String To Unicode Conversion Macro)",
    "syntax": "Unicode (String) => Buffer",
    "arguments": "This macro will convert a string to a Unicode (UTF-16) string contained in a buffer. The format of the Unicode string is 16 bits per character, with a 16-bit null terminator.",
    "description": "",
    "example": ""
  },
  {
    "title": "VendorLong (Long Vendor Resource Descriptor)",
    "syntax": "VendorLong (DescriptorName) {VendorByteList}",
    "arguments": "DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer.\nVendorByteList evaluates to a comma-separated list of 8-bit integer constants, where each byte is added verbatim to the body of the VendorLong resource descriptor. A maximum of n bytes can be specified. UUID and UUID specific descriptor subtype are part of the VendorByteList.",
    "description": "The VendorLong macro evaluates to a buffer which contains a vendor-defined resource descriptor. The format of the long form of the vendor-defined resource descriptor can be found in Vendor-Defined Descriptor  (page 424). The macro is designed to be used inside of a ResourceTemplate (page 1033).\nThis is similar to VendorShort (page 1051), except that the number of allowed bytes in VendorByteList is 65,533 (instead of 7).",
    "example": ""
  },
  {
    "title": "Unload (Unload Definition Block)[DEPRECATED]",
    "syntax": "Unload (Handle)",
    "arguments": "Handle is evaluated as a DDBHandle data type.",
    "description": "Performs a run-time unload of a Definition Block that was loaded using a Load term or LoadTable term. Loading or unloading a Definition Block is a synchronous operation, and no control method execution occurs during the function. On completion of the Unload operation, the Definition Block has been unloaded (all the namespace objects created as a result of the corresponding Load operation will be removed from the namespace).",
    "example": ""
  },
  {
    "title": "VendorShort (Short Vendor Resource Descriptor)",
    "syntax": "VendorShort (DescriptorName) {VendorByteList}",
    "arguments": "DescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer.",
    "description": "The VendorShort macro evaluates to a buffer which contains a vendor-defined resource descriptor. The format of the short form of the vendor-defined resource descriptor can be found in \u201cVendor-Defined Descriptor\u201d (page 424). The macro is designed to be used inside of a ResourceTemplate (page 1033).\nThis is similar to VendorLong (page 1050), except that the number of allowed bytes in VendorByteList is 7 (instead of 65,533).",
    "example": ""
  },
  {
    "title": "Wait (Wait for a Synchronization Event)",
    "syntax": "Wait (SyncObject, TimeoutValue) => Boolean",
    "arguments": "SynchObject must be an event synchronization object. TimeoutValue is evaluated as an Integer. The calling method blocks while waiting for the event to be signaled.",
    "description": "The pending signal count is decremented. If there is no pending signal count, the processor is relinquished until a signal count is posted to the Event or until at least TimeoutValue milliseconds have elapsed.\nThis operation returns a non-zero value if a timeout occurred and a signal was not acquired. A TimeoutValue of 0xFFFF (or greater) indicates that there is no time out and the operation will wait indefinitely.",
    "example": ""
  },
  {
    "title": "While (Conditional Loop)",
    "syntax": "While (Predicate) {TermList}",
    "arguments": "Predicate is evaluated as an integer.",
    "description": "If the Predicate is non-zero, the list of terms in TermList is executed. The operation repeats until the Predicate evaluates to zero.\nNote:     Creation of a named object more than once in a given scope is not allowed. As such, unconditionally creating named objects within a While loop must be avoided. A fatal error will be generated on the second iteration of the loop, during the attempt to create the same named object a second time.",
    "example": ""
  },
  {
    "title": "WordBusNumber (Word Bus Number Resource Descriptor Macro)",
    "syntax": "WordBusNumber (ResourceUsage, IsMinFixed, IsMaxFixed, Decode, AddressGranularity,\nAddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName)",
    "arguments": "ResourceUsage specifies whether the bus range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nIsMinFixed specifies whether the minimum address of this bus number range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this bus number range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nDecode specifies whether or not the device decodes the bus number range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nAddressGranularity evaluates to a 16-bit integer that specifies the power-of-two boundary (- 1) on which the bus number range must be aligned. The 16-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 16-bit integer that specifies the lowest possible bus number for the bus number range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 16-bit integer that specifies the highest possible bus number for the bus number range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 16-bit integer that specifies the offset to be added to a secondary bus bus number which results in the corresponding primary bus bus number. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 16-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 16-bit integer that specifies the total number of bus numbers decoded in the bus number range. The 16-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The WordBusNumber macro evaluates to a buffer which contains a 16-bit bus-number resource descriptor. The format of the 16-bit bus number resource descriptor can be found in \u201cWord Address Space Descriptor \u201d (page 437). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "WordIO (Word IO Resource Descriptor Macro)",
    "syntax": "WordIO (ResourceUsage, IsMinFixed, IsMaxFixed, Decode, ISARanges, AddressGranularity,\nAddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex,\nResourceSource, DescriptorName, TranslationType, TranslationDensity)",
    "arguments": "ResourceUsage specifies whether the I/O range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nIsMinFixed specifies whether the minimum address of this I/O range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field\nDescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this I/O range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field\nDescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nDecode specifies whether or not the device decodes the I/O range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nISARanges specifies whether the I/O ranges specifies are limited to valid ISA I/O ranges (ISAOnly), valid non-ISA I/O ranges (NonISAOnly) or encompass the whole range without limitation (EntireRange). The 2bit field DescriptorName._RNG is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is NonISAOnly, \u20182\u2019 is ISAOnly and \u20180\u2019 is EntireRange.\nAddressGranularity evaluates to a 16-bit integer that specifies the power-of-two boundary (- 1) on which the I/O range must be aligned. The 16-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 16-bit integer that specifies the lowest possible base address of the I/O range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 16-bit integer that specifies the highest possible base address of the I/O range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 16-bit integer that specifies the offset to be added to a secondary bus I/O address which results in the corresponding primary bus I/O address. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 16-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 16-bit integer that specifies the total number of bytes decoded in the I/O range. The 16-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.\nTranslationType is an optional argument that specifies whether the resource type on the secondary side of the bus is different (TypeTranslation) from that on the primary side of the bus or the same\n(TypeStatic). If TypeTranslation is specified, then the primary side of the bus is Memory. If TypeStatic is specified, then the primary side of the bus is I/O. If nothing is specified, then TypeStatic is assumed. The 1-bit field DescriptorName. _TTP is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is TypeTranslation and \u20180\u2019 is TypeStatic. See _TTP (page 444) for more information\nTranslationDensity is an optional argument that specifies whether or not the translation from the primary to secondary bus is sparse (SparseTranslation) or dense (DenseTranslation). It is only used when TranslationType is TypeTranslation. If nothing is specified, then DenseTranslation is assumed. The 1-bit field DescriptorName. _TRS is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SparseTranslation and \u20180\u2019 is DenseTranslation. See _TRS (page 444) for more information.",
    "description": "The WordIO macro evaluates to a buffer which contains a 16-bit I/O range resource descriptor. The format of the 16-bit I/O range resource descriptor can be found in \u201cWord Address Space Descriptor \u201d (page 437). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "WordSpace (Word Space Resource Descriptor Macro) )",
    "syntax": "WordSpace (ResourceType, ResourceUsage, Decode, IsMinFixed, IsMaxFixed, TypeSpecificFlags,\nAddressGranularity, AddressMinimum, AddressMaximum, AddressTranslation, RangeLength, ResourceSourceIndex, ResourceSource, DescriptorName)",
    "arguments": "ResourceType evaluates to an 8-bit integer that specifies the type of this resource. Acceptable values are 0xC0 through 0xFF.\nResourceUsage specifies whether the bus range is consumed by this device (ResourceConsumer) or passed on to child devices (ResourceProducer). If nothing is specified, then ResourceConsumer is assumed.\nDecode specifies whether or not the device decodes the bus number range using positive (PosDecode) or subtractive (SubDecode) decode. If nothing is specified, then PosDecode is assumed. The 1-bit field DescriptorName. _DEC is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is SubDecode and \u20180\u2019 is PosDecode.\nIsMinFixed specifies whether the minimum address of this bus number range is fixed (MinFixed) or can be changed (MinNotFixed). If nothing is specified, then MinNotFixed is assumed. The 1-bit field DescriptorName. _MIF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MinFixed and \u20180\u2019 is MinNotFixed.\nIsMaxFixed specifies whether the maximum address of this bus number range is fixed (MaxFixed) or can be changed (MaxNotFixed). If nothing is specified, then MaxNotFixed is assumed. The 1-bit field DescriptorName. _MAF is automatically created to refer to this portion of the resource descriptor, where \u20181\u2019 is MaxFixed and \u20180\u2019 is MaxNotFixed.\nTypeSpecificFlags evaluates to an 8-bit integer. The flags are specific to the ResourceType.\nAddressGranularity evaluates to a 16-bit integer that specifies the power-of-two boundary (- 1) on which the bus number range must be aligned. The 16-bit field DescriptorName. _GRA is automatically created to refer to this portion of the resource descriptor.\nAddressMinimum evaluates to a 16-bit integer that specifies the lowest possible bus number for the bus number range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MIN is automatically created to refer to this portion of the resource descriptor.\nAddressMaximum evaluates to a 16-bit integer that specifies the highest possible bus number for the bus number range. The value must have \u20180\u2019 in all bits where the corresponding bit in AddressGranularity is \u20181\u2019. For bridge devices which translate addresses, this is the address on the secondary bus. The 16-bit field DescriptorName._MAX is automatically created to refer to this portion of the resource descriptor.\nAddressTranslation evaluates to a 16-bit integer that specifies the offset to be added to a secondary bus bus number which results in the corresponding primary bus bus number. For all non-bridge devices or bridges which do not perform translation, this must be \u20180\u2019. The 16-bit field DescriptorName._TRA is automatically created to refer to this portion of the resource descriptor.\nRangeLength evaluates to a 16-bit integer that specifies the total number of bus numbers decoded in the bus number range. The 16-bit field DescriptorName. _LEN is automatically created to refer to this portion of the resource descriptor.\nResourceSourceIndex is an optional argument which evaluates to an 8-bit integer that specifies the resource descriptor within the object specified by ResourceSource. If this argument is specified, the ResourceSource argument must also be specified.\nResourceSource is an optional argument which evaluates to a string containing the path of a device which produces the pool of resources from which this I/O range is allocated. If this argument is specified, but the ResourceSourceIndex argument is not specified, a zero value is assumed.\nDescriptorName is an optional argument that specifies a name for an integer constant that will be created in the current scope that contains the offset of this resource descriptor within the current resource template buffer. The predefined descriptor field names may be appended to this name to access individual fields within the descriptor via the Buffer Field operators.",
    "description": "The WordSpace macro evaluates to a buffer which contains a 16-bit Address Space resource descriptor. The format of the 16-bit Address Space resource descriptor can be found in \u201cWord Address Space\nDescriptor \u201d (page 437). The macro is designed to be used inside of a ResourceTemplate (page 1033).",
    "example": ""
  },
  {
    "title": "XOr (Integer Bitwise Xor)",
    "syntax": "XOr (Source1, Source2, Result) => Integer\nResult = Source1 ^ Source2 => Integer\nResult ^= Source => Integer",
    "arguments": "Source1 and Source2 are evaluated as Integers.",
    "description": "A bitwise XOR is performed and the result is optionally stored into Result.",
    "example": ""
  },
  {
    "title": "_CDM (Clock Domain)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object conveys the processor clock domain to which a processor belongs. A processor clock domain is a unique identifier representing the hardware clock source providing the input clock for a given set of processors. This clock source drives software accessible internal counters, such as the Time Stamp Counter, in each processor. Processor counters in the same clock domain are driven by the same hardware clock source. In multi-processor platforms that utilize multiple clock domains, such counters may exhibit drift when compared against processor counters on different clock domains.\nThe _CDM object evaluates to an integer that identifies the device as belonging to a specific clock domain. OSPM assumes that two devices in the same clock domain are connected to the same hardware clock.",
    "example": ""
  },
  {
    "title": "_CRS (Current Resource Settings)",
    "syntax": "",
    "arguments": "",
    "description": "This required object evaluates to a byte stream that describes the system resources currently allocated to a device. Additionally, a bus device must supply the resources that it decodes and can assign to its children devices. If a device is disabled, then _CRS returns a valid resource template for the device, but the actual resource assignments in the return byte stream are ignored. If the device is disabled when _CRS is called, it must remain disabled.\nThe format of the data contained in a _CRS object follows the formats defined in Section 6.4 \u201cResource\nData Types for ACPI,\u201d a compatible extension of the formats specified in the PNPBIOS specification.[7] The resource data is provided as a series of data structures, with each of the resource data structures having a unique tag or identifier. The resource descriptor data structures specify the standard PC system resources, such as memory address ranges, I/O ports, interrupts, and DMA channels.",
    "example": ""
  },
  {
    "title": "_DIS (Disable)",
    "syntax": "",
    "arguments": "",
    "description": "This control method disables a device. When the device is disabled, it must not be decoding any hardware resources. Prior to running this control method, OSPM will have already put the device in the D3 state.\nWhen a device is disabled via the _DIS, the _STA control method for this device must return with the Disabled bit set.",
    "example": ""
  },
  {
    "title": "_DMA (Direct Memory Access)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object returns a byte stream in the same format as a _CRS object. _DMA is only defined under devices that represent buses. It specifies the ranges the bus controller (bridge) decodes on the child-side of its interface. (This is analogous to the _CRS object, which describes the resources that the bus controller decodes on the parent-side of its interface.) Any ranges described in the resources of a _DMA object can be used by child devices for DMA or bus master transactions.\nThe _DMA object is only valid if a _CRS object is also defined. OSPM must re-evaluate the _DMA object after an _SRS object has been executed because the _DMA ranges resources may change depending on how the bridge has been configured.\nIf the _DMA object is not present for a bus device, the OS assumes that any address placed on a bus by a child device will be decoded either by a device on the bus or by the bus itself, (in other words, all address ranges can be used for DMA).\nFor example, if a platform implements a PCI bus that cannot access all of physical memory, it has a _DMA object under that PCI bus that describes the ranges of physical memory that can be accessed by devices on that bus.\nA _DMA object is not meant to describe any \u201cmap register\u201d hardware that is set up for each DMA transaction. It is meant only to describe the DMA properties of a bus that cannot be changed without reevaluating the _SRS method.",
    "example": ""
  },
  {
    "title": "_DSD (Device Specific Data)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object is used to provide device drivers (via OSPM) with additional device properties and information. _DSD returns a variable-length package containing a list of Device Data Descriptor structures each consisting of a UUID (see Section 5.2.4) and a package (Data Structure). The UUID is all that is needed to define the Data Structure. The UUID itself may place a restriction based on _HID or the optional _CID, _CLS, _HRV, _SUB objects, or _HID and one of those optional objects. However, it also may not place such a restriction.\nNew UUIDs may be created by OEMs and IHVs or other interface or device governing bodies (e.g. the PCI SIG or the UEFI Forum), as long as the UUID is different from other published UUIDs.\nThe list of well-known UUIDs allocated for _DSD and the definition of data formats associated with them is available in an auxiliary document hosted on the UEFI Forum: http://www.uefi.org/acpi.",
    "example": ""
  },
  {
    "title": "_FIX (Fixed Register Resource Provider)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object is used to provide a correlation between the fixed-hardware register blocks defined in the FADT and the devices in the ACPI namespace that implement these fixed-hardware registers. This object evaluates to a package of Plug and Play-compatible IDs (32-bit compressed EISA type IDs) that correlate to the fixed-hardware register blocks defined in the FADT. The device under which _FIX appears plays a role in the implementation of the fixed-hardware (for example, implements the hardware or decodes the hardware\u2019s address). _FIX conveys to OSPM whether a given device can be disabled, powered off, or should be treated specially by conveying its role in the implementation of the ACPI fixedhardware register interfaces. This object takes no arguments.\nThe _CRS object describes a device\u2019s resources. That _CRS object may contain a superset of the resources in the FADT, as the device may actually decode resources beyond what the FADT requires. Furthermore, in a machine that performs translation of resources within I/O bridges, the processor-relative resources in the FADT may not be the same as the bus-relative resources in the _CRS.",
    "example": ""
  },
  {
    "title": "_GSB (Global System Interrupt Base)",
    "syntax": "",
    "arguments": "",
    "description": "_GSB is an optional object that evaluates to an integer that corresponds to the Global System Interrupt\nBase for the corresponding I/O APIC device. The I/O APIC device may either be bus enumerated (e.g. as a PCI device) or enumerated in the namespace as described in Section 9.17,\u201dI/O APIC Device\u201d. Any I/O APIC device that either supports hot-plug or is not described in the MADT must contain a _GSB object.\nIf the I/O APIC device also contains a _MAT object, OSPM evaluates the _GSB object first before evaluating the _MAT object. By providing the Global System Interrupt Base of the I/O APIC, this object enables OSPM to process only the _MAT entries that correspond to the I/O APIC device. See\nSection 6.2.10, \u201c_MAT (Multiple APIC Table Entry)\u201d. Since _MAT is allowed to potentially return all the MADT entries for the entire platform, _GSB is needed in the I/O APIC device scope to enable OSPM to identify the entries that correspond to that device.\nIf an I/O APIC device is activated by a device-specific driver, the physical address used to access the I/O APIC will be exposed by the driver and cannot be determined from the _MAT object. In this case, OSPM cannot use the _MAT object to determine the Global System Interrupt Base corresponding to the I/O APIC device and hence requires the _GSB object.\nThe Global System Interrupt Base is a 64-bit value representing the corresponding I/OAPIC device as defined in Section 5.2.13, \u201cGlobal System Interrupts\u201d.",
    "example": ""
  },
  {
    "title": "_HPP (Hot Plug Parameters)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object evaluates to a package containing the cache-line size, latency timer, SERR enable, and PERR enable values to be used when configuring a PCI device inserted into a hot-plug slot or for performing configuration of a PCI devices not configured by the platform boot firmware at system boot.\nThe object is placed under a PCI bus where this behavior is desired, such as a bus with hot-plug slots. _HPP provided settings apply to all child buses, until another _HPP object is encountered.",
    "example": ""
  },
  {
    "title": "_HPX (Hot Plug Parameter Extensions)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object provides platform-specific information to the OSPM PCI driver component responsible for configuring PCI, PCI-X, or PCI Express Functions. The information conveyed applies to the entire hierarchy downward from the scope containing the _HPX object. If another _HPX object is encountered downstream, the settings conveyed by the lower-level object apply to that scope downward.\nOSPM uses the information returned by _HPX to determine how to configure PCI Functions that are hotplugged into the system, to configure Functions not configured by the platform firmware during initial system boot, and to configure Functions any time they lose configuration space settings (e.g. OSPM issues a Secondary Bus Reset/Function Level Reset or Downstream Port Containment is triggered). The _HPX object is placed within the scope of a PCI-compatible bus where this behavior is desired, such as a bus with hot-plug slots. It returns a single package that contains one or more sub-packages, each containing a single Setting Record. Each such Setting Record contains a Setting Type (INTEGER), a Revision number (INTEGER) and type/revision specific contents.\nThe format of data returned by the _HPX object is extensible. The Setting Type and Revision number determine the format of the Setting Record. OSPM ignores Setting Records of types that it does not understand. A Setting Record with higher Revision number supersedes that with lower revision number, however, the _HPX method can return both together, OSPM shall use the one with highest revision number that it understands. Type 3 records may have multiple records with the same revision or different revision (refer to the Revision field in Table 6-198.  Out of all the Type 3 records, the OSPM shall determine the highest revision number that it understands and use all Type 3 records with that revision.\n_HPX may return multiple types or Record Settings (each setting in a single sub-package.) OSPM is responsible for detecting the type of  Function and for applying the appropriate settings. OSPM is also responsible for detecting the device / port type of the PCI Express Function and applying the appropriate settings provided. For example, the Secondary Uncorrectable Error Severity and Secondary\nUncorrectable Error Mask settings of Type 2 record are only applicable to PCI Express to PCI-X/PCI Bridge whose device / port type is 1000b. Similarly, AER settings are only applicable to hot plug PCI Express devices that support the optional AER capability.",
    "example": ""
  },
  {
    "title": "_MAT (Multiple APIC Table Entry)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object evaluates to a buffer returning data in the format of a series of Multiple APIC Description Table (MADT) APIC Structure entries. This object can appear under an I/O APIC or processor object definition as processors may contain Local APICs. Specific types of MADT entries are meaningful to\n(in other words, is processed by) OSPM when returned via the evaluation of this object as described in Table 5-45. Other entry types returned by the evaluation of _MAT are ignored by OSPM.\nWhen _MAT appears under a Processor object, OSPM uses the ACPI processor ID in the entries returned from the object\u2019s evaluation to identify the entries corresponding to either the ACPI processor ID of the Processor object or the value returned by the _UID object under a Processor device.",
    "example": ""
  },
  {
    "title": "_OSC (Operating System Capabilities)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object is a control method that is used by OSPM to communicate to the platform the feature support or capabilities provided by a device\u2019s driver. This object is a child object of a device and may also exist in the \\_SB scope, where it can be used to convey platform wide OSPM capabilities. When supported, _OSC is invoked by OSPM immediately after placing the device in the D0 power state. Device specific objects are evaluated after _OSC invocation. This allows the values returned from other objects to be predicated on the OSPM feature support / capability information conveyed by _OSC. OSPM may evaluate _OSC multiple times to indicate changes in OSPM capability to the device but this may be precluded by specific device requirements. As such, _OSC usage descriptions in Section 9, \u201cACPI-Defined Devices and Device Specific Objects\u201d, or other governing specifications describe superseding device specific _OSC capabilities and / or preclusions.\n_OSC enables the platform to configure its ACPI namespace representation and object evaluations to match the capabilities of OSPM. This enables legacy operating system support for platforms with new features that make use of new namespace objects that if exposed would not be evaluated when running a legacy OS. _OSC provides the capability to transition the platform to native operating system support of new features and capabilities when available through dynamic namespace reconfiguration. _OSC also allows devices with Compatible IDs to provide superset functionality when controlled by their native (For example, _HID matched) driver as appropriate objects can be exposed accordingly as a result of OSPM\u2019s evaluation of _OSC.",
    "example": ""
  },
  {
    "title": "_PRS (Possible Resource Settings)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object evaluates to a byte stream that describes the possible resource settings for the device. When describing a platform, specify a _PRS for all the configurable devices. Static (nonconfigurable) devices do not specify a _PRS object. The information in this package is used by OSPM to select a conflict-free resource allocation without user intervention. This method must not reference any operation regions that have not been declared available by a _REG method.\nThe format of the data in a _PRS object follows the same format as the _CRS object (for more information, see the _CRS object definition in Section 6.2.2, \u201c_CRS (Current Resource Settings)\u201d).\nIf the device is disabled when _PRS is called, it must remain disabled.",
    "example": ""
  },
  {
    "title": "_PRT (PCI Routing Table)",
    "syntax": "",
    "arguments": "",
    "description": "PCI interrupts are inherently non-hierarchical. PCI interrupt pins are wired to interrupt inputs of the interrupt controllers. The _PRT object provides a mapping from PCI interrupt pins to the interrupt inputs of the interrupt controllers. The _PRT object is required under all PCI root bridges. _PRT evaluates to a package that contains a list of packages, each of which describes the mapping of a PCI interrupt pin.\nAddress\nDWORD\nThe address of the device (uses the same format as _ADR).\nPin\nByte\nThe PCI pin number of the device (0\u2013INTA, 1\u2013INTB, 2\u2013INTC, 3\u2013INTD).\nSource\nNamePath\nOr\nByte\nName of the device that allocates the interrupt to which the above pin is connected. The name can be a fully qualified path, a relative path, or a simple name segment that utilizes the namespace search rules. Note: This field is a NamePath and not a String literal, meaning that it should not be surrounded by quotes. If this field is the integer constant Zero (or a Byte value of 0), then the interrupt is allocated from the global interrupt pool.\nSource Index\nDWORD\nIndex that indicates which resource descriptor in the resource template of the device pointed to in the Source field this interrupt is allocated from. If the Source field is the Byte value zero, then this field is the global system interrupt number to which the pin is connected.\nThere are two ways that _PRT can be used. Typically, the interrupt input that a given PCI interrupt is on is configurable. For example, a given PCI interrupt might be configured for either IRQ 10 or 11 on an 8259 interrupt controller. In this model, each interrupt is represented in the ACPI namespace as a PCI Interrupt Link Device.\nThese objects have _PRS, _CRS, _SRS, and _DIS control methods to allocate the interrupt. Then, OSPM handles the interrupts not as interrupt inputs on the interrupt controller, but as PCI interrupt pins. The driver looks up the device\u2019s pins in the _PRT to determine which device objects allocate the interrupts. To move the PCI interrupt to a different interrupt input on the interrupt controller, OSPM uses _PRS, _CRS, _SRS, and _DIS control methods for the PCI Interrupt Link Device.\nIn the second model, the PCI interrupts are hardwired to specific interrupt inputs on the interrupt controller and are not configurable. In this case, the Source field in _PRT does not reference a device, but instead contains the value zero, and the Source Index field contains the global system interrupt to which the PCI interrupt is hardwired.\n6.Example: Using _PRT to Describe PCI IRQ Routing\nThe following example describes two PCI slots and a PCI video chip. Notice that the interrupts on the two PCI slots are wired differently (barber-poled).\nScope(\\_SB) {\n  Device(LNKA){\n    Name(_HID, EISAID(\"PNP0C0F\"))           // PCI interrupt link\n    Name(_UID, 1)\n    Name(_PRS, ResourceTemplate(){\n      Interrupt(ResourceProducer,\u2026) {10,11}     // IRQs 10,11\n    })\n    Method(_DIS) {\u2026}\n    Method(_CRS) {\u2026}\n    Method(_SRS, 1) {\u2026}\n  }\n  Device(LNKB){\n    Name(_HID, EISAID(\"PNP0C0F\"))           // PCI interrupt link\n    Name(_UID, 2)\n    Name(_PRS, ResourceTemplate(){\n      Interrupt(ResourceProducer,\u2026) {11,12}     // IRQs 11,12\n    })\n    Method(_DIS) {\u2026}\n    Method(_CRS) {\u2026}\n    Method(_SRS, 1) {\u2026}\n  }\n  Device(LNKC){\n    Name(_HID, EISAID(\"PNP0C0F\"))           // PCI interrupt link\n    Name(_UID, 3)\n    Name(_PRS, ResourceTemplate(){\n      Interrupt(ResourceProducer,\u2026) {12,14}     // IRQs 12,14\n    })\n    Method(_DIS) {\u2026}\n    Method(_CRS) {\u2026}\n    Method(_SRS, 1) {\u2026}\n  }\n  Device(LNKD){\n    Name(_HID, EISAID(\"PNP0C0F\"))           // PCI interrupt link\n    Name(_UID, 4)\n    Name(_PRS, ResourceTemplate(){\n      Interrupt(ResourceProducer,\u2026) {10,15}     // IRQs 10,15\n    })\n    Method(_DIS) {\u2026}\n    Method(_CRS) {\u2026}\n    Method(_SRS, 1) {\u2026}\n  }\n  Device(PCI0){\n    \u2026\n    Name(_PRT, Package{    // A fully qualified pathname can be used,\n                           // or a simple name segment utilizing the search rules.\n      Package{0x0004FFFF, 0, \\_SB_.LNKA, 0},  // Slot 1, INTA\n      Package{0x0004FFFF, 1, \\_SB_.LNKB, 0},  // Slot 1, INTB \n      Package{0x0004FFFF, 2, \\_SB_.LNKC, 0},  // Slot 1, INTC        Package{0x0004FFFF, 3, \\_SB_.LNKD, 0},  // Slot 1, INTD\n      Package{0x0005FFFF, 0, LNKB, 0},        // Slot 2, INTA \n      Package{0x0005FFFF, 1, LNKC, 0},        // Slot 2, INTB \n      Package{0x0005FFFF, 2, LNKD, 0},        // Slot 2, INTC \n      Package{0x0005FFFF, 3, LNKA, 0},        // Slot 2, INTD \n      Package{0x0006FFFF, 0, LNKC, 0}         // Video, INTA\n    })\n  }\n}",
    "example": ""
  },
  {
    "title": "_PXM (Proximity)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object is used to describe proximity domain associations within a machine. _PXM evaluates to an integer that identifies a device as belonging to a Proximity Domain defined in the System Resource Affinity Table (SRAT). OSPM assumes that two devices in the same proximity domain are tightly coupled. OSPM could choose to optimize its behavior based on this. For example, in a system with four processors and six memory devices, there might be two separate proximity domains (0 and 1), each with two processors and three memory devices. In this case, the OS may decide to run some software threads on the processors in proximity domain 0 and others on the processors in proximity domain 1. Furthermore, for performance reasons, it could choose to allocate memory for those threads from the memory devices inside the proximity domain common to the processor and the memory device rather than from a memory device outside of the processor\u2019s proximity domain.\nChildren of a device belong to the same proximity domain as their parent unless they contain an overriding _PXM. Proximity domains do not imply any ejection relationships.\nOSPM shall make no assumptions about the proximity or nearness of different proximity domains. The difference between two integers representing separate proximity domains does not imply distance between the proximity domains (in other words, proximity domain 1 is not assumed to be closer to proximity domain 0 than proximity domain 6).\nIf the Local APIC ID / Local SAPIC ID / Local x2APIC ID or the GICC ACPI Processor UID of a dynamically added processor is not present in the System Resource Affinity Table (SRAT), a _PXM object must exist for the processor\u2019s device or one of its ancestors in the ACPI Namespace. See Section 5.2.16, \u201cSystem Resource Affinity Table (SRAT)\u201d and Section 6.2.14, \u201c_PXM (Proximity)\u201d for more information.",
    "example": ""
  },
  {
    "title": "_SLI (System Locality Information)",
    "syntax": "",
    "arguments": "",
    "description": "The System Locality Information Table (SLIT) table defined in Section 5.2.16.6, \u201cSystem Locality Distance Information Table (SLIT)\u201d provides relative distance information between all System Localities for use during OS initialization.\nThe value of each Entry[i,j] in the SLIT table, where i represents a row of a matrix and j represents a column of a matrix, indicates the relative distances from System Locality / Proximity Domain i to every other System Locality j in the system (including itself).\nThe i,j row and column values correlate to the value returned by the _PXM object in the ACPI namespace. See Section 6.2.14, \u201c_PXM (Proximity)\u201d for more information.\nDynamic runtime reconfiguration of the system may cause the distance between System Localities to change.\n_SLI is an optional object that enables the platform to provide the OS with updated relative System Locality distance information at runtime. _SLI provide OSPM with an update of the relative distance from System Locality i to all other System Localities in the system.\nHeader\n \n \n \n  Signature\n4\n0\n\u2018SLIT\u2019.\n  Length\n4\n4\n60\n  Revision\n1\n8\n1\n  Checksum\n1\n9\nEntire table must sum to zero.\n  OEMID\n6\n10\nOEM ID.\n  OEM Table ID\n8\n16\nFor the System Locality Information Table, the table ID is the manufacturer model ID.\n  OEM Revision\n4\n24\nOEM revision of System Locality Information Table for supplied OEM Table ID.\n  Creator ID\n4\n28\nVendor ID of utility that created the table. For the DSDT, RSDT, SSDT, and PSDT tables, this is the ID for the ASL Compiler.\n  Creator Revision\n4\n32\nRevision of utility that created the table. For the DSDT, RSDT, SSDT, and PSDT tables, this is the revision for the ASL Compiler.\nNumber of System\nLocalities\n8\n36\n4\nEntry[0][0]\n1\n44\n10\nEntry[0][1]\n1\n45\n15\nEntry[0][2]\n1\n46\n20\nField\nByte\nLength\nByte Offset\nEntry[0][3]\n1\n47\n18\nEntry[1][0]\n1\n48\n15\nEntry[1][1]\n1\n49\n10\nEntry[1][2]\n1\n50\n16\nEntry[1][3]\n1\n51\n24\nEntry[2][0]\n1\n52\n20\nEntry[2][1]\n1\n53\n16\nEntry[2][2]\n1\n54\n10\nEntry[2][3]\n1\n55\n12\nEntry[3][0]\n1\n56\n18\nEntry[3][1]\n1\n57\n24\nEntry[3][2]\n1\n58\n12\nEntry[3][3]\n1\n59\n10\nIf a new node, \u201cNode 4\u201d, is added, then Table 6-204 represents the updated system\u2019s NUMA relative distances of proximity domains.\nTable 6-204 Example Relative Distances Between Proximity Domains - 5 Node\nProximity Domain\n0\n1\n2\n3\n4\n0\n10\n15\n20\n18\n17\n1\n15\n10\n16\n24\n21\n2\n20\n16\n10\n12\n14\n3\n18\n24\n12\n10\n23\n4\n17\n21\n14\n23\n10\nThe new node\u2019s _SLI object would evaluate to a buffer containing [17,21,14,23,10,17,21,14,23,10].\nNote:     Some systems support interleave memory across the nodes. The SLIT representation of these systems is implementation specific.",
    "example": ""
  },
  {
    "title": "_SRS (Set Resource Settings)",
    "syntax": "",
    "arguments": "",
    "description": "This optional control method takes one byte stream argument that specifies a new resource allocation for a device. The resource descriptors in the byte stream argument must be specified exactly as listed in the _CRS byte stream meaning that the identical resource descriptors must appear in the identical order, resulting in a buffer of exactly the same length. Optimizations such as changing an IRQ descriptor to an IRQNoFlags descriptor (or vice-versa) must not be performed. Similarly, changing\nStartDependentFn to StartDependentFnNoPri is not allowed. A _CRS object can be used as a template to ensure that the descriptors are in the correct format. For more information, see the _CRS object definition.\nThe settings must take effect before the _SRS control method returns.\nThis method must not reference any operation regions that have not been declared available by a _REG method.\nIf the device is disabled, _SRS enables the device at the specified resources. _SRS is not used to disable a device; use the _DIS control method instead.",
    "example": ""
  },
  {
    "title": "_CCA (Cache Coherency Attribute)",
    "syntax": "",
    "arguments": "",
    "description": "The _CCA object returns whether or not a bus-master device supports hardware managed cache coherency. Expected values are 0 to indicate it is not supported, and 1 to indicate that it is supported. All other values are reserved.\nOn platforms for which existing default cache-coherency behavior of the OS is not adequate, _CCA enables the OS to adapt to the differences. If used, _CCA must be included under all bus-master-capable devices defined as children of \\_SB, to ensure that the operating system knows when it can rely on hardware managed cache coherency. The value of _CCA is inherited by all descendants of these devices, so it need not be repeated for their children devices and will be ignored by OSPM if it is provided there. This includes slave devices on a shared DMA controller; thus these DMA controllers must also be defined in the namespace under the System Bus and include a _CCA object.\nIf a device indicates it does not have hardware cache coherency support, then OSPM must use a software cache flushing algorithm to ensure stale or invalid data is not accessed from the caches.\n__CCA objects are only relevant for devices that can access CPU-visible memory, such as devices that are DMA capable. On ARM based systems, the _CCA object must be supplied all such devices. On Intel platforms, if the _CCA object is not supplied, the OSPM will assume the devices are hardware cache coherent.",
    "example": ""
  },
  {
    "title": "_HMA (Heterogeneous Memory Attributes)",
    "syntax": "",
    "arguments": "",
    "description": "The Heterogeneous Memory Attributes Table (HMAT) defined in Section provides Heterogeneous Memory Attributes. Dynamic runtime reconfiguration of the system may cause proximities domains or memory attributes to change. If the \u201cReservation Hint\u201d is set, new HMAT update shall not reset the \u201cReservation Hint\u201d unless the memory range is removed.\n_HMA is an optional object that enables the platform to provide the OS with updated Heterogeneous Memory Attributes information at runtime. _HMA provides OSPM with the latest HMAT in entirety overriding existing HMAT.\n_EDL\nObject that evaluates to a package of namespace references of device objects that depend on the device containing _EDL.\n_EJD\nObject that evaluates to the name of a device object on which a device depends. Whenever the named device is ejected, the dependent device must receive an ejection notification.\n_EJx\nControl method that ejects a device.\n_LCK\nControl method that locks or unlocks a device.\n_OST\nControl method invoked by OSPM to convey processing status to the platform.\n_RMV\nObject that indicates that the given device is removable.\n_STA\nControl method that returns a device\u2019s status.",
    "example": ""
  },
  {
    "title": "_EDL (Eject Device List)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to a package of namespace references containing the names of device objects that depend on the device under which the _EDL object is declared. This is primarily used to support docking stations. Before the device under which the _EDL object is declared may be ejected, OSPM prepares the devices listed in the _EDL object for physical removal.",
    "example": ""
  },
  {
    "title": "_EJD (Ejection Dependent Device)",
    "syntax": "",
    "arguments": "",
    "description": "This object is used to specify the name of a device on which the device, under which this object is declared, is dependent. This object is primarily used to support docking stations. Before the device indicated by _EJD is ejected, OSPM will prepare the dependent device (in other words, the device under which this object is declared) for removal.",
    "example": ""
  },
  {
    "title": "_EJx (Eject)",
    "syntax": "",
    "arguments": "",
    "description": "These control methods are optional and are supplied for devices that support a software-controlled VCRstyle ejection mechanism or that require an action be performed such as isolation of power/data lines before the device can be removed from the system. To support warm (system is in a sleep state) and hot (system is in S0) removal, an _EJx control method is listed for each sleep state from which the device supports removal, where x is the sleeping state supported. For example, _EJ0 indicates the device supports hot removal; _EJ1\u2013EJ4 indicate the device supports warm removal.",
    "example": ""
  },
  {
    "title": "_LCK (Lock)",
    "syntax": "",
    "arguments": "",
    "description": "This control method is optional and is required only for a device that supports a software-controlled locking mechanism. When the OS invokes this control method, the associated device is to be locked or unlocked based upon the value of the argument that is passed. On a lock request, the control method must not complete until the device is completely locked.",
    "example": ""
  },
  {
    "title": "_OST (OSPM Status Indication)",
    "syntax": "",
    "arguments": "",
    "description": "This object is an optional control method that is invoked by OSPM to indicate processing status to the platform. During device ejection, device hot add, Error Disconnect Recover, or other event processing, OSPM may need to perform specific handshaking with the platform. OSPM may also need to indicate to the platform its inability to complete a requested operation; for example, when a user presses an ejection button for a device that is currently in use or is otherwise currently incapable of being ejected. In this case, the processing of the ACPI Eject Request notification by OSPM fails. OSPM may indicate this failure to the platform through the invocation of the _OST control method. As a result of the status notification indicating ejection failure, the platform may take certain action including reissuing the notification or perhaps turning on an appropriate indicator light to signal the failure to the user. Arguments: (3)\nArg0 An Integer containing the source event\nArg1 An Integer containing the status code Arg2 A Buffer containing status information\nReturn Value: None\nArgument Information:\nArg0 source_event: DWordConst\nIf the value of source_event is <= 0xFF, this argument is the ACPI notification value whose processing generated the status indication. This is the value that was passed into the Notify operator.\nIf the value of source_event is 0x100 or greater then the OSPM status indication is a result of an OSPM action as indicated in Table 6-206. For example, a value of 0x103 will be passed into _OST for this argument upon the failure of a user interface invoked device ejection.\nIf OSPM is unable to identify the originating notification value, OSPM invokes _OST with a value that contains all bits set (ones) for this parameter.\nArg1 Status Code: DWordConst. OSPM indicates a notification value specific status. See Table 6-207, Table 6-208, and Table 6-210 for status code descriptions.\nArg2 A buffer containing detailed OSPM-specific information about the status indication. This argument may be null.\nTable 6-206 OST Source Event Codes\nSource Event Code\n0-0xFF\nReserved for Notification Values\n0x100\nOperation System Shutdown Processing\n0x101-0x102\nReserved\n0x103\nEjection Processing\n0x104-0x1FF\nReserved\n0x200\nInsertion Processing\n0x201-0xFFFFFFFF\nReserved\nTable 6-207 General Processing Status Codes\nStatus Code\n0\nSuccess\n1\nNon-specific failure\n2\nUnrecognized Notify Code\n3-0x7F\nReserved\n0x80-0xFFFFFFFF\nNotification value specific status codes\nTable 6-208 Operating System Shutdown Processing (Source Events : 0x100) Status Codes\nStatus Code\n0x80\nOS Shutdown Request denied\n0x81\nOS Shutdown in progress\n0x82\nOS Shutdown completed\n0x83\nOS Graceful Shutdown not supported\n0x84-0xFFFFFFFF\nReserved\n6.Processing Sequence for Graceful Shutdown Request:\nFollowing receipt of the Graceful Shutdown Request (see Table 5-166, value 0x81) the OS will be responsible for responding with one of the following status codes:\n\u2022       0x80 (OS Shutdown Request denied) \u2013This value will be sent if the OS is not capable of performing a graceful shutdown.\n\u2022       0x81 (OS Shutdown in progress) The OS has initiated the graceful shutdown procedure.\n\u2022       0x83 (OS Graceful Shutdown not supported) The OS does not support the Graceful Shutdown Request.\nIf the OS does initiate a graceful shutdown it should continue to generate the \u201cOS Shutdown in progress\u201d message (_OST source event 0x100 status code 0x81) every 10 seconds. This functions as a heartbeat so that the service which requested the graceful shutdown knows that the request is currently being processed. The platform should assume that the OS shutdown is not proceeding if it does not receive the \u201cOS Shutdown in progress\u201d message for 60 seconds.\nWhen the graceful shutdown procedure has completed the OSPM will send the \u201cOS Shutdown completed\u201d message and then transition the platform to the G2 \u201csoft-off\u201d power state.\nTable 6-209 Ejection Request / Ejection Processing (Source Events: 0x03 and 0x103) Status Codes\nStatus Code\n0x80\nDevice ejection not supported by OSPM\n0x81\nDevice in use by application\n0x82\nDevice Busy\n0x83\nEjection dependency is busy or not supported for ejection by OSPM\n0x84\nEjection is in progress (pending)\n0x85-0xFFFFFFFF\nReserved\nTable 6-210 Insertion Processing (Source Event: 0x200) Status Codes\nStatus Code\n0x80\nDevice insertion in progress (pending)\n0x81\nDevice driver load failure\n0x82\nDevice insertion not supported by OSPM\n0x83-0x8F\nReserved\n0x90-0x9F\nInsertion failure encodings:\nBit [3]\n Resources Unavailable as described by the following bit\nBus or Segment Numbers\n \nBit [2]\nInterrupts\n \nBit [1]\nI/O\n \nBit [0]\nMemory\n0xA0-0xFFFFFFFF\nReserved\n \nIt is possible for the platform to issue multiple notifications to OSPM and for OSPM to process the notifications asynchronously. As such, OSPM may invoke _OST for notifications independent of the order the notification are conveyed by the platform or by software to OSPM.\nThe figure below provides and example event flow of device ejection on a platform employing the _OST object.\nFigure 6-34 Device Ejection Flow Example Using _OST\nNote:     To maintain compatibility with OSPM implementations of previous revisions of the ACPI specification, the platform must not rely on OSPM\u2019s evaluation of the _OST object for proper platform operation.",
    "example": ""
  },
  {
    "title": "_RMV (Remove)",
    "syntax": "",
    "arguments": "",
    "description": "The optional _RMV object indicates to OSPM whether the device can be removed while the system is in the working state and does not require any ACPI system firmware actions to be performed for the device to be safely removed from the system (in other words, any device that only supports surprise-style removal). Any such removable device that does not have _LCK or _EJx control methods must have an _RMV object. This allows OSPM to indicate to the user that the device can be removed and to provide a way for shutting down the device before removing it. OSPM will transition the device into D3 before telling the user it is safe to remove the device.\nThis method is reevaluated after a device-check notification.",
    "example": ""
  },
  {
    "title": "_STA (Status)",
    "syntax": "",
    "arguments": "",
    "description": "This object returns the current status of a device, which can be one of the following: enabled, disabled, or removed.\nOSPM evaluates the _STA object before it evaluates a device _INI method. The return values of the Present and Functioning bits determines whether _INI should be evaluated and whether children of the device should be enumerated and initialized. See Section 6.5.1, \u201c_INI (Init)\u201d.\nIf a device object describes a device that is not on an enumerable bus and the device object does not have an _STA object, then OSPM assumes that the device is present, enabled, shown in the UI, and functioning.\nThis method must not reference any operation regions that have not been declared available by a _REG method.\nByte 0\nResource Identifier\nValue = 0x8D, (10001101B) Type = 1, Large item name = 0x0D\nByte 1\nLength, bits[7:0]\nVariable length, minimum value = 0x0F + L (15 + length of the\nResource Source Name string)\nByte 2\nLength, bits[15:8]\nVariable length, minimum value = 0x00\nByte 3\nRevision ID\nIndicates the revision for the Pin Function Descriptor. This value is 1\nByte 4\nFlags [7:0]\nBit [7:1] - Reserved. Must be 0.\nBit [0] - IO Sharing, _SHR\n 0x0 = Exclusive: This function is used exclusively by one device.\n 0x1 = Shared: This function is shared by two or more devices.\nByte 5\nFlags [15:8]\nReserved. Must be 0.\nByte 6\nPin pull configuration\nCan be one of PullDefault, PullUp, PullDown, PullNone or a vendor-supplied value in the range 128-255.\nByte 7\nFunction number (low byte)\nThe function number in which the pin is configured. This number is provider-specific.\nByte 8\nFunction number (high byte)\nThe function number in which the pin is configured. This number is provider-specific.\nByte 9\nPin table offset (low byte)\nOffset to the start of the pin table (low byte). The offset is relative to the start of this descriptor.\n \nByte Offset\nField Name\nByte 10\nPin table offset (high byte)\nOffset to the start of the pin table (high byte). The offset is relative to the start of this descriptor.\nByte 11\nResource source index\nReserved for future use. This field must be 0.\nByte 12\nResource source name index (low byte)\nOffset to the start of the resource source name (low byte). The offset is relative to the start of this descriptor.\nByte 13\nResource source name index (high byte)\nOffset to the start of the resource source name (high byte). The offset is relative to the start of this descriptor.\nByte 14\nVendor data offset (low byte)\n(low byte) Offset to the start of the Vendordefined Data (the last byte of the\nResourceSource + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the ResourceSource + 1. The offset is relative to the start of this descriptor.\nByte 15\nVendor data offset (high byte)\n(high byte) Offset to the start of the Vendordefined Data (the last byte of the\nResourceSource + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the ResourceSource + 1. The offset is relative to the start of this descriptor.\nByte 16\nVendor data length (low byte)\nLength of Vendor-defined Data (low-byte).\nByte 17\nVendor data length (high byte)\nLength of Vendor-defined Data (high-byte).\nByte PinTableOffset[15:0] + 2n (n is the index into the pin table)Byte PinTableOffset[15:0] + 2n + 1 (n is the index into the pin table)\nPin Number, bits [15:8]\nProvider-relative pin number (high byte). _PIN[15:8]. Pin numbers are zero-based.\nByte PinTableOffset[15:0] + 2n + 1 (n is the index into the pin table)\nByte\nResourceSourceNameOffset[15:0]\nResource Source (length = L)\nName of the function config provider to which this descriptor applies. The name can be a fullyqualified name, a relative name or a name segment that utilizes the namespace search\nByte VendorDataOffset[15:0]\nVendor-defined Data\n(Optional)\nData specific to the GPIO controller device supplied by a vendor. This data is provided to the device driver for this GPIO Controller. _VEN.\n6.Pin Configuration Descriptor\nTable 6-245 Pin Configuration Descriptor Definition\nByte Offset\nField Name\nByte 0\nResource Identifier\nValue = 0x8F, (10001111B) Type = 1, Large item name = 0x0F\nByte 1\nLength, bits[7:0]\nVariable length, minimum value = 0x13 + L (19 + length of the\nResource Source Name string)\nByte 2\nLength, bits[15:8]\nVariable length, minimum value = 0x00\nByte 3\nRevision ID\nIndicates the revision for the Function Configuration Descriptor. This value is 1\nByte 4\nFlags [7:0]\nBit [7:2] - Reserved. Must be 0.\nBit [1] - Consumer/Producer\n 0x1: This device consumes this resource\n 0x0: This device produces and consumes this resource\nBit [0] - IO Sharing, _SHR\n 0x0 = Exclusive: This function is used exclusively by one device.\n 0x1 = Shared: This function is shared by two or more devices.\nByte 5\nFlags [15:8]\nReserved. Must be 0.\nByte6\nPin Configuration Type, _TYP\nThe pin configuration type (see Table 19-434).\nByte 7\nPin Configuration\nValue, _VAL, bits [7:0]\nThe pin configuration value associated with the pin configuration type (see Table 19-434).\nByte 8\nPin Configuration\nValue, _VAL, bits\n[15:8]\nThe pin configuration value associated with the pin configuration type (see Table 19-434).\nByte 9\nPin Configuration Value, _VAL, bits\n[23:16]\nThe pin configuration value associated with the pin configuration type (see Table 19-434).\nByte 10\nPin Configuration\nValue, _VAL, bits\n[31:24]\nThe pin configuration value associated with the pin configuration type (see Table 19-434).\nByte 11\nPin Table\nOffset[7:0]\nOffset to the start of the pin table (low byte). The offset is relative to the start of this descriptor.\nByte 12\nPin Table\nOffset[15:8]\nOffset to the start of the pin table (high byte). The offset is relative to the start of this descriptor.\n \nByte Offset\nField Name\nByte 13\nResource\nSource Index\nReserved for future use. This field must be 0.\nByte 14\nResource\nSource Name\nOffset[7:0]\nOffset to the start of the resource source name (low byte). The offset is relative to the start of this descriptor.\nByte 15\nResource\nSource Name\nOffset[15:8]\nOffset to the start of the resource source name (high byte). The offset is relative to the start of this descriptor.\nByte 16\nVendor Data\nOffset[7:0]\n(low byte) Offset to the start of the Vendordefined Data (the last byte of the\nResourceSource + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the ResourceSource + 1. The offset is relative to the start of this descriptor.\nByte 17\nVendor Data\nOffset[15:8]\n(high byte) Offset to the start of the Vendordefined Data (the last byte of the\nResourceSource + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the ResourceSource + 1. The offset is relative to the start of this descriptor.\nByte 18\nVendor Data\nLength [7:0]\nLength of Vendor-defined Data (low-byte).\nByte 19\nVendor Data\nLength [15:8]\nLength of Vendor-defined Data (high-byte).\nByte PinTableOffset[15:0] + 2n (n is the index into the pin table)\nPin Number, _PIN, bits [7:0]\nProvider-relative pin number (low byte). Pin numbers are zero-based.\nByte PinTableOffset[15:0] + 2n + 1 (n is the index into the pin table)\nPin Number, _PIN, bits [15:8]\nProvider-relative pin number (high byte). Pin numbers are zero-based.\nByte\nResourceSourceNameOffset[15:0]\nResource Source (length = L)\nName of the pin controller to which this descriptor applies. The name can be a fullyqualified name, a relative name or a name segment that utilizes the namespace search\nByte VendorDataOffset[15:0]\nVendor-defined Data, _VEN\n(Optional)\nData specific to the pin controller device supplied by a vendor. This data is provided to the device driver for this pin controller.\n6.Pin Group Descriptor\nTable 6-246 Pin Group Descriptor Definition\nByte Offset\nField Name\nByte 0\nResource Identifier\nValue = 0x90, (10010000B) Type = 1, Large item name = 0x10\nByte 1\nLength [7:0]\nVariable length, minimum value = 0x0B + L (11 + length of the Resource Label)\nByte 2\nLength [15:8]\nValue = 0x00\nByte 3\nRevision ID\nIndicates the revision for the Pin Group Descriptor. This value is 1.\nByte 4\nFlags [7:0]\n[7:1] Reserved. Must be 0.\nBit [0] - Consumer/Producer\n 0x1: This device consumes this resource\n 0x0: This device produces and consumes this resource\nByte 5\nFlags [15:8]\nReserved. Must be 0.\nByte 6\nPin table offset [7:0]\nOffset to the start of the pin table (low byte). The offset is relative to the start of this descriptor.\nByte 7\nPin table offset [15:8]\nOffset to the start of the pin table (high byte). The offset is relative to the start of this descriptor.\nByte 8\nResource label offset [7:0]\nOffset to the start of the resource label (low byte). The offset is relative to the start of this descriptor.\nThe length of the resource label string can be calculated from length L = Vendor data offset Resource label offset. The length includes the string\u2019s terminating \u2018\\0\u2019 character.\nByte 9\nResource label offset [15:8]\nOffset to the start of the resource label (high byte). The offset is relative to the start of this descriptor.\nByte 10\nVendor data offset [7:0]\n(low byte) Offset to the start of the Vendordefined Data (the last byte of the Resource label offset (high byte) + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the Resource label offset (high byte) + 1. The offset is relative to the start of this descriptor.\nByte Offset\nField Name\nByte11\nVendor data offset [15:8]\n(high byte) Offset to the start of the Vendordefined Data (the last byte of the Pin table offset (high byte) + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the Pin table offset (high byte) + 1. The offset is relative to the start of this descriptor.\nByte 12\nVendor data length [7:0]\nLength of Vendor-defined Data (low-byte).\nByte 13\nVendor data length [15:8]\nLength of Vendor-defined Data (high-byte).\nByte PinTableOffset[15:0] + 2n (n is the index into the pin table)\nPin Number, _PIN [7:0]\nProvider-relative pin number (low byte). Pin numbers are zero-based.\nByte PinTableOffset[15:0] + 2n + 1 (n is the index into the pin table)\nPin Number, _PIN [15:8]\nProvider-relative pin number (high byte). Pin numbers are zero-based.\nByte ResourceLabelOffset[15:0]\nResource Label (length = L)\nLabel for the resource (string). Can be any nonempty string and is used by resource consumers to refer to this resource by name. Always terminated by \u2018\\0\u2019.\nByte VendorDataOffset[15:0]\nVendor-defined Data, _VEN\n(Optional)\nData specific to the GPIO controller device supplied by a vendor. This data is provided to the device driver for this GPIO Controller.\n6.Pin Group Function Descriptor\nTable 6-247 Pin Group Function Descriptor Definition\nByte Offset\nField Name\nByte 0\nResource Identifier\nValue = 0x91, (10010001B) Type = 1, Large item name = 0x11\nByte 1\nLength [7:0]\nVariable length, minimum value = 0x0E + L1 + L2 (14 + length of the\nResource Source Name string + length of the\nResource Source Label string)\nByte 2\nLength [15:8]\nVariable length, minimum value = 0x00\nByte 3\nRevision ID\nIndicates the revision for the Pin Function Descriptor. This value is 1\n \nByte Offset\nField Name\nByte 4\nFlags [7:0]\nBit [7:2] - Reserved. Must be 0.\nBit [1] - Consumer/Producer\n 0x1: This device consumes this resource\n 0x0: This device produces and consumes this resource\nBit [0] - IO Sharing, _SHR\n 0x0 = Exclusive: This function is used exclusively by one device.\n 0x1 = Shared: This function is shared by two or more devices.\nByte 5\nFlags [15:8]\nReserved. Must be 0.\nByte 6\nFunction number, _FUN [7:0]\nThe function number in which the pin is configured. This number is provider-specific.\nByte 7\nFunction number, _FUN [15:8]\nThe function number in which the pin is configured. This number is provider-specific.\nByte 8\nResource source index\nReserved for future use. This field must be 0.\nByte 9\nResource source name index [7:0]\nOffset to the start of the resource source name (low byte). The offset is relative to the start of this descriptor.\nByte 10\nResource source name index [15:8]\nOffset to the start of the resource source name (high byte). The offset is relative to the start of this descriptor.\nByte 11\nResource source label offset [7:0]\nOffset to the start of the Resource source label (low byte). The offset is relative to the start of this descriptor.\nThe length of the resource source label string can be calculated from length L2 = Vendor data offset Resource source label offset. The length includes the string\u2019s terminating \u2018\\0\u2019 character.\nByte 12\nResource source label offset [15:8]\nOffset to the start of the resource source label (high byte). The offset is relative to the start of this descriptor.\nByte Offset\nField Name\nByte 13\nVendor data offset [7:0]\n(low byte) Offset to the start of the Vendordefined Data (the last byte of the\nResourceSource + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the ResourceSource + 1. The offset is relative to the start of this descriptor.\nByte 14\nVendor data offset [15:8]\n(high byte) Offset to the start of the Vendordefined Data (the last byte of the\nResourceSource + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the ResourceSource + 1. The offset is relative to the start of this descriptor.\nByte 15\nVendor data length [7:0]\nLength of Vendor-defined Data (low-byte).\nByte 16\nVendor data length [15:8]\nLength of Vendor-defined Data (high-byte).\nByte\nResourceSourceNameOffset[15:0]\nResource Source (length = L1)\nName of the function config provider to which this descriptor applies. The name can be a fully-qualified name, a relative name or a name segment that utilizes the namespace search\nByte\nResourceSourceLabelOffset[15:0]\nResource Source Label (length = L2)\nThis name refers to the PinGroup resource in the current resource template buffer of the GPIO controller. The PinGroup resource is matched by comparing its ResourceLabel string to this field. Always terminated by \u2018\\0\u2019.\nByte VendorDataOffset[15:0]\nVendor-defined Data, _VEN\n(Optional)\nData specific to the GPIO controller device supplied by a vendor. This data is provided to the device driver for this GPIO Controller.\n6.Pin Group Configuration Descriptor\nTable 6-248 Pin Group Configuration Descriptor Description\nByte Offset\nField Name\nByte 0\nResource Identifier\nValue = 0x92, (10010001B) Type = 1, Large item name = 0x12\n \nByte Offset\nField Name\nByte 1\nLength, bits[7:0]\nVariable length, minimum value = 0x11 + L1 + L2 (17 + length of the\nResource Source Name string + length of the\nResource Source Label string)\nByte 2\nLength, bits[15:8]\nVariable length, minimum value = 0x00\nByte 3\nRevision ID\nIndicates the revision for the Function Configuration Descriptor. This value is 1\nByte 4\nFlags [7:0]\nBit [7:2] - Reserved. Must be 0.\nBit [1] - Consumer/Producer\n 0x1: This device consumes this resource\n 0x0: This device produces and consumes this resource\nBit [0] - IO Sharing, _SHR\n 0x0 = Exclusive: This function is used exclusively by one device.\n 0x1 = Shared: This function is shared by two or more devices.\nByte 5\nFlags [15:8]\nReserved. Must be 0.\nByte6\nPin Configuration Type, _TYP\nThe pin configuration type (see Table 19-435).\nByte 7\nPin Configuration Value, _VAL, bits\n[7:0]\nThe pin configuration value associated with the pin configuration type (see Table 19-435).\nByte 8\nPin Configuration Value, _VAL, bits\n[15:8]\nThe pin configuration value associated with the pin configuration type (see Table 19-435).\nByte 9\nPin Configuration Value, _VAL, bits\n[23:16]\nThe pin configuration value associated with the pin configuration type (see Table 19-435).\nByte 10\nPin Configuration Value, _VAL, bits\n[31:24]\nThe pin configuration value associated with the pin configuration type (see Table 19-435).\nByte 11\nResource\nSource Index\nReserved for future use. This field must be 0.\nByte 12\nResource\nSource Name\nOffset[7:0]\nOffset to the start of the resource source name (low byte). The offset is relative to the start of this descriptor.\n \nByte Offset\nField Name\nByte 13\nResource\nSource Name\nOffset[15:8]\nOffset to the start of the resource source name (high byte). The offset is relative to the start of this descriptor.\nByte 14\nResource source label offset (low byte)\nOffset to the start of the resource source label (low byte). The offset is relative to the start of this descriptor.\nThe length of the resource source label string can be calculated from length L2 = Vendor data offset Resource source label offset. The length includes the string\u2019s terminating \u2018\\0\u2019 character.\nByte 15\nResource source label offset (high byte)\nOffset to the start of the resource source label (high byte). The offset is relative to the start of this descriptor.\nByte 16\nVendor Data\nOffset[7:0]\n(low byte) Offset to the start of the Vendordefined Data (the last byte of the\nResourceSource + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the ResourceSource + 1. The offset is relative to the start of this descriptor.\nByte 17\nVendor Data\nOffset[15:8]\n(high byte) Offset to the start of the Vendordefined Data (the last byte of the\nResourceSource + 1). This value must always be valid to allow for length calculations. In the case where there is no Vendor Data, this offset still must refer to the last byte of the ResourceSource + 1. The offset is relative to the start of this descriptor.\nByte 18\nVendor Data\nLength [7:0]\nLength of Vendor-defined Data (low-byte).\nByte 19\nVendor Data\nLength [15:8]\nLength of Vendor-defined Data (high-byte).\nByte\nResourceSourceNameOffset[15:0]\nResource Source (length = L1)\nName of the pin controller to which this descriptor applies. The name can be a fullyqualified name, a relative name or a name segment that utilizes the namespace search\nByte\nResourceSourceLabelOffset[15:0]\nResource Source Label (length = L2)\nThis name refers to the PinGroup resource in current resource template buffer of the GPIO controller. The PinGroup resource is matched by comparing its ResourceLabel string to this field. Always terminated by \u2018\\0\u2019.\nByte Offset\nField Name\nByte VendorDataOffset[15:0]\nVendor-defined Data, _VEN\n(Optional)\nData specific to the pin controller device supplied by a vendor. This data is provided to the device driver for this pin controller.\n6.5 Other Objects and Control Methods\nTable 6-249 Other Objects and Methods\nObject\n_BBN\nPCI bus number set up by the platform boot firmware.\n_BDN\nCorrelates a docking station between ACPI and legacy interfaces.\n_DCK\nIndicates that the device is a docking station.\n_DEP\nIndicates device objects that OSPM should assign a higher priority in start ordering due to future operation region accesses.\n_FIT\nObject that evaluates to a buffer of NFIT Structures.\n_GLK\nIndicates the Global Lock must be acquired when accessing a device.\n_INI\nDevice initialization method that is run shortly after ACPI has been enabled.\n_LSI\nLabel Storage Information Returns information about the Label Storage Area associated with the NVDIMM object, including its size.\n_LSR\nLabel Storage Read Returns label data from the Label Storage Area of the NVDIMM object.\n_LSW\nLabel Storage Write Writes label data in to the Label Storage Area of the NVDIMM object.\n_REG\nNotifies AML code of a change in the availability of an operation region.\n_SEG\nIndicates a bus segment location.",
    "example": ""
  },
  {
    "title": "_INI (Init)",
    "syntax": "",
    "arguments": "",
    "description": "_INI is a device initialization object that performs device specific initialization. This control method is located under a device object and is run only when OSPM loads a description table. There are restrictions related to when this method is called and governing writing code for this method. The _INI method must only access Operation Regions that have been indicated to available as defined by the _REG method. The\n_REG method is described in Section 6.5.4, \u201c_REG (Region).\u201d This control method is run before _ADR, _CID, _HID, _SUN, and _UID are run.",
    "example": ""
  },
  {
    "title": "_DCK (Dock)",
    "syntax": "",
    "arguments": "",
    "description": "This control method is located in the device object that represents the docking station (that is, the device object with all the _EJx control methods for the docking station). The presence of _DCK indicates to the OS that the device is really a docking station.\n_DCK also controls the isolation logic on the docking connector. This allows an OS to prepare for docking before the bus is activated and devices appear on the bus.",
    "example": ""
  },
  {
    "title": "_BDN (BIOS Dock Name)",
    "syntax": "",
    "arguments": "",
    "description": "_BDN is used to correlate a docking station reported via ACPI and the same docking station reported via legacy interfaces. It is primarily used for upgrading over non-ACPI environments.",
    "example": ""
  },
  {
    "title": "_REG (Region)",
    "syntax": "",
    "arguments": "",
    "description": "The OS runs _REG control methods to inform AML code of a change in the availability of an operation region. When an operation region handler is unavailable, AML cannot access data fields in that region. (Operation region writes will be ignored and reads will return indeterminate data.)",
    "example": ""
  },
  {
    "title": "_BBN (Base Bus Number)",
    "syntax": "",
    "arguments": "",
    "description": "For multi-root PCI platforms, the _BBN object evaluates to the PCI bus number that the platform boot firmware assigns. This is needed to access a PCI_Config operation region for the specific bus. The _BBN object is located under a PCI host bridge and must be unique for every host bridge within a segment since it is the PCI bus number.",
    "example": ""
  },
  {
    "title": "_SEG (Segment)",
    "syntax": "",
    "arguments": "",
    "description": "The optional _SEG object is located under a PCI host bridge and evaluates to an integer that describes the\nPCI Segment Group (see PCI Firmware Specification v3.0). If _SEG does not exist, OSPM assumes that all PCI bus segments are in PCI Segment Group 0.",
    "example": ""
  },
  {
    "title": "_GLK (Global Lock)",
    "syntax": "",
    "arguments": "",
    "description": "This optional named object is located within the scope of a device object. This object returns a value that indicates to any entity that accesses this device (in other words, OSPM or any device driver) whether the Global Lock must be acquired when accessing the device. OS-based device accesses must be performed while in acquisition of the Global Lock when potentially contentious accesses to device resources are performed by non-OS code, such as System Management Mode (SMM)-based code in Intel architecturebased systems.\nNote:     Default behavior: if _GLK is not present within the scope of a given device, then the Global Lock is not required for that device.",
    "example": ""
  },
  {
    "title": "_DEP (Operation Region Dependencies)",
    "syntax": "",
    "arguments": "",
    "description": "_DEP evaluates to a package and designates device objects that OSPM should assign a higher priority in start ordering due to future operation region accesses.\nTo increase the likelihood that an SPB operation region handler is available when needed, OSPM needs to know in advance which methods will access it -- _DEP provides OSPM with this information. While the _DEP keyword may be used to determine start ordering, only the _REG method (Section 6.5.4) callbacks can be relied upon to determine whether a region is accessible at a given point in time.",
    "example": ""
  },
  {
    "title": "_FIT (Firmware Interface Table)",
    "syntax": "",
    "arguments": "",
    "description": "This method evaluates to a buffer returning data in the format of a series of NFIT Structures (See Section 5.2.25). This method may appear under the NVDIMM root device (see Section 9.20.2). The _FIT method, when present, is always evaluated by OSPM.\n_FIT returns all the entries in the NFIT.\nThe NFIT Update Notification notification value for the NVDIMM root device (see Table 5-173) notifies OSPM that it needs to re-evaluate the _FIT method.\nNote: NFIT is an ACPI table enumerated at OS boot. In case of hot plug of NVDIMMs, the corresponding NFIT structures will not be present in NFIT. _FIT method is also used to provide these structures dynamically during hot plug.\n_LSI\nLabel Storage Information Returns information about the Label Storage Area associated with the NVDIMM object, including its size.\n_LSR\nLabel Storage Read Returns label data from the Label Storage Area of the NVDIMM object.\n_LSW\nLabel Storage Write Writes label data in to the Label Storage Area of the NVDIMM object.\n6._LSI (Label Storage Information)\nThis optional object returns information about the Label Storage Area for the requested device.\nStatus\nInteger\n(DWORD)\nIndicates the status of the _LSI request.\uf020 0x00000000 Success Returned package is valid\uf020\n0x00000001 Failure The rest of the returned package is not valid\nSizeOfLabelStorageArea\nInteger\n(DWORD)\nSize of the Label Storage Area in bytes\nMaxTransferLength\nInteger\n(DWORD)\nMaximum amount of data in bytes supported by a single call to the _LSR and _LSW methods. This is the minimum of the platform supported transfer size and the transfer size supported by the NVDIMM.\n0x00000000 - the NVDIMM does not support label storage.\nA non-zero value the NVDIMM supports label storage.\n6._LSR (Label Storage Read)\nThis optional object returns label data from the Label Storage Area starting at the specified offset.\nStatus\nInteger\n(DWORD)\nIndicates the status of the _LSR request.\uf020\n0x00000000 Success\uf020\n0x00000001 Failure\uf020\n0x00000002 Invalid Input Parameters\uf020\n   -Offset > SizeOfLabelStorageArea reported with _LSI\uf020\n   -Offset + TransferLength > SizeOfLabelStorageArea reported with _LSI\uf020\n   -TransferLength > MaxTransferLength reported with _LSI\uf020\n0x00000003 Label Storage Area is locked and cannot be accessed\uf020\n0x00000004 HW failure prevented data from being read\uf020 Note: Any other non-zero values reflect a failure\nLabelData\nBuffer\nContains the returned label storage data. The size of the output is equal to TransferLength if Status is Success; otherwise, the contents of the output buffer shall be 0. The format of the Label Storage Area data is defined in UEFI.\n6._LSW (Label Storage Write)\nThis optional object writes label data to the Label Storage Area starting at the specified offset.\n_OFF\nSet the resource off.\n_ON\nSet the resource on.\n_RST\nObject that executes a platform level reset of all devices that list this resource in their _PRR object. (See Section for a description of this object.)\n_STA\nObject that evaluates to the current on or off state of the Power Resource. 0\u2013OFF, 1\u2013ON",
    "example": ""
  },
  {
    "title": "_OFF",
    "syntax": "",
    "arguments": "",
    "description": "This power resource control method puts the power resource into the OFF state. The control method must not complete until the power resource is off, including any required sequencing delays between, or after, operations on the power resource. OSPM is required to turn on or off only one resource at a time. The AML code can use Stall or Sleep within the method to cause the proper sequencing delays. OSPM is not required to run the _STA method to confirm that the resource has been successfully turned off, and may run the _OFF method repeatedly, even if the resource is already off.",
    "example": ""
  },
  {
    "title": "_ON",
    "syntax": "",
    "arguments": "",
    "description": "This power resource control method puts the power resource into the ON state. The control method must not complete until the power resource is on, including any required sequencing delays between, or after, operations on the power resource. OSPM is required to turn on or off only one resource at a time. The AML code can use Stall or Sleep within the method to cause the proper sequencing delays. OSPM is not required to run the _STA method to confirm that the resource has been successfully turned on, and may run the _ON method repeatedly, even if the resource is already on.",
    "example": ""
  },
  {
    "title": "_STA (Status)",
    "syntax": "",
    "arguments": "",
    "description": "Returns the current ON or OFF status for the power resource.\n_DSW\nControl method that enables or disables the device\u2019s wake function for device-only wake.\n_PS0\nControl method that puts the device in the D0 device state (device fully on).\n_PS1\nControl method that puts the device in the D1 device state.\n_PS2\nControl method that puts the device in the D2 device state.\n_PS3\nControl method that puts the device in the D3 device state (device off).\n_PSC\nObject that evaluates to the device\u2019s current power state.\n_PR0\nObject that evaluates to the device\u2019s power requirements in the D0 device state (device fully on).\n_PR1\nObject that evaluates to the device\u2019s power requirements in the D1 device state. The only devices that supply this level are those that can achieve the defined D1 device state according to the related device class.\n_PR2\nObject that evaluates to the device\u2019s power requirements in the D2 device state. The only devices that supply this level are those that can achieve the defined D2 device state according to the related device class.\n_PR3\nObject that evaluates to the device\u2019s power requirements in the D3hot device state.\n_PRW\nObject that evaluates to the device\u2019s power requirements in order to wake the system from a system sleeping state.\n_PSW\nControl method that enables or disables the device\u2019s wake function.\n_IRC\nObject that signifies the device has a significant inrush current draw.\nObject\n_S1D\nShallowest D-state supported by the device in the S1 state\n_S2D\nShallowest D-state supported by the device in the S2 state\n_S3D\nShallowest D-state supported by the device in the S3 state\n_S4D\nShallowest D-state supported by the device in the S4 state\n_S0W\nDeepest D-state supported by the device in the S0 state which can wake the device\n_S1W\nDeepest D-state supported by the device in the S1 state which can wake the system.\n_S2W\nDeepest D-state supported by the device in the S2 state which can wake the system.\n_S3W\nDeepest D-state supported by the device in the S3 state which can wake the system.\n_S4W\nDeepest D-state supported by the device in the S4 state which can wake the system.\n_RST\nControl method that executes a function level reset of the device.\n_PRR\nObject that evaluates to the device's platform level reset requirements.",
    "example": ""
  },
  {
    "title": "_DSW (Device Sleep Wake)",
    "syntax": "",
    "arguments": "",
    "description": "In addition to _PRW, this control method can be used to enable or disable the device\u2019s ability to wake a sleeping system. This control method can only access Operation Regions that are either always available while in a system working state or that are available when the Power Resources referenced by the _PRW object are all ON. For example, do not put a power plane control for a bus controller within configuration space located behind the bus. The method should enable the device only for the last system state/device state combination passed in by OSPM. OSPM will only pass in combinations allowed by the _SxD and _SxW objects.\nThe arguments provided to _DSW indicate the eventual Device State the device will be transitioned to and the eventual system state that the system will be transitioned to. The target system state is allowed to be the system working state (S0). The _DSW method will be run before the device is placed in the designated state and also before the system is placed in the designated system state.\nCompatibility Note: The _PSW method was deprecated in ACPI 3.0. The _DSW method should be used instead. OSPM will only use the _PSW method if OSPM does not support _DSW or if the _DSW method is not present.",
    "example": ""
  },
  {
    "title": "_PS0 (Power State 0)",
    "syntax": "",
    "arguments": "",
    "description": "This Control Method is used to put the specific device into its D0 state. This Control Method can only access Operation Regions that are either always available while in a system working state or that are available when the Power Resources references by the _PR0 object are all ON.",
    "example": ""
  },
  {
    "title": "_PS1 (Power State 1)",
    "syntax": "",
    "arguments": "",
    "description": "This control method is used to put the specific device into its D1 state. This control method can only access Operation Regions that are either always available while in the system working state (S0) or that are available when the Power Resources referenced by the _PR0 object are all ON.",
    "example": ""
  },
  {
    "title": "_PS2 (Power State 2)",
    "syntax": "",
    "arguments": "",
    "description": "This control method is used to put the specific device into its D2 state. This control method can only access Operation Regions that are either always available while in the system working state (S0) or that are available when the Power Resources referenced by the _PR0 and _PR1 objects are all ON.",
    "example": ""
  },
  {
    "title": "_PS3 (Power State 3)",
    "syntax": "",
    "arguments": "",
    "description": "This control method is used to put the specific device into its D3 state. This control method can only access Operation Regions that are either always available while in the system working state (S0) or that are available when the Power Resources referenced by the _PR0, _PR1 and  PR2 objects are all ON.",
    "example": ""
  },
  {
    "title": "_PSC (Power State Current)",
    "syntax": "",
    "arguments": "",
    "description": "This control method evaluates to the current device state. This control method is not required if the device state can be inferred by the Power Resource settings. This would be the case when the device does not require a _PS0, _PS1, _PS2, or _PS3 control method.",
    "example": ""
  },
  {
    "title": "_PSE (Power State for Enumeration)",
    "syntax": "",
    "arguments": "",
    "description": "This control method is used to put a device into a powered mode appropriate for enumeration by its parent bus. This control method can only access Operation Regions that are either always available while in a system working state or that are available when the Power Resources referenced by the _PRE object are all ON.",
    "example": ""
  },
  {
    "title": "_PR0 (Power Resources for D0)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to a list of power resources that are dependent on this device. For OSPM to put the device in the D0 device state, the following must occur:\n1.       All Power Resources referenced by elements 1 through N must be in the ON state.\n2.       All Power Resources no longer referenced by any device in the system must be in the OFF state.\n3.       If present, the _PS0 control method is executed to set the device into the D0 device state.\n1\nobject reference\nReference to required Power Resource #0\nN\nobject reference\nReference to required Power Resource #N\n_PR0 must return the same data each time it is evaluated. All power resources referenced must exist in the namespace.",
    "example": ""
  },
  {
    "title": "_PR1 (Power Resources for D1)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to a list of power resources upon which this device is dependent when it is in the D1 state. For OSPM to transition the device from the D0 state into the D1 state, the following must occur, in order:\n1.      If present, the _PS1 control method is executed to set the device into the D1 device state.\n2.      All Power Resources referenced by elements 1 through N must be in the ON state.\n3.      All Power Resources no longer referenced by any device in the system must be in the OFF state.",
    "example": ""
  },
  {
    "title": "_PR2 (Power Resources for D2)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to a list of power resources upon which this device is dependent when it is in the D2 state. For OSPM to transition the device into the D2 state, the following must occur, in order:\n1.      If present, the _PS2 control method is executed to set the device into the D2 device state.\n2.      All Power Resources referenced by elements 1 through N must be in the ON state.\n3.      All Power Resources no longer referenced by any device in the system must be in the OFF state.",
    "example": ""
  },
  {
    "title": "_PR3 (Power Resources for D3hot)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to a list of power resources upon which this device is dependent when it is in the\nD3hot state. For OSPM to transition the device into the D3hot state, the following must occur, in order:\n1.      If present, the _PS3 control method is executed to set the device into the D3hot device state.\n2.      All Power Resources referenced by elements 1 through N must be in the ON state.\n3.      All Power Resources no longer referenced by any device in the system must be in the OFF state.",
    "example": ""
  },
  {
    "title": "_PRE (Power Resources for Enumeration)",
    "syntax": "",
    "arguments": "",
    "description": "This object appears under a device and evaluates to a list of power resources that are required for enumeration of the device by its parent bus. For the bus driver to enumerate any devices while they are in the D3Cold device state, OSPM must ensure that the following occur:\n1.      All Power Resources referenced by elements 1 through N must be in the ON state.\n2.      If present, the _PSE control method is executed to perform any actions on the device to make it accessible for enumeration.",
    "example": ""
  },
  {
    "title": "_PRW (Power Resources for Wake)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to a list of power resources upon which this device depends for wake. It also contains additional information needed for wake, including wake events and sleep or soft-off state information. _PRW is only required for devices that have the ability to wake the system from a system sleeping state.\nFour types of general purpose events are supported:\n\u2022       GPEs that are defined by a GPE block described within the FADT.\n\u2022       GPEs that are defined by a GPE Block Device.\n\u2022       GPIO-signaled events that are defined by _AEI object of the GPIO controller device\n\u2022       Interrupt-signaled events that are defined by _CRS object of the Generic Event Device (GED)\nThe four types of events are differentiated by the type of the EventInfo object in the returned package.\nFor FADT-based GPEs, EventInfo is an Integer containing a bit index. For Block Device-based GPEs, EventInfo is a Package containing a Reference to the parent block device and an Integer containing a bit index. For GPIO-signaled events, EventInfo is a Package containing a Reference to the GPIO controller device and an Integer containing the index of the event in the _AEI object (starting from zero). For Interrupt-signaled events, EventInfo is a Package containing a Reference to the GED and an Integer containing the index of the event in the _CRS object (starting from zero).\nFor HW-Reduced ACPI platforms that do not support wake on GPIO-signaled or Interrupt-signaled events, the EventInfo structure is an Integer with value of zero, and is ignored by OSPM. Therefore, _PRW is only required on such platforms if power resources for wakeup must be managed by OSPM (e.g. the _PRW provides a list of Power Resources). Instead, for a device to wake the system, its interrupt must be wakecapable and enabled by the driver. See Section 3.11.1.1\"Interrupt-based  Wake Events\".",
    "example": ""
  },
  {
    "title": "_PSW (Power State Wake)",
    "syntax": "",
    "arguments": "",
    "description": "In addition to the _PRW control method, this control method can be used to enable or disable the device\u2019s ability to wake a sleeping system. This control method can only access Operation Regions that are either always available while in a system working state or that are available when the Power Resources references by the _PRW object are all ON. For example, do not put a power plane control for a bus controller within configuration space located behind the bus.\nNote: Regarding compatability--The _PSW method was deprecated in ACPI 3.0. OSPM must use _DSW if it is present. Otherwise, it may use _PSW.",
    "example": ""
  },
  {
    "title": "_IRC (In Rush Current)",
    "syntax": "",
    "arguments": "",
    "description": "Indicates that this device can cause a significant in-rush current when transitioning to state D0.",
    "example": ""
  },
  {
    "title": "_S1D (S1 Device State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the shallowest D-state supported by this device in the S1 system sleeping state. _S1D must return the same integer each time it is evaluated. This value overrides an S-state to D-state mapping OSPM may ascertain from the device\u2019s power resource declarations. See Table 7-257 for valid return values.",
    "example": ""
  },
  {
    "title": "_S2D (S2 Device State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the shallowest D-state supported by this device in the S2 system sleeping state. _S2D must return the same integer each time it is evaluated. This value overrides an S-state to D-state mapping OSPM may ascertain from the device\u2019s power resource declarations. See Table 7-257 for valid return values.",
    "example": ""
  },
  {
    "title": "_S3D (S3 Device State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the shallowest D-state supported by this device in the S3 system sleeping state. _S3D must return the same integer each time it is evaluated. This value overrides an S-state to D-state mapping OSPM may ascertain from the device\u2019s power resource declarations. See Table 7-257 for valid return values.",
    "example": ""
  },
  {
    "title": "_S4D (S4 Device State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the shallowest D-state supported by this device in the S4 system sleeping state. _S4D must return the same integer each time it is evaluated. This value overrides an S-state to D-state mapping OSPM may ascertain from the device\u2019s power resource declarations. See Table 7-3 for valid return values.",
    "example": ""
  },
  {
    "title": "_S0W (S0 Device Wake State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the deepest D-state supported by this device in the S0 system sleeping state where the device can wake itself.",
    "example": ""
  },
  {
    "title": "_S1W (S1 Device Wake State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the deepest D-state supported by this device in the S1 system sleeping state that can wake the system.",
    "example": ""
  },
  {
    "title": "_S2W (S2 Device Wake State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the deepest D-state supported by this device in the S2 system sleeping state that can wake the system.",
    "example": ""
  },
  {
    "title": "_S3W (S3 Device Wake State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the deepest D-state supported by this device in the S3 system sleeping state that can wake the system.",
    "example": ""
  },
  {
    "title": "_S4W (S4 Device Wake State)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to an integer that conveys to OSPM the deepest D-state supported by this device in the S4 system sleeping state that can wake the system.",
    "example": ""
  },
  {
    "title": "_RST (Device Reset)",
    "syntax": "",
    "arguments": "",
    "description": "This object executes a reset on the associated device or devices. If included in a device context, the reset must not affect any other ACPI-described devices; if included in a power resource for reset (_PRR, Section 7.3.26) the reset must affect all ACPI-described devices that reference it.\nWhen this object is described in a device context, it executes a function level reset that only affects the device it is associated with; neither parent nor children should be affected by the execution of this reset. Executing this must only result in this device resetting without the device appearing as if it has been removed from the bus altogether, to prevent OSPM re-enumeration of devices on hot-pluggable buses (e.g. USB).\nIf a device reset is supported by the platform, but cannot meet the function level and bus requirement, the device should instead implement a _PRR (Section 7.3.26).\nDevices can define both a _RST and a _PRR if supported by the hardware.",
    "example": ""
  },
  {
    "title": "_PRR (Power Resource for Reset)",
    "syntax": "",
    "arguments": "",
    "description": "This object evaluates to a single reference to a power resource. The power resource that this references must implement a _RST method (Section 7.3.25).\n\\_PTS\nControl method used to notify the platform of impending sleep transition.\n\\_S0\nPackage that defines system \\_S0 state mode.\n\\_S1\nPackage that defines system \\_S1 state mode.\n\\_S2\nPackage that defines system \\_S2 state mode.\n\\_S3\nPackage that defines system \\_S3 state mode.\n\\_S4\nPackage that defines system \\_S4 state mode.\n\\_S5\nPackage that defines system \\_S5 state mode.\n\\_TTS\nControl method used to prepare to sleep and run once awakened\n\\_WAK\nControl method run once awakened.\nNote:     Compatibility issue: The _BFS (Back From Sleep) and _GTS (Going To Sleep) methods were deprecated in ACPI 5.0A.\n\\_PTS (Prepare To Sleep)\nThe _PTS control method is executed by the OS during the sleep transition process for S1, S2, S3, S4, and for orderly S5 shutdown. The sleeping state value (For example, 1, 2, 3, 4 or 5 for the S5 soft-off state) is passed to the _PTS control method. This method is called after OSPM has notified native device drivers of the sleep state transition and before the OSPM has had a chance to fully prepare the system for a sleep state transition. Thus, this control method can be executed a relatively long time before actually entering the desired sleeping state. If OSPM aborts the sleep state transition, OSPM should run the _WAK method to indicate this condition to the platform.\n1\n0\nValue for PM1a_CNT.SLP_TYP register to enter this system state. On HW-reduced platforms, this is the HW-reduced Sleep Type value for SLEEP_CONTROL_REG.SLP_TYP.\n1\n1\nValue for PM1b_CNT.SLP_TYP register to enter this system state. To enter any given state, OSPM must write the PM1a_CNT.SLP_TYP register before the\nPM1b_CNT.SLP_TYP register. On HW-reduced platforms, this value is ignored.\n2\n2\nReserved\nStates S1\u2013S4 represent some system sleeping state. The S0 state is the system working state. Transition into the S0 state from some other system state (such as sleeping) is automatic, and, by virtue that instructions are being executed, OSPM assumes the system to be in the S0 state. Transition into any system sleeping state is only accomplished by the operating software directing the hardware to enter the appropriate state, and the operating software can only do this within the requirements defined in the Power Resource and Bus/Device Package objects.\nAll run-time system state transitions (for example, to and from the S0 state), except S4 and S5, are done similarly such that the code sequence to do this is the following:\n/*\n *    Intel Architecture SetSleepingState example  */\n    ULONG\n    SetSystemSleeping (\n        IN    ULONG    NewState\n    )\n    {\n    PROCESSOR_CONTEXT   Context;\n    ULONG               PowerSeqeunce;\n    BOOLEAN             FlushCaches;\n    USHORT              SlpTyp;\n// Required environment: Executing on the system boot\n// processor. All other processors stopped.  Interrupts // disabled.  All  Power Resources (and devices) are in // corresponding device state to support NewState.\n        // Get h/w attributes for this system state\n        FlushCaches   = SleepType[NewState].FlushCache;\n        SlpTyp        = SleepType[NewState].SlpTyp & SLP_TYP_MASK;\n        _asm {\n        lea     eax, OsResumeContext\n        push    eax                      ; Build real mode handler the resume         push    offset    sp50           ; context, with eip = sp50         call    SaveProcessorState\n        mov     eax, ResumeVector        ; set firmware\u2019s resume vector         mov     [eax], offset OsRealModeResumeCode\n        mov     edx, PM1a_STS            ; Make sure wake status is clear         mov     ax, WAK_STS              ; (cleared by asserting the bit         out     dx, ax                   ; in the status register)\n        mov     edx, PM1b_STS            ;         out     dx, ax                   ;\n        and     eax, not SLP_TYP_MASK\n        or      eax, SlpTyp              ; set SLP_TYP         or      ax, SLP_EN               ; set SLP_EN\n        cmp     FlushCaches, 0\n        jz      short sp10               ; If needed, ensure no dirty data in\n        call    FlushProcessorCaches     ; the caches while sleeping\n                                   \nsp10:    mov    edx, PM1a_SLP_TYP        ; get address for PM1a_SLP_TYP         out     dx, ax                   ; start h/w sequencing         mov     edx, PM1b_SLP_TYP        ; get address for PM1b_SLP_TYP         out     dx, ax                   ; start h/w sequencing\n        mov     edx, PM1a_STS            ; get address for PM1x_STS         mov     ecx, PM1b_STS\nsp20:    in     ax, dx                    ; wait for WAK status         xchg    edx, ecx         test    ax, WAK_STS         jz      short sp20\nsp50:   \n}\n        // Done..\n        *ResumeVector = NULL;         return 0;         }\nOn HW-reduced ACPI platforms all run-time system state transitions (for example, to and from the S0 state) are done similarly, but include the following instead of PM1*_BLK register bit manipulation:\nAfter ensuring that any desired wake-capable interrupts are enabled, OSPM writes the HWreduced Sleep Type value to the Sleep Control Register and spins waiting for the WAK_STS bit of the Sleep Status Register to be set, indicating a platform transition to the Working state.\n7.System \\_S0 State (Working)\nWhile the system is in the S0 state, it is in the system working state. The behavior of this state is defined as:\n\u2022       The processors are either running, or in a C-state, or in an LPI state. The processor-complex context is maintained and instructions are executed as defined by any of these processor states.\n\u2022       Dynamic RAM context is maintained and is read/write by the processors.\n\u2022       Devices states are individually managed by the operating software and can be in any device state (D0, D1, D2, D3hot, or D3).\n\u2022       Power Resources are in a state compatible with the current device states.\nTransition into the S0 state from some system sleeping state is automatic, and by virtue that instructions are being executed OSPM, assumes the system to be in the S0 state.\n7.System \\_S1 State (Sleeping with Processor Context Maintained)\nWhile the system is in the S1 sleeping state, its behavior is the following:\n\u2022       The processors are not executing instructions. The processor-complex context is maintained.\n\u2022       Dynamic RAM context is maintained.\n\u2022       Power Resources are in a state compatible with the system S1 state. All Power Resources that supply a System-Level reference of S0 are in the OFF state.\n\u2022       Devices states are compatible with the current Power Resource states. Only devices that solely reference Power Resources that are in the ON state for a given device state can be in that device state. In all other cases, the device is in the D3 (off) state[8].\n\u2022       Devices that are enabled to wake the system and that can do so from their current device state can initiate a hardware event that transitions the system state to S0. This transition causes the processor to continue execution where it left off.\nTo transition into the S1 state, the OSPM must flush all processor caches.\n7.System \\_S2 State\nThe S2 sleeping state is logically deeper than the S1 state and is assumed to conserve more power. The behavior of this state is defined as:\n\u2022       The processors are not executing instructions. The processor-complex context is not maintained.\n\u2022       Dynamic RAM context is maintained.\n\u2022       Power Resources are in a state compatible with the system S2 state. All Power Resources that supply a System-Level reference of S0 or S1 are in the OFF state.\n\u2022       Devices states are compatible with the current Power Resource states. Only devices that solely reference Power Resources that are in the ON state for a given device state can be in that device state. In all other cases, the device is in the D3 (off) state.\n\u2022       Devices that are enabled to wake the system and that can do so from their current device state can initiate a hardware event that transitions the system state to S0. This transition causes the processor to begin execution at its boot location. The platform runtime firmware performs initialization of core functions as needed to exit an S2 state and passes control to the firmware resume vector. See Section for more details on platform firmware initialization.\nBecause the processor context can be lost while in the S2 state, the transition to the S2 state requires that the operating software flush all dirty cache to dynamic RAM (DRAM).\n7.System \\_S3 State\nThe S3 state is logically deeper than the S2 state and is assumed to conserve more power. The behavior of this state is defined as follows:\n\u2022       The processors are not executing instructions. The processor-complex context is not maintained.\n\u2022       Dynamic RAM context is maintained.\n\u2022       Power Resources are in a state compatible with the system S3 state. All Power Resources that supply a System-Level reference of S0, S1, or S2 are in the OFF state.\n\u2022       Devices states are compatible with the current Power Resource states. Only devices that solely reference Power Resources that are in the ON state for a given device state can be in that device state. In all other cases, the device is in the D3 (off) state.\n\u2022       Devices that are enabled to wake the system and that can do so from their current device state can initiate a hardware event that transitions the system state to S0. This transition causes the processor to begin execution at its boot location. The platform runtime firmware performs initialization of core functions as necessary to exit an S3 state and passes control to the firmware resume vector. See Section for more details on platform firmware initialization.\nFrom the software viewpoint, this state is functionally the same as the S2 state. The operational difference can be that some Power Resources that could be left ON to be in the S2 state might not be available to the S3 state. As such, additional devices may need to be in a deeper state for S3 than S2. Similarly, some device wake events can function in S2 but not S3.\nBecause the processor context can be lost while in the S3 state, the transition to the S3 state requires that the operating software flush all dirty cache to DRAM.\n7.System \\_S4 State\nWhile the system is in this state, it is in the system S4 sleeping state. The state is logically deeper than the S3 state and is assumed to conserve more power. The behavior of this state is defined as follows:\n\u2022       The processors are not executing instructions. The processor-complex context is not maintained.\n\u2022       DRAM context is not maintained.\n\u2022       Power Resources are in a state compatible with the system S4 state. All Power Resources that supply a System-Level reference of S0, S1, S2, or S3 are in the OFF state.\n\u2022       Devices states are compatible with the current Power Resource states. In other words, all devices are in the D3 state when the system state is S4.\n\u2022       Devices that are enabled to wake the system and that can do so from their device state in S4 can initiate a hardware event that transitions the system state to S0. This transition causes the processor to begin execution at its boot location.\nAfter OSPM has executed the _PTS control method and has put the entire system state into main memory, there are two ways that OSPM may handle the next phase of the S4 state transition; saving and restoring main memory. The first way is to use the operating system's drivers to access the disks and file system structures to save a copy of memory to disk and then initiate the hardware S4 sequence by setting the SLP_EN register bit. When the system wakes, the firmware performs a normal boot process and transfers control to the OS via the firmware_waking_vector loader. The OS then restores the system's memory and resumes execution.\nThe alternate method for entering the S4 state is to utilize the platform runtime firmware via the S4BIOS transition. The platform runtime firmware uses firmware to save a copy of memory to disk and then initiates the hardware S4 sequence. When the system wakes, the firmware restores memory from disk and wakes OSPM by transferring control to the FACS waking vector.\nThe S4BIOS transition is optional, but any system that supports this mechanism must support entering the S4 state via the direct OS mechanism. Thus the preferred mechanism for S4 support is the direct OS mechanism as it provides broader platform support. The alternate S4BIOS transition provides a way to achieve S4 support on operating systems that do not have support for the direct method.\n7.System \\_S5 State (Soft Off)\n The S5 state is similar to the S4 state except that OSPM does not save any context. The system is in the soft off state and requires a complete boot when awakened (platform boot firmware and OS). Software uses a different state value to distinguish between this state and the S4 state to allow for initial boot operations within the platform boot firmware to distinguish whether or not the boot is going to wake from a saved memory image. OSPM does not disable wake events before setting the SLP_EN bit when entering the S5 system state. This provides support for remote management initiatives by enabling Remote Start capability. An ACPI-compliant OS must provide an end user accessible mechanism for disabling all wake devices, with the exception of the system power button, from a single point in the user interface.",
    "example": ""
  },
  {
    "title": "_ADR (Address)",
    "syntax": "",
    "arguments": "",
    "description": "This object is used to supply OSPM with the address of a device on its parent bus. An _ADR object must be used when specifying the address of any device on a bus that has a standard enumeration algorithm (see Section 3.7, \u201cConfiguration and Plug and Play\u201d, for the situations when these devices do appear in the ACPI namespace).",
    "example": ""
  },
  {
    "title": "_CID (Compatible ID)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object is used to supply OSPM with a device\u2019s Plug and Play-Compatible Device ID. Use _CID objects when a device has no other defined hardware standard method to report its compatible IDs.",
    "example": ""
  },
  {
    "title": "_CLS (Class Code)",
    "syntax": "",
    "arguments": "",
    "description": "This object is used to supply OSPM with the PCI-defined base-class, sub-class and programming interface for a device. This object is optional. However, it may be useful for loading generic drivers on hardware that is compatible with PCI -defined device classes, but that is not implemented on the PCI bus (and is therefore enumerated by ACPI.)",
    "example": ""
  },
  {
    "title": "_DDN (DOS Device Name)",
    "syntax": "",
    "arguments": "",
    "description": "This object is used to associate a logical name (for example, COM1) with a device. This name can be used by applications to connect to the device.",
    "example": ""
  },
  {
    "title": "_HID (Hardware ID)",
    "syntax": "",
    "arguments": "",
    "description": "This object is used to supply OSPM with the device\u2019s PNP ID or ACPI ID.[6]\n When describing a platform, use of any _HID objects is optional. However, a _HID object must be used to describe any device that will be enumerated by OSPM. OSPM only enumerates a device when no bus enumerator can detect the device ID. For example, devices on an ISA bus are enumerated by OSPM. Use the _ADR object to describe devices enumerated by bus enumerators other than OSPM.",
    "example": ""
  },
  {
    "title": "_HRV (Hardware Revision)",
    "syntax": "",
    "arguments": "",
    "description": "This object is used to supply OSPM with the device\u2019s hardware revision. The use of _HRV is optional.",
    "example": ""
  },
  {
    "title": "_MLS (Multiple Language String)",
    "syntax": "",
    "arguments": "",
    "description": "The _MLS object provides OSPM a human readable description of a device in multiple languages. This information may be provided to the end user when the OSPM is unable to get any other information about this device. Although this functionality is also provided by the _STR object, _MLS expands that functionality and provides vendors with the capability to provide multiple strings in multiple languages. The _MLS object evaluates to a package of packages. Each sub-package consists of a Language identifier and corresponding unicode string for a given locale. Specifying a language identifier allows OSPM to easily determine if support for displaying the Unicode string is available. OSPM can use this information to determine whether or not to display the device string, or which string is appropriate for a user\u2019s preferred locale.\nIt is assumed that OSPM will always support the primary English locale to accommodate English embedded in a non-English string, such as a brand name.\nIf OSPM doesn\u2019t support the specific sub-language ID it may choose to use the primary language ID for displaying device text.",
    "example": ""
  },
  {
    "title": "_PLD (Physical Location of Device)",
    "syntax": "",
    "arguments": "",
    "description": "This optional object is a method that conveys to OSPM a general description of the physical location of a device\u2019s external connection point. The _PLD may be child object for any ACPI Namespace object the system wants to describe. This information can be used by system software to describe to the user which specific connector or device input mechanism may be used for a given task or may need user intervention for correct operation. The _PLD should only be evaluated when its parent device is present as indicated by the device\u2019s presence mechanism (i.e. _STA or other)\nAn externally exposed device connection point can reside on any surface of a system\u2019s housing. The respective surfaces of a system\u2019s housing are identified by the \u201cPanel\u201d field (described below). The _PLD method returns data to describe the location of where the device\u2019s connection point resides and a Shape (described below) that may be rendered at that position. One physical device may have several connection points. A _PLD describes the offset and rotation of a single device connection point from an \u201corigin\u201d that resides in the lower left hand corner of its Panel.\nAll Panel references (Top, Bottom, Right, Left, etc.) are interpreted as though the user is facing the front of the system. For handheld mobile devices, the front panel is the one holding the display screen, and its origin is in the lower-left corner when the display is viewed in the Portrait orientation. For example, the Right Panel is the right side of the system as viewed from the front.\nAll \u201corigin\u201d references for a Panel are interpreted as its lower left corner when the user is facing the respective Panel. The Top Panel shall be viewed with the system is viewed resting on its Front Panel, and the Bottom Panel shall be viewed with the system resting on its Back Panel. All other Panels shall be viewed with the system resting on its Bottom Panel. Refer to Figure 6-29 for more information.\nFigure 6-29 System Panel and Panel Origin Positions\n The data bits also assume that if the system is capable of opening up like a laptop that the device may exist on the base of the laptop system or on the lid. In the case of the latter, the \u201cLid\u201d bit (described below) should be set indicating the device connection point is on the lid. If the device is on the lid, the description describes the device\u2019s connection point location when the system is opened with the lid up. If the device connection point is not on the lid, then the description describes the device\u2019s connection point location when the system with the lid closed.\nFigure 6-30 Laptop Panel and Panel Origin Positions\nTo render a view of a system Panel, all _PLDs that define the same Panel and Lid values are collected. The _PLDs are then sorted by the value of their Order field and the view of the panel is rendered by drawing the shapes of each connection point (in their correct Shape, Color, Horizontal Offset, Vertical Offset, Width, Height, and Orientation) starting with all Order = 0 _PLDs first. Refer to Figure 6-32 for an example.\nThe location of a device connection point may change as a result of the system connecting or disconnecting to a docking station or a port replicator. As such, Notify event of type 0x09 will cause OSPM to re-evaluate the _PLD object residing under the particular device notified. If a platform is unable to detect the change of connecting or disconnecting to a docking station or port replicator, a _PLD object should not be used to describe the device connection points that will change location after such an event.",
    "example": ""
  },
  {
    "title": "_SUB (Subsystem ID)",
    "syntax": "",
    "arguments": "",
    "description": "This object is used to supply OSPM with the device's Subsystem ID. The use of _SUB is optional.",
    "example": ""
  },
  {
    "title": "_STR (String)",
    "syntax": "",
    "arguments": "",
    "description": "The _STR object evaluates to a Unicode string that describes the device or thermal zone. It may be used by an OS to provide information to an end user. This information is particularly valuable when no other information is available.",
    "example": ""
  },
  {
    "title": "_SUN (Slot User Number)",
    "syntax": "",
    "arguments": "",
    "description": "_SUN is an object that evaluates to the slot-unique ID number for a slot. _SUN is used by OSPM UI to identify slots for the user. For example, this can be used for battery slots, PCI slots, PCMCIA slots, or swappable bay slots to inform the user of what devices are in each slot. _SUN evaluates to an integer that is the number to be used in the user interface.",
    "example": ""
  },
  {
    "title": "_GL (Global Lock Mutex)",
    "syntax": "",
    "arguments": "",
    "description": "This predefined object is a Mutex object that behaves like a Mutex as defined in Section 19.6.87, Mutex (Declare Synchronization/Mutex Object), with the added behavior that acquiring this Mutex also acquires the shared environment Global Lock defined in Section 5.2.10.1, Global Lock. This allows Control Methods to explicitly synchronize with the Global Lock if necessary.",
    "example": ""
  },
  {
    "title": " _OSI (Operating System Interfaces)",
    "syntax": "",
    "arguments": "",
    "description": "This method is used by the system firmware to query OSPM about interfaces and features that are supported by the host operating system. The usage and implementation model for this method is as follows:\n       The _OSI method is implemented within the operating system.\n       OSI is called by the firmware AML code, usually during initialization (such as via _INI method). Thus, _OSI is actually an up-call from the firmware AML to the OS  exactly the opposite of other control methods.\n       An _OSI invocation by the firmware is a request to the operating system: \"Do you support this interface/feature?\"\n       The host responds to this _OSI request with a simple yes or no (Ones/Zero, TRUE/FALSE, Supported/NotSupported)",
    "example": ""
  },
  {
    "title": "_OS (OS Name Object)",
    "syntax": "",
    "arguments": "",
    "description": "This predefined object evaluates to a string that identifies the operating system. In robust OSPM implementations, \\_OS evaluates differently for each OS release. This may allow AML code to accommodate differences in OSPM implementations. This value does not change with different revisions of the AML interpreter.",
    "example": ""
  },
  {
    "title": "_REV (Revision Data Object)",
    "syntax": "",
    "arguments": "",
    "description": "This predefined object evaluates to an Integer (DWORD) representing the revision of the ACPI Specification implemented by the specified \\_OS.",
    "example": ""
  },
  {
    "title": "_DLM (DeviceLock Mutex)",
    "syntax": "",
    "arguments": "",
    "description": "This object appears in a device scope when AML access to the device must be synchronized with the OS environment. It is used in conjunction with a standard Mutex object. With _DLM, the standard Mutex provides synchronization within the AML environment as usual, but also synchronizes with the OS environment.\n_DLM evaluates to a package of packages, each containing a reference to a Mutex and an optional resource template protected by the Mutex, If only the Mutex name is specified, then the sharing rules (i.e. which resources are protected by the lock) are defined by a predefined contract between the AML and the OS device driver. If the resource template is specified, then only those resources within the resource template are protected.",
    "example": ""
  },
  {
    "title": "_PIC Method",
    "syntax": "",
    "arguments": "",
    "description": "The \\_PIC optional method is used to report to the platform runtime firmware the current interrupt model used by the OS. This control method returns nothing. The argument passed into the method signifies the interrupt model OSPM has chosen, PIC mode, APIC mode, or SAPIC mode. Notice that calling this method is optional for OSPM. If the platform CPU architecture supports PIC mode and the method is never called, the platform runtime firmware must assume PIC mode. It is important that the platform runtime firmware save the value passed in by OSPM for later use during wake operations.",
    "example": ""
  },
  {
    "title": "_UID (Unique ID)",
    "syntax": "",
    "arguments": "",
    "description": "This object provides OSPM with a logical device ID that does not change across reboots. This object is optional, but is required when the device has no other way to report a persistent unique device ID. The _UID must be unique across all devices with either a common _HID or _CID. This is because a device needs to be uniquely identified to the OSPM, which may match on either a _HID or a _CID to identify the device. The uniqueness match must be true regardless of whether the OSPM uses the _HID or the _CID. OSPM typically uses the unique device ID to ensure that the device-specific information, such as network protocol binding information, is remembered for the device even if its relative location changes. For most integrated devices, this object contains a unique identifier.\nA _UID object evaluates to either a numeric value or a string.",
    "example": ""
  },
  {
    "title": "_GPE",
    "syntax": "",
    "arguments": "",
    "description": "General events in GPE register block.",
    "example": ""
  },
  {
    "title": "_PR",
    "syntax": "",
    "arguments": "",
    "description": "ACPI 1.0 Processor Namespace. ACPI 1.0 requires all Processor objects to be defined under this namespace. ACPI 2.0 and later allow Processor object definitions under the \\_SB namespace. Platforms may maintain the \\_PR namespace for compatibility with ACPI 1.0 operating systems, but it is otherwise deprecated. see the compatibility note in\nSection 5.2.12.12. An ACPI-compatible namespace may define Processor objects in either the \\_SB or \\_PR scope but not both.\nFor more information about defining Processor objects",
    "example": ""
  },
  {
    "title": "_SB",
    "syntax": "",
    "arguments": "",
    "description": "All Device/Bus Objects are defined under this namespace.",
    "example": ""
  },
  {
    "title": "_TZ",
    "syntax": "",
    "arguments": "",
    "description": "ACPI 1.0 Thermal Zone namespace. ACPI 1.0 requires all Thermal Zone objects to be defined under this namespace. Thermal Zone object definitions may now be defined under the \\_SB namespace. ACPI-compatible systems may maintain the \\_TZ namespace for compatibility with ACPI 1.0 operating systems. An ACPI-compatible namespace may define Thermal Zone objects in either the \\_SB or \\_TZ scope but not both.\nFor more information about defining Thermal Zone objects, see Section 11, Thermal Management.",
    "example": ""
  },
  {
    "title": "_SI",
    "syntax": "",
    "arguments": "",
    "description": "System indicator objects are defined under this namespace. For more information about defining system indicators, see Section 9.2, \\_SI System Indicators.",
    "example": ""
  },
  {
    "title": "_ACx",
    "syntax": "",
    "arguments": "",
    "description": "Active Cooling returns the active cooling policy threshold values.",
    "example": ""
  },
  {
    "title": "_ADR",
    "syntax": "",
    "arguments": "",
    "description": "Address  (1) returns the address of a device on its parent bus. \uf020 (2) returns a unique ID for the display output device.\uf020\n(3) resource descriptor field.",
    "example": ""
  },
  {
    "title": "_AEI",
    "syntax": "",
    "arguments": "",
    "description": "Designates those GPIO interrupts that shall be handled by OSPM as ACPI events",
    "example": ""
  },
  {
    "title": "_ALC",
    "syntax": "",
    "arguments": "",
    "description": "Ambient Light Chromaticity returns the ambient light color chromaticity.\nHeading  ",
    "example": ""
  },
  {
    "title": "_ALI",
    "syntax": "",
    "arguments": "",
    "description": "Ambient Light Illuminance returns the ambient light brightness.",
    "example": ""
  },
  {
    "title": "_ALN",
    "syntax": "",
    "arguments": "",
    "description": "Alignment base alignment, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_ALP",
    "syntax": "",
    "arguments": "",
    "description": "Ambient Light Polling returns the ambient light sensor polling frequency.",
    "example": ""
  },
  {
    "title": "_ALR",
    "syntax": "",
    "arguments": "",
    "description": "Ambient Light Response returns the ambient light brightness to display brightness mappings.",
    "example": ""
  },
  {
    "title": "_ALT",
    "syntax": "",
    "arguments": "",
    "description": "Ambient Light Temperature returns the ambient light color temperature.",
    "example": ""
  },
  {
    "title": "_ALx",
    "syntax": "",
    "arguments": "",
    "description": "Active List returns a list of active cooling device objects.",
    "example": ""
  },
  {
    "title": "_ART",
    "syntax": "",
    "arguments": "",
    "description": "Active cooling Relationship Table returns thermal relationship information between platform devices and fan devices.",
    "example": ""
  },
  {
    "title": "_ASI",
    "syntax": "",
    "arguments": "",
    "description": "Address Space Id resource descriptor field.",
    "example": ""
  },
  {
    "title": "_ASZ",
    "syntax": "",
    "arguments": "",
    "description": "Access Size resource descriptor field.",
    "example": ""
  },
  {
    "title": "_ATT",
    "syntax": "",
    "arguments": "",
    "description": "Type-Specific Attribute resource descriptor field.",
    "example": ""
  },
  {
    "title": "_BAS",
    "syntax": "",
    "arguments": "",
    "description": "Base Address range base address, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_BBN",
    "syntax": "",
    "arguments": "",
    "description": "Bios Bus Number returns the PCI bus number returned by the platform firmware.",
    "example": ""
  },
  {
    "title": "_BCL",
    "syntax": "",
    "arguments": "",
    "description": "Brightness Control Levels returns a list of supported brightness control levels.",
    "example": ""
  },
  {
    "title": "_BCM",
    "syntax": "",
    "arguments": "",
    "description": "Brightness Control Method sets the brightness level of the display device.",
    "example": ""
  },
  {
    "title": "_BCT",
    "syntax": "",
    "arguments": "",
    "description": "Battery Charge Time returns time remaining to complete charging battery.",
    "example": ""
  },
  {
    "title": "_BDN",
    "syntax": "",
    "arguments": "",
    "description": "Bios Dock Name returns the Dock ID returned by the platform firmware.",
    "example": ""
  },
  {
    "title": "_BIF",
    "syntax": "",
    "arguments": "",
    "description": "Battery Information returns a Control Method Battery information block.",
    "example": ""
  },
  {
    "title": "_BIX",
    "syntax": "",
    "arguments": "",
    "description": "Battery Information Extended returns a Control Method Battery extended information block.",
    "example": ""
  },
  {
    "title": "_BLT",
    "syntax": "",
    "arguments": "",
    "description": "Battery Level Threshold set battery level threshold preferences.",
    "example": ""
  },
  {
    "title": "_BM",
    "syntax": "",
    "arguments": "",
    "description": "Bus Master resource descriptor field.",
    "example": ""
  },
  {
    "title": "_BMA",
    "syntax": "",
    "arguments": "",
    "description": "Battery Measurement Averaging Interval Sets battery measurement averaging interval.",
    "example": ""
  },
  {
    "title": "_BMC",
    "syntax": "",
    "arguments": "",
    "description": "Battery Maintenance Control Sets battery maintenance and control features.",
    "example": ""
  },
  {
    "title": "_BMD",
    "syntax": "",
    "arguments": "",
    "description": "Battery Maintenance Data returns battery maintenance, control, and state data.",
    "example": ""
  },
  {
    "title": "_BMS",
    "syntax": "",
    "arguments": "",
    "description": "Battery Measurement Sampling Time Sets the battery measurement sampling time.",
    "example": ""
  },
  {
    "title": "_BQC",
    "syntax": "",
    "arguments": "",
    "description": "Brightness Query Current returns the current display brightness level.",
    "example": ""
  },
  {
    "title": "_BST",
    "syntax": "",
    "arguments": "",
    "description": "Battery Status returns a Control Method Battery status block.\nHeading  ",
    "example": ""
  },
  {
    "title": "_BTH",
    "syntax": "",
    "arguments": "",
    "description": "Battery Throttle Limit - specifies the thermal throttle limit of battery for the firmware when engaging charging.",
    "example": ""
  },
  {
    "title": "_BTM",
    "syntax": "",
    "arguments": "",
    "description": "Battery Time returns the battery runtime.",
    "example": ""
  },
  {
    "title": "_BTP",
    "syntax": "",
    "arguments": "",
    "description": "Battery Trip Point sets a Control Method Battery trip point.",
    "example": ""
  },
  {
    "title": "_CBA",
    "syntax": "",
    "arguments": "",
    "description": "Configuration Base Address sets the CBA for a PCI Express host bridge. See the PCI Firmware Specification, Revision 3.0 at \u201cLinks to ACPI-Related Documents\u201d (http://uefi.org/acpi) under the heading \"PCI Sig\".\n ",
    "example": ""
  },
  {
    "title": "_CCA",
    "syntax": "",
    "arguments": "",
    "description": "Cache Coherency Attribute -- specifies whether a device and its descendants support hardware managed cache coherency.",
    "example": ""
  },
  {
    "title": "_CDM",
    "syntax": "",
    "arguments": "",
    "description": "Clock Domain returns a logical processor\u2019s clock domain identifier.",
    "example": ""
  },
  {
    "title": "_CID",
    "syntax": "",
    "arguments": "",
    "description": "Compatible ID returns a device\u2019s Plug and Play Compatible ID list.",
    "example": ""
  },
  {
    "title": "_CLS",
    "syntax": "",
    "arguments": "",
    "description": "Class Code supplies OSPM with the PCI-defined class, subclass and programming interface for a device. Optional.",
    "example": ""
  },
  {
    "title": "_CPC",
    "syntax": "",
    "arguments": "",
    "description": "Continuous Performance Control declares an interface that allows OSPM to transition the processor into a performance state based on a continuous range of allowable values.",
    "example": ""
  },
  {
    "title": "_CRS",
    "syntax": "",
    "arguments": "",
    "description": "Current Resource Settings returns the current resource settings for a device.",
    "example": ""
  },
  {
    "title": "_CRT",
    "syntax": "",
    "arguments": "",
    "description": "Critical Temperature returns the shutdown critical temperature.",
    "example": ""
  },
  {
    "title": "_CSD",
    "syntax": "",
    "arguments": "",
    "description": "C State Dependencies returns a list of C-state dependencies.",
    "example": ""
  },
  {
    "title": "_CST",
    "syntax": "",
    "arguments": "",
    "description": "C States returns a list of supported C-states.",
    "example": ""
  },
  {
    "title": "_CWS",
    "syntax": "",
    "arguments": "",
    "description": "Clear Wake Status Clears the wake status of a Time and Alarm Control Method Device.",
    "example": ""
  },
  {
    "title": "_DBT",
    "syntax": "",
    "arguments": "",
    "description": "Debounce Timeout -Debounce timeout setting for a GPIO input connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_DCK",
    "syntax": "",
    "arguments": "",
    "description": "Dock sets docking isolation. Presence indicates device is a docking station.",
    "example": ""
  },
  {
    "title": "_DCS",
    "syntax": "",
    "arguments": "",
    "description": "Display Current Status returns status of the display output device.",
    "example": ""
  },
  {
    "title": "_DDC",
    "syntax": "",
    "arguments": "",
    "description": "Display Data Current returns the EDID for the display output device.",
    "example": ""
  },
  {
    "title": "_DDN",
    "syntax": "",
    "arguments": "",
    "description": "Dos Device Name returns a device logical name.",
    "example": ""
  },
  {
    "title": "_DEC",
    "syntax": "",
    "arguments": "",
    "description": "Decode device decoding type, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_DEP",
    "syntax": "",
    "arguments": "",
    "description": "Operation Region Dependencies -- evaluates to a package and designates device objects that OSPM should assign a higher priority in start ordering due to future operation region accesses.",
    "example": ""
  },
  {
    "title": "_DGS",
    "syntax": "",
    "arguments": "",
    "description": "Display Graphics State returns the current state of the output device.",
    "example": ""
  },
  {
    "title": "_DIS",
    "syntax": "",
    "arguments": "",
    "description": "Disable disables a device.",
    "example": ""
  },
  {
    "title": "_DLM",
    "syntax": "",
    "arguments": "",
    "description": "Device Lock Mutex- Designates a mutex as a Device Lock",
    "example": ""
  },
  {
    "title": "_DMA",
    "syntax": "",
    "arguments": "",
    "description": "Direct Memory Access returns a device\u2019s current resources for DMA transactions.\nHeading  ",
    "example": ""
  },
  {
    "title": "_DOD",
    "syntax": "",
    "arguments": "",
    "description": "Display Output Devices enumerate all devices attached to the display adapter.",
    "example": ""
  },
  {
    "title": "_DOS",
    "syntax": "",
    "arguments": "",
    "description": "Disable Output Switching sets the display output switching mode.",
    "example": ""
  },
  {
    "title": "_DPL",
    "syntax": "",
    "arguments": "",
    "description": "Device Selection Polarity - The polarity of the Device Selection signal on a SPISerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_DRS",
    "syntax": "",
    "arguments": "",
    "description": "Drive Strength Drive strength setting for a GPIO output connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_DSD",
    "syntax": "",
    "arguments": "",
    "description": "Device Specific Datareturns device-specific information.",
    "example": ""
  },
  {
    "title": "_DSM",
    "syntax": "",
    "arguments": "",
    "description": "Device Specific Method executes device-specific functions.",
    "example": ""
  },
  {
    "title": "_DSS",
    "syntax": "",
    "arguments": "",
    "description": "Device Set State sets the display device state.",
    "example": ""
  },
  {
    "title": "_DSW",
    "syntax": "",
    "arguments": "",
    "description": "Device Sleep Wake sets the sleep and wake transition states for a device.",
    "example": ""
  },
  {
    "title": "_DTI",
    "syntax": "",
    "arguments": "",
    "description": "Device Temperature Indication conveys native device temperature to the platform.",
    "example": ""
  },
  {
    "title": "_Exx",
    "syntax": "",
    "arguments": "",
    "description": "Edge GPE method executed as a result of a general-purpose event.",
    "example": ""
  },
  {
    "title": "_EC",
    "syntax": "",
    "arguments": "",
    "description": "Embedded Controller returns EC offset and query information.",
    "example": ""
  },
  {
    "title": "_EDL",
    "syntax": "",
    "arguments": "",
    "description": "Eject Device List returns a list of devices that are dependent on a device (docking).",
    "example": ""
  },
  {
    "title": "_EJD",
    "syntax": "",
    "arguments": "",
    "description": "Ejection Dependent Device returns the name of dependent (parent) device (docking).",
    "example": ""
  },
  {
    "title": "_EJx",
    "syntax": "",
    "arguments": "",
    "description": "Eject begin or cancel a device ejection request (docking).",
    "example": ""
  },
  {
    "title": "_END",
    "syntax": "",
    "arguments": "",
    "description": "Endian-ness Endian orientation of a UART SerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_EVT",
    "syntax": "",
    "arguments": "",
    "description": "Event Method - Event method for GPIO-signaled events numbered larger than 255.",
    "example": ""
  },
  {
    "title": "_FDE",
    "syntax": "",
    "arguments": "",
    "description": "Floppy Disk Enumerate returns floppy disk configuration information.",
    "example": ""
  },
  {
    "title": "_FDI",
    "syntax": "",
    "arguments": "",
    "description": "Floppy Drive Information returns a floppy drive information block.",
    "example": ""
  },
  {
    "title": "_FDM",
    "syntax": "",
    "arguments": "",
    "description": "Floppy Drive Mode sets a floppy drive speed.",
    "example": ""
  },
  {
    "title": "_FIF",
    "syntax": "",
    "arguments": "",
    "description": "Fan Information returns fan device information.",
    "example": ""
  },
  {
    "title": "_FIT",
    "syntax": "",
    "arguments": "",
    "description": "Firmware Interface Table - returns a list of NFIT Structures.",
    "example": ""
  },
  {
    "title": "_FIX",
    "syntax": "",
    "arguments": "",
    "description": "Fixed Register Resource Provider returns a list of devices that implement FADT register blocks.",
    "example": ""
  },
  {
    "title": "_FLC",
    "syntax": "",
    "arguments": "",
    "description": "Flow Control Flow Control mechanism for a UART SerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_FPS",
    "syntax": "",
    "arguments": "",
    "description": "Fan Performance States returns a list of supported fan performance states.",
    "example": ""
  },
  {
    "title": "_FSL",
    "syntax": "",
    "arguments": "",
    "description": "Fan Set Level Control method that sets the fan device\u2019s speed level (performance state).\nHeading  ",
    "example": ""
  },
  {
    "title": "_FST",
    "syntax": "",
    "arguments": "",
    "description": "Fan Status returns current status information for a fan device.",
    "example": ""
  },
  {
    "title": "_GAI",
    "syntax": "",
    "arguments": "",
    "description": "Get Averaging Interval returns the power meter averaging interval.",
    "example": ""
  },
  {
    "title": "_GCP",
    "syntax": "",
    "arguments": "",
    "description": " Get Capabilities Returns the capabilities of a Time and Alarm Control Method Device",
    "example": ""
  },
  {
    "title": "_GHL",
    "syntax": "",
    "arguments": "",
    "description": "Get Hardware Limit returns the hardware limit enforced by the power meter.",
    "example": ""
  },
  {
    "title": "_GL",
    "syntax": "",
    "arguments": "",
    "description": "Global Lock OS-defined Global Lock mutex object.",
    "example": ""
  },
  {
    "title": "_GLK",
    "syntax": "",
    "arguments": "",
    "description": "Global Lock returns a device\u2019s Global Lock requirement for device access.",
    "example": ""
  },
  {
    "title": "_GPD",
    "syntax": "",
    "arguments": "",
    "description": "Get Post Data returns the value of the VGA device that will be posted at boot.",
    "example": ""
  },
  {
    "title": "_GPE",
    "syntax": "",
    "arguments": "",
    "description": "General Purpose Events (1) predefined Scope (\\_GPE.)\uf020\n(2) Returns the SCI interrupt associated with the Embedded Controller.",
    "example": ""
  },
  {
    "title": "_GRA",
    "syntax": "",
    "arguments": "",
    "description": "Granularity address space granularity, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_GRT",
    "syntax": "",
    "arguments": "",
    "description": " Get Real Time Returns the current time from a Time and Alarm Control Method Device.",
    "example": ""
  },
  {
    "title": "_GSB",
    "syntax": "",
    "arguments": "",
    "description": "Global System Interrupt Base returns the GSB for a I/O APIC device.",
    "example": ""
  },
  {
    "title": "_GTF",
    "syntax": "",
    "arguments": "",
    "description": "Get Task File returns a list of ATA commands to restore a drive to default state.",
    "example": ""
  },
  {
    "title": "_GTM",
    "syntax": "",
    "arguments": "",
    "description": "Get Timing Mode returns a list of IDE controller timing information.",
    "example": ""
  },
  {
    "title": "_GWS",
    "syntax": "",
    "arguments": "",
    "description": "Get Wake Status Gets the wake status of a Time and Alarm Control Method Device.",
    "example": ""
  },
  {
    "title": "_HE",
    "syntax": "",
    "arguments": "",
    "description": "High-Edge interrupt triggering, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_HID",
    "syntax": "",
    "arguments": "",
    "description": "Hardware ID returns a device\u2019s Plug and Play Hardware ID.",
    "example": ""
  },
  {
    "title": "_HMA",
    "syntax": "",
    "arguments": "",
    "description": "Heterogeneous Memory Attributes - returns a list of HMAT structures.",
    "example": ""
  },
  {
    "title": "_HOT",
    "syntax": "",
    "arguments": "",
    "description": "Hot Temperature returns the critical temperature for sleep (entry to S4).",
    "example": ""
  },
  {
    "title": "_HPP",
    "syntax": "",
    "arguments": "",
    "description": "Hot Plug Parameters returns a list of hot-plug information for a PCI device.",
    "example": ""
  },
  {
    "title": "_HPX",
    "syntax": "",
    "arguments": "",
    "description": "Hot Plug Parameter Extensions returns a list of hot-plug information for a PCI device. Supersedes _HPP.",
    "example": ""
  },
  {
    "title": "_HRV",
    "syntax": "",
    "arguments": "",
    "description": "Hardware Revisionsupplies OSPM with the device\u2019s hardware revision. Optional",
    "example": ""
  },
  {
    "title": "_IFT",
    "syntax": "",
    "arguments": "",
    "description": "IPMI Interface Type. See the Intelligent Platform Management Interface Specification at \u201cLinks to ACPI-Related Documents\u201d (http://uefi.org/acpi) under the heading \"Server Platform Management Interface Table\".",
    "example": ""
  },
  {
    "title": "_INI",
    "syntax": "",
    "arguments": "",
    "description": "Initialize performs device specific initialization.",
    "example": ""
  },
  {
    "title": "_INT",
    "syntax": "",
    "arguments": "",
    "description": "Interrupts interrupt mask bits, resource descriptor field.\nHeading  ",
    "example": ""
  },
  {
    "title": "_IOR",
    "syntax": "",
    "arguments": "",
    "description": "IO Restriction IO restriction setting for a GPIO IO connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_IRC",
    "syntax": "",
    "arguments": "",
    "description": "Inrush Current presence indicates that a device has a significant inrush current draw.",
    "example": ""
  },
  {
    "title": "_Lxx",
    "syntax": "",
    "arguments": "",
    "description": "Level GPE Control method executed as a result of a general-purpose event.",
    "example": ""
  },
  {
    "title": "_LCK",
    "syntax": "",
    "arguments": "",
    "description": "Lock locks or unlocks a device (docking).",
    "example": ""
  },
  {
    "title": "_LEN",
    "syntax": "",
    "arguments": "",
    "description": "Length range length, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_LID",
    "syntax": "",
    "arguments": "",
    "description": "Lid returns the open/closed status of the lid on a mobile system.",
    "example": ""
  },
  {
    "title": "_LIN",
    "syntax": "",
    "arguments": "",
    "description": "Lines in Use - Handshake lines in use in a UART SerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_LL",
    "syntax": "",
    "arguments": "",
    "description": "Low Level interrupt polarity, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_LPI",
    "syntax": "",
    "arguments": "",
    "description": "Low Power Idle States returns the list of low power idle states supported by a processor or processor container.",
    "example": ""
  },
  {
    "title": "_LSI",
    "syntax": "",
    "arguments": "",
    "description": "Label Storage Information Returns information about the Label Storage Area associated with the NVDIMM object, including its size.",
    "example": ""
  },
  {
    "title": "_LSR",
    "syntax": "",
    "arguments": "",
    "description": "Label Storage Read Returns label data from the Label Storage Area of the NVDIMM object.",
    "example": ""
  },
  {
    "title": "_LSW",
    "syntax": "",
    "arguments": "",
    "description": "Label Storage Write Writes label data in to the Label Storage Area of the NVDIMM object.",
    "example": ""
  },
  {
    "title": "_MAF",
    "syntax": "",
    "arguments": "",
    "description": "Maximum Address Fixed resource descriptor field.",
    "example": ""
  },
  {
    "title": "_MAT",
    "syntax": "",
    "arguments": "",
    "description": "Multiple Apic Table Entry returns a list of Interrupt Controller Structures.",
    "example": ""
  },
  {
    "title": "_MAX",
    "syntax": "",
    "arguments": "",
    "description": "Maximum Base Address resource descriptor field.",
    "example": ""
  },
  {
    "title": "_MBM",
    "syntax": "",
    "arguments": "",
    "description": "Memory Bandwidth Monitoring Data returns bandwidth monitoring data for a memory device.",
    "example": ""
  },
  {
    "title": "_MEM",
    "syntax": "",
    "arguments": "",
    "description": "Memory Attributes resource descriptor field.",
    "example": ""
  },
  {
    "title": "_MIF",
    "syntax": "",
    "arguments": "",
    "description": "Minimum Address Fixed resource descriptor field.",
    "example": ""
  },
  {
    "title": "_MIN",
    "syntax": "",
    "arguments": "",
    "description": "Minimum Base Address resource descriptor field.",
    "example": ""
  },
  {
    "title": "_MLS",
    "syntax": "",
    "arguments": "",
    "description": "Multiple Language String returns a device description in multiple languages.",
    "example": ""
  },
  {
    "title": "_MOD",
    "syntax": "",
    "arguments": "",
    "description": "Mode \u2013Resource descriptor field",
    "example": ""
  },
  {
    "title": "_MSG",
    "syntax": "",
    "arguments": "",
    "description": "Message sets the system message waiting status indicator.",
    "example": ""
  },
  {
    "title": "_MSM",
    "syntax": "",
    "arguments": "",
    "description": "Memory Set Monitoring sets bandwidth monitoring parameters for a memory device.",
    "example": ""
  },
  {
    "title": "_MTL",
    "syntax": "",
    "arguments": "",
    "description": "Minimum Throttle Limit returns the minimum throttle limit of a specific thermal",
    "example": ""
  },
  {
    "title": "_MTP",
    "syntax": "",
    "arguments": "",
    "description": "Memory Type resource descriptor field.\nHeading  ",
    "example": ""
  },
  {
    "title": "_NTT",
    "syntax": "",
    "arguments": "",
    "description": "Notification Temperature Threshold returns a threshold for device temperature change that requires platform notification.",
    "example": ""
  },
  {
    "title": "_OFF",
    "syntax": "",
    "arguments": "",
    "description": "Off sets a power resource to the off state.",
    "example": ""
  },
  {
    "title": "_ON",
    "syntax": "",
    "arguments": "",
    "description": "On sets a power resource to the on state.",
    "example": ""
  },
  {
    "title": "_OS",
    "syntax": "",
    "arguments": "",
    "description": "Operating System returns a string that identifies the operating system.",
    "example": ""
  },
  {
    "title": "_OSC",
    "syntax": "",
    "arguments": "",
    "description": "Operating System Capabilities inform AML of host features and capabilities.",
    "example": ""
  },
  {
    "title": "_OSI",
    "syntax": "",
    "arguments": "",
    "description": "Operating System Interfaces returns supported interfaces, behaviors, and features.",
    "example": ""
  },
  {
    "title": "_OST",
    "syntax": "",
    "arguments": "",
    "description": "Ospm Status Indication inform AML of event processing status.",
    "example": ""
  },
  {
    "title": "_PAI",
    "syntax": "",
    "arguments": "",
    "description": "Power Averaging Interval sets the averaging interval for a power meter.",
    "example": ""
  },
  {
    "title": "_PAR",
    "syntax": "",
    "arguments": "",
    "description": "Parity Parity for a UART SerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_PCL",
    "syntax": "",
    "arguments": "",
    "description": "Power Consumer List returns a list of devices powered by a power source.",
    "example": ""
  },
  {
    "title": "_PCT",
    "syntax": "",
    "arguments": "",
    "description": "Performance Control returns processor performance control and status registers.",
    "example": ""
  },
  {
    "title": "_PDC",
    "syntax": "",
    "arguments": "",
    "description": "Processor Driver Capabilities inform AML of processor driver capabilities.",
    "example": ""
  },
  {
    "title": "_PDL",
    "syntax": "",
    "arguments": "",
    "description": "P-state Depth Limit returns the lowest available performance P-state.",
    "example": ""
  },
  {
    "title": "_PHA",
    "syntax": "",
    "arguments": "",
    "description": "Clock Phase Clock phase for a SPISerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_PIC",
    "syntax": "",
    "arguments": "",
    "description": "PIC inform AML of the interrupt model in use.",
    "example": ""
  },
  {
    "title": "_PIF",
    "syntax": "",
    "arguments": "",
    "description": "Power Source Information returns a Power Source information block.",
    "example": ""
  },
  {
    "title": "_PIN",
    "syntax": "",
    "arguments": "",
    "description": " Pin List List of GPIO pins described, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_PLD",
    "syntax": "",
    "arguments": "",
    "description": "Physical Location of Device  returns a device\u2019s physical location information.",
    "example": ""
  },
  {
    "title": "_PMC",
    "syntax": "",
    "arguments": "",
    "description": "Power Meter Capabilities returns a list of Power Meter capabilities info.",
    "example": ""
  },
  {
    "title": "_PMD",
    "syntax": "",
    "arguments": "",
    "description": "Power Metered Devices returns a list of devices that are measured by the power meter device.",
    "example": ""
  },
  {
    "title": "_PMM",
    "syntax": "",
    "arguments": "",
    "description": "Power Meter Measurement returns the current value of the Power Meter.",
    "example": ""
  },
  {
    "title": "_POL",
    "syntax": "",
    "arguments": "",
    "description": "Polarity Resource descriptor field",
    "example": ""
  },
  {
    "title": "_PPC",
    "syntax": "",
    "arguments": "",
    "description": "Performance Present Capabilites returns a list of the performance states currently supported by the platform.",
    "example": ""
  },
  {
    "title": "_PPE",
    "syntax": "",
    "arguments": "",
    "description": "Polling for Platform Error returns the polling interval to retrieve Corrected Platform Error information.",
    "example": ""
  },
  {
    "title": "_PPI",
    "syntax": "",
    "arguments": "",
    "description": "Pin Configuration Pin configuration for a GPIO connection, resource descriptor field\nHeading  ",
    "example": ""
  },
  {
    "title": "_PR",
    "syntax": "",
    "arguments": "",
    "description": "Processor predefined scope for processor objects.",
    "example": ""
  },
  {
    "title": "_PR0",
    "syntax": "",
    "arguments": "",
    "description": "Power Resources for D0 returns a list of dependent power resources to enter state D0 (fully on).",
    "example": ""
  },
  {
    "title": "_PR1",
    "syntax": "",
    "arguments": "",
    "description": "Power Resources for D1 returns a list of dependent power resources to enter state D1.",
    "example": ""
  },
  {
    "title": "_PR2",
    "syntax": "",
    "arguments": "",
    "description": "Power Resources for D2 returns a list of dependent power resources to enter state D2.",
    "example": ""
  },
  {
    "title": "_PR3",
    "syntax": "",
    "arguments": "",
    "description": "Power Resources for D3hot returns a list of dependent power resources to enter state D3hot.",
    "example": ""
  },
  {
    "title": "_PRE",
    "syntax": "",
    "arguments": "",
    "description": "Power Resources for Enumeration - Returns a list of dependent power resources to enumerate devices on a bus.",
    "example": ""
  },
  {
    "title": "_PRL",
    "syntax": "",
    "arguments": "",
    "description": "Power Source Redundancy List returns a list of power source devices in the same redundancy grouping.",
    "example": ""
  },
  {
    "title": "_PRR",
    "syntax": "",
    "arguments": "",
    "description": "Power Resource for Reset executes a reset on the associated device or devices.",
    "example": ""
  },
  {
    "title": "_PRS",
    "syntax": "",
    "arguments": "",
    "description": "Possible Resource Settings returns a list of a device\u2019s possible resource settings.",
    "example": ""
  },
  {
    "title": "_PRT",
    "syntax": "",
    "arguments": "",
    "description": "Pci Routing Table returns a list of PCI interrupt mappings.",
    "example": ""
  },
  {
    "title": "_PRW",
    "syntax": "",
    "arguments": "",
    "description": "Power Resources for Wake returns a list of dependent power resources for waking.",
    "example": ""
  },
  {
    "title": "_PS0",
    "syntax": "",
    "arguments": "",
    "description": "Power State 0 sets a device\u2019s power state to D0 (device fully on).",
    "example": ""
  },
  {
    "title": "_PS1",
    "syntax": "",
    "arguments": "",
    "description": "Power State 1 sets a device\u2019s power state to D1.",
    "example": ""
  },
  {
    "title": "_PS2",
    "syntax": "",
    "arguments": "",
    "description": "Power State 2 sets a device\u2019s power state to D2.",
    "example": ""
  },
  {
    "title": "_PS3",
    "syntax": "",
    "arguments": "",
    "description": "Power State 3 sets a device\u2019s power state to D3 (device off).",
    "example": ""
  },
  {
    "title": "_PSC",
    "syntax": "",
    "arguments": "",
    "description": "Power State Current returns a device\u2019s current power state.",
    "example": ""
  },
  {
    "title": "_PSD",
    "syntax": "",
    "arguments": "",
    "description": "Power State Dependencies returns processor P-State dependencies.",
    "example": ""
  },
  {
    "title": "_PSE",
    "syntax": "",
    "arguments": "",
    "description": "Power State for Enumeration",
    "example": ""
  },
  {
    "title": "_PSL",
    "syntax": "",
    "arguments": "",
    "description": "Passive List returns a list of passive cooling device objects.",
    "example": ""
  },
  {
    "title": "_PSR",
    "syntax": "",
    "arguments": "",
    "description": "Power Source returns the power source device currently in use.",
    "example": ""
  },
  {
    "title": "_PSS",
    "syntax": "",
    "arguments": "",
    "description": "Performance Supported States returns a list of supported processor performance states.",
    "example": ""
  },
  {
    "title": "_PSV",
    "syntax": "",
    "arguments": "",
    "description": "Passive returns the passive trip point temperature.",
    "example": ""
  },
  {
    "title": "_PSW",
    "syntax": "",
    "arguments": "",
    "description": "Power State Wake sets a device\u2019s wake function.",
    "example": ""
  },
  {
    "title": "_PTC",
    "syntax": "",
    "arguments": "",
    "description": "Processor Throttling Control returns throttling control and status registers.",
    "example": ""
  },
  {
    "title": "_PTP",
    "syntax": "",
    "arguments": "",
    "description": "Power Trip Points sets trip points for the Power Meter device.",
    "example": ""
  },
  {
    "title": "_PTS",
    "syntax": "",
    "arguments": "",
    "description": "Prepare To Sleep inform the platform of an impending sleep transition.\nHeading  ",
    "example": ""
  },
  {
    "title": "_PUR",
    "syntax": "",
    "arguments": "",
    "description": "Processor Utilization Request returns the number of processors that the platform would like to idle.",
    "example": ""
  },
  {
    "title": "_PXM",
    "syntax": "",
    "arguments": "",
    "description": "Proximity returns a device\u2019s proximity domain identifier.",
    "example": ""
  },
  {
    "title": "_Qxx",
    "syntax": "",
    "arguments": "",
    "description": "Query Embedded Controller query and SMBus Alarm control method.",
    "example": ""
  },
  {
    "title": "_RBO",
    "syntax": "",
    "arguments": "",
    "description": "Register Bit Offset resource descriptor field.",
    "example": ""
  },
  {
    "title": "_RBW",
    "syntax": "",
    "arguments": "",
    "description": "Register Bit Width resource descriptor field.",
    "example": ""
  },
  {
    "title": "_RDI",
    "syntax": "",
    "arguments": "",
    "description": "Resource Dependencies for Idle - returns the list of power resource dependencies for system level low power idle states.",
    "example": ""
  },
  {
    "title": "_REG",
    "syntax": "",
    "arguments": "",
    "description": "Region inform AML code of an operation region availability change.",
    "example": ""
  },
  {
    "title": "_REV",
    "syntax": "",
    "arguments": "",
    "description": "Revision returns the revision of the ACPI specification that is implemented.",
    "example": ""
  },
  {
    "title": "_RMV",
    "syntax": "",
    "arguments": "",
    "description": "Remove returns a device\u2019s removal ability status (docking).",
    "example": ""
  },
  {
    "title": "_RNG",
    "syntax": "",
    "arguments": "",
    "description": "Range memory range type, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_ROM",
    "syntax": "",
    "arguments": "",
    "description": "Read-Only Memory returns a copy of the ROM data for a display device.",
    "example": ""
  },
  {
    "title": "_RST",
    "syntax": "",
    "arguments": "",
    "description": "Device Reset   executes a reset on the associated device or devices.",
    "example": ""
  },
  {
    "title": "_RT",
    "syntax": "",
    "arguments": "",
    "description": "Resource Type resource descriptor field.",
    "example": ""
  },
  {
    "title": "_RTV",
    "syntax": "",
    "arguments": "",
    "description": "Relative Temperature Values returns temperature value information.",
    "example": ""
  },
  {
    "title": "_RW",
    "syntax": "",
    "arguments": "",
    "description": "Read-Write Status resource descriptor field.",
    "example": ""
  },
  {
    "title": "_RXL",
    "syntax": "",
    "arguments": "",
    "description": "Receive Buffer Size - Size of the receive buffer in a UART Serialbus connection, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_S0",
    "syntax": "",
    "arguments": "",
    "description": "S0 System State returns values to enter the system into the S0 state.",
    "example": ""
  },
  {
    "title": "_S1",
    "syntax": "",
    "arguments": "",
    "description": "S1 System State returns values to enter the system into the S1 state.",
    "example": ""
  },
  {
    "title": "_S2",
    "syntax": "",
    "arguments": "",
    "description": "S2 System State returns values to enter the system into the S2 state.",
    "example": ""
  },
  {
    "title": "_S3",
    "syntax": "",
    "arguments": "",
    "description": "S3 System State returns values to enter the system into the S3 state.",
    "example": ""
  },
  {
    "title": "_S4",
    "syntax": "",
    "arguments": "",
    "description": "S4 System State returns values to enter the system into the S4 state.",
    "example": ""
  },
  {
    "title": "_S5",
    "syntax": "",
    "arguments": "",
    "description": "S5 System State returns values to enter the system into the S5 state.",
    "example": ""
  },
  {
    "title": "_S1D",
    "syntax": "",
    "arguments": "",
    "description": "S1 Device State returns the highest D-state supported by a device when in the S1 state.",
    "example": ""
  },
  {
    "title": "_S2D",
    "syntax": "",
    "arguments": "",
    "description": "S2 Device State returns the highest D-state supported by a device when in the S2 state.",
    "example": ""
  },
  {
    "title": "_S3D",
    "syntax": "",
    "arguments": "",
    "description": "S3 Device State returns the highest D-state supported by a device when in the S3 state.",
    "example": ""
  },
  {
    "title": "_S4D",
    "syntax": "",
    "arguments": "",
    "description": "S4 Device State returns the highest D-state supported by a device when in the S4 state.",
    "example": ""
  },
  {
    "title": "_S0W",
    "syntax": "",
    "arguments": "",
    "description": "S0 Device Wake State returns the lowest D-state that the device can wake itself from S0.\nHeading  ",
    "example": ""
  },
  {
    "title": "_S1W",
    "syntax": "",
    "arguments": "",
    "description": "S1 Device Wake State returns the lowest D-state for this device that can wake the system from S1.",
    "example": ""
  },
  {
    "title": "_S2W",
    "syntax": "",
    "arguments": "",
    "description": "S2 Device Wake State returns the lowest D-state for this device that can wake the system from S2.",
    "example": ""
  },
  {
    "title": "_S3W",
    "syntax": "",
    "arguments": "",
    "description": "S3 Device Wake State returns the lowest D-state for this device that can wake the system from S3.",
    "example": ""
  },
  {
    "title": "_S4W",
    "syntax": "",
    "arguments": "",
    "description": "S4 Device Wake State returns the lowest D-state for this device that can wake the system from S4.",
    "example": ""
  },
  {
    "title": "_SB",
    "syntax": "",
    "arguments": "",
    "description": "System Bus scope for device and bus objects.",
    "example": ""
  },
  {
    "title": "_SBS",
    "syntax": "",
    "arguments": "",
    "description": "Smart Battery Subsystem returns the subsystem configuration.",
    "example": ""
  },
  {
    "title": "_SCP",
    "syntax": "",
    "arguments": "",
    "description": "Set Cooling Policy sets the cooling policy (active or passive).",
    "example": ""
  },
  {
    "title": "_SDD",
    "syntax": "",
    "arguments": "",
    "description": "Set Device Data sets data for a SATA device.",
    "example": ""
  },
  {
    "title": "_SEG",
    "syntax": "",
    "arguments": "",
    "description": "Segment returns a device\u2019s PCI Segment Group number.",
    "example": ""
  },
  {
    "title": "_SHL",
    "syntax": "",
    "arguments": "",
    "description": "Set Hardware Limit sets the hardware limit enforced by the Power Meter.",
    "example": ""
  },
  {
    "title": "_SHR",
    "syntax": "",
    "arguments": "",
    "description": "Sharable interrupt share status, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_SI",
    "syntax": "",
    "arguments": "",
    "description": "System Indicators predefined scope.",
    "example": ""
  },
  {
    "title": "_SIZ",
    "syntax": "",
    "arguments": "",
    "description": "Size DMA transfer size, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_SLI",
    "syntax": "",
    "arguments": "",
    "description": "System Locality Information returns a list of NUMA system localities.",
    "example": ""
  },
  {
    "title": "_SLV",
    "syntax": "",
    "arguments": "",
    "description": "Slave Mode Slave mode setting for a SerialBus connection, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_SPD",
    "syntax": "",
    "arguments": "",
    "description": "Set Post Device sets which video device will be posted at boot.",
    "example": ""
  },
  {
    "title": "_SPE",
    "syntax": "",
    "arguments": "",
    "description": "Connection Speed Connection speed for a SerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_SRS",
    "syntax": "",
    "arguments": "",
    "description": "Set Resource Settings sets a device\u2019s resource allocation.",
    "example": ""
  },
  {
    "title": "_SRT",
    "syntax": "",
    "arguments": "",
    "description": "Set Real Time Sets the current time to a Time and Alarm Control Method Device.",
    "example": ""
  },
  {
    "title": "_SRV",
    "syntax": "",
    "arguments": "",
    "description": "IPMI Spec Revision.  See the Intelligent Platform Management Interface Specification at \u201cLinks to ACPI-Related Documents\u201d (http://uefi.org/acpi) under the heading \"Server Platform Management Interface Table\".\n ",
    "example": ""
  },
  {
    "title": "_SST",
    "syntax": "",
    "arguments": "",
    "description": "System Status sets the system status indicator.",
    "example": ""
  },
  {
    "title": "_STA",
    "syntax": "",
    "arguments": "",
    "description": "Status  (1) returns the current status of a device.\uf020\n(2) Returns the current on or off state of a Power Resource.",
    "example": ""
  },
  {
    "title": "_STB",
    "syntax": "",
    "arguments": "",
    "description": "Stop Bits - Number of stop bits used in a UART SerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_STM",
    "syntax": "",
    "arguments": "",
    "description": "Set Timing Mode sets an IDE controller transfer timings.\nHeading  ",
    "example": ""
  },
  {
    "title": "_STP",
    "syntax": "",
    "arguments": "",
    "description": "Set Expired Timer Wake Policy sets expired timer policies of the wake alarm device.",
    "example": ""
  },
  {
    "title": "_STR",
    "syntax": "",
    "arguments": "",
    "description": "String returns a device\u2019s description string.",
    "example": ""
  },
  {
    "title": "_STV",
    "syntax": "",
    "arguments": "",
    "description": "Set Timer Value set timer values of the wake alarm device.",
    "example": ""
  },
  {
    "title": "_SUB",
    "syntax": "",
    "arguments": "",
    "description": "Supplies OSPM with the device's Subsystem ID. Optional.",
    "example": ""
  },
  {
    "title": "_SUN",
    "syntax": "",
    "arguments": "",
    "description": "Slot User Number returns the slot unique ID number.",
    "example": ""
  },
  {
    "title": "_SWS",
    "syntax": "",
    "arguments": "",
    "description": "System Wake Source returns the source event that caused the system to wake.",
    "example": ""
  },
  {
    "title": "_T_x",
    "syntax": "",
    "arguments": "",
    "description": "Temporary reserved for use by ASL compilers.",
    "example": ""
  },
  {
    "title": "_TC1",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Constant 1 returns TC1 for the passive cooling formula.",
    "example": ""
  },
  {
    "title": "_TC2",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Constant 2 returns TC2 for the passive cooling formula.",
    "example": ""
  },
  {
    "title": "_TDL",
    "syntax": "",
    "arguments": "",
    "description": "T-State Depth Limit returns the _TSS entry number of the lowest power throttling state.",
    "example": ""
  },
  {
    "title": "_TFP",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Fast Sampling Period - returns the thermal sampling period for passive cooling.",
    "example": ""
  },
  {
    "title": "_TIP",
    "syntax": "",
    "arguments": "",
    "description": "Expired Timer Wake Policy returns timer policies of the wake alarm device.",
    "example": ""
  },
  {
    "title": "_TIV",
    "syntax": "",
    "arguments": "",
    "description": "Timer Values returns remaining time of the wake alarm device.",
    "example": ""
  },
  {
    "title": "_TMP",
    "syntax": "",
    "arguments": "",
    "description": "Temperature returns a thermal zone\u2019s current temperature.",
    "example": ""
  },
  {
    "title": "_TPC",
    "syntax": "",
    "arguments": "",
    "description": "Throttling Present Capabilities returns the current number of supported throttling states.",
    "example": ""
  },
  {
    "title": "_TPT",
    "syntax": "",
    "arguments": "",
    "description": "Trip Point Temperature inform AML that a devices\u2019 embedded temperature sensor has crossed a temperature trip point.",
    "example": ""
  },
  {
    "title": "_TRA",
    "syntax": "",
    "arguments": "",
    "description": "Translation address translation offset, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_TRS",
    "syntax": "",
    "arguments": "",
    "description": "Translation Sparse sparse/dense flag, resource descriptor field.",
    "example": ""
  },
  {
    "title": "_TRT",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Relationship Table returns thermal relationships between platform devices.",
    "example": ""
  },
  {
    "title": "_TSD",
    "syntax": "",
    "arguments": "",
    "description": "Throttling State Dependencies returns a list of T-state dependencies.",
    "example": ""
  },
  {
    "title": "_TSF",
    "syntax": "",
    "arguments": "",
    "description": "Type-Specific Flags resource descriptor field.",
    "example": ""
  },
  {
    "title": "_TSN",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Sensor Device - returns a reference to the thermal sensor reporting a zone temperature",
    "example": ""
  },
  {
    "title": "_TSP",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Sampling Period returns the thermal sampling period for passive cooling.",
    "example": ""
  },
  {
    "title": "_TSS",
    "syntax": "",
    "arguments": "",
    "description": "Throttling Supported States returns supported throttling state information.",
    "example": ""
  },
  {
    "title": "_TST",
    "syntax": "",
    "arguments": "",
    "description": "Temperature Sensor Threshold returns the minimum separation for a device\u2019s temperature trip points.",
    "example": ""
  },
  {
    "title": "_TTP",
    "syntax": "",
    "arguments": "",
    "description": "Translation Type translation/static flag, resource descriptor field.\nHeading  ",
    "example": ""
  },
  {
    "title": "_TTS",
    "syntax": "",
    "arguments": "",
    "description": "Transition To State inform AML of an S-state transition.",
    "example": ""
  },
  {
    "title": "_TXL",
    "syntax": "",
    "arguments": "",
    "description": "Transmit Buffer Size Size of the transmit buffer in a UART Serialbus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_TYP",
    "syntax": "",
    "arguments": "",
    "description": "Type DMA channel type (speed), resource descriptor field.",
    "example": ""
  },
  {
    "title": "_TZ",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Zone predefined scope: ACPI 1.0.",
    "example": ""
  },
  {
    "title": "_TZD",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Zone Devices returns a list of device names associated with a Thermal Zone.",
    "example": ""
  },
  {
    "title": "_TZM",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Zone Member returns a reference to the thermal zone of which a device is a member.",
    "example": ""
  },
  {
    "title": "_TZP",
    "syntax": "",
    "arguments": "",
    "description": "Thermal Zone Polling returns a Thermal zone\u2019s polling frequency.",
    "example": ""
  },
  {
    "title": "_UID",
    "syntax": "",
    "arguments": "",
    "description": "Unique ID return a device\u2019s unique persistent ID.",
    "example": ""
  },
  {
    "title": "_UPC",
    "syntax": "",
    "arguments": "",
    "description": "USB Port Capabilities returns a list of USB port capabilities.",
    "example": ""
  },
  {
    "title": "_UPD",
    "syntax": "",
    "arguments": "",
    "description": "User Presence Detect returns user detection information.",
    "example": ""
  },
  {
    "title": "_UPP",
    "syntax": "",
    "arguments": "",
    "description": "User Presence Polling returns the recommended user presence polling interval.",
    "example": ""
  },
  {
    "title": "_VEN",
    "syntax": "",
    "arguments": "",
    "description": "Vendor-defined Data Vendor-defined data for a GPIO or SerialBus connection, resource descriptor field",
    "example": ""
  },
  {
    "title": "_VPO",
    "syntax": "",
    "arguments": "",
    "description": "Video Post Options returns the implemented video post options.",
    "example": ""
  },
  {
    "title": "_WAK",
    "syntax": "",
    "arguments": "",
    "description": "Wake inform AML that the system has just awakened.",
    "example": ""
  },
  {
    "title": "_WPC",
    "syntax": "",
    "arguments": "",
    "description": "Wireless Power Calibration - returns the notifier to wireless power controller",
    "example": ""
  },
  {
    "title": "_WPP",
    "syntax": "",
    "arguments": "",
    "description": "Wireless Power Polling - returns the recommended polling frequency",
    "example": ""
  }
]